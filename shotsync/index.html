<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ShotSync - Basketball Shot Analysis</title>
    <link rel="stylesheet" href="/tool/style.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&family=Work+Sans:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        /* Athletic Theme Overrides - Consistent with Landing Page */

        /* Player Button Hover Effects */
        .player-btn:hover {
            transform: translateY(-4px) !important;
            border-color: var(--primary-color) !important;
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.4) !important;
            background: var(--bg-card) !important;
        }

        .player-btn:active {
            transform: translateY(-2px) !important;
        }

        .custom-btn:hover {
            background: var(--bg-card) !important;
            border-color: var(--primary-hover) !important;
            border-style: solid !important;
        }

        .player-btn {
            outline: none !important;
        }

        .player-btn:focus {
            outline: 3px solid rgba(255, 107, 122, 0.3) !important;
            outline-offset: 2px !important;
        }

        /* Upload Mode Toggle Styles */
        .mode-toggle-btn {
            flex: 1;
            min-width: 140px;
            height: 44px;
            padding: 12px 24px;
            background: var(--bg-card);
            border: 2px solid var(--border-color);
            border-radius: 0;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 14px;
            font-weight: 700;
            font-family: 'Work Sans', sans-serif;
            letter-spacing: 1px;
            text-transform: uppercase;
            color: var(--text-dark);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            white-space: nowrap;
        }

        .mode-toggle-btn.active {
            background: var(--gradient-main);
            color: white;
            border-color: var(--primary-color);
        }

        .mode-toggle-btn:hover:not(.active) {
            border-color: var(--primary-color);
            background: var(--bg-elevated);
            color: var(--text-dark);
        }

        #uploadedFileName {
            font-style: normal;
            padding: 8px 12px;
            background: var(--bg-card);
            border-radius: 0;
            color: var(--text-gray);
            font-size: 13px;
        }

        /* Navbar Tab Styles */
        .nav-tab {
            background: none;
            border: none;
            padding: 10px 20px;
            font-family: 'Work Sans', sans-serif;
            font-size: 13px;
            font-weight: 600;
            letter-spacing: 2px;
            text-transform: uppercase;
            color: var(--text-gray);
            cursor: pointer;
            border-bottom: 3px solid transparent;
            transition: all 0.3s;
        }

        .nav-tab:hover {
            color: var(--primary-color);
        }

        .nav-tab.active {
            color: var(--primary-color);
            border-bottom-color: var(--primary-color);
        }

        /* Analysis Type Button Styles */
        .analysis-type-btn {
            background: var(--bg-card);
            border: 2px solid var(--border-color);
            border-radius: 8px;
            padding: 24px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 10px;
            width: 220px;
            height: 140px;
            color: var(--text-dark);
        }

        .analysis-type-btn:hover {
            border-color: var(--primary-color);
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.3);
        }

        .analysis-type-btn.selected {
            border-color: var(--primary-color);
            background: rgba(255, 107, 122, 0.15);
        }

        .analysis-icon { font-size: 32px; }

        .analysis-title {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 18px;
            letter-spacing: 1px;
            text-transform: uppercase;
        }

        .analysis-desc {
            font-size: 12px;
            color: var(--text-gray);
            text-align: center;
        }

        /* Body Warning Overlay */
        .body-warning-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
            border-radius: 12px;
        }

        .body-warning-overlay .warning-content {
            text-align: center;
            color: white;
            padding: 30px;
        }

        .body-warning-overlay .warning-icon {
            font-size: 48px;
            margin-bottom: 15px;
        }

        .body-warning-overlay h3 {
            color: #FF6B7A;
            font-family: 'Bebas Neue', sans-serif;
            font-size: 24px;
            letter-spacing: 2px;
            margin-bottom: 10px;
        }

        .body-warning-overlay p {
            color: #ccc;
            font-size: 14px;
        }

        /* Video Ready Overlay (neutral - waiting for analysis selection) */
        .video-ready-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
            border-radius: 12px;
        }

        .video-ready-overlay .ready-content {
            text-align: center;
            color: white;
            padding: 30px;
        }

        .video-ready-overlay .ready-icon {
            font-size: 48px;
            margin-bottom: 15px;
        }

        .video-ready-overlay h3 {
            color: #60a5fa;
            font-family: 'Bebas Neue', sans-serif;
            font-size: 24px;
            letter-spacing: 2px;
            margin-bottom: 10px;
        }

        .video-ready-overlay p {
            color: #ccc;
            font-size: 14px;
        }

        /* Running Analysis Overlay (green - actually processing) */
        .analysis-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
            border-radius: 12px;
        }

        .analysis-overlay .analysis-content {
            text-align: center;
            color: white;
            padding: 30px;
        }

        .analysis-overlay .analysis-spinner {
            width: 50px;
            height: 50px;
            border: 4px solid rgba(255, 255, 255, 0.2);
            border-top-color: #4ade80;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .analysis-overlay h3 {
            color: #4ade80;
            font-family: 'Bebas Neue', sans-serif;
            font-size: 24px;
            letter-spacing: 2px;
            margin-bottom: 10px;
        }

        .analysis-overlay p {
            color: #ccc;
            font-size: 14px;
        }

        /* Stat Card Styles */
        .stat-card {
            background: var(--bg-card);
            padding: 24px;
            border-radius: 0;
            box-shadow: none;
            text-align: center;
            border: 1px solid var(--border-color);
            transition: all 0.3s ease;
        }

        .stat-card:hover {
            border-color: rgba(255, 107, 122, 0.3);
        }

        .stat-label {
            font-size: 12px;
            color: var(--text-gray);
            margin-bottom: 12px;
            font-family: 'Work Sans', sans-serif;
            font-weight: 700;
            letter-spacing: 1px;
            text-transform: uppercase;
        }

        .stat-value {
            font-size: 36px;
            font-weight: 400;
            color: var(--primary-color);
            font-family: 'Bebas Neue', sans-serif;
            letter-spacing: 2px;
        }

        /* Badge Card Styles */
        .badge-card {
            background: var(--bg-card);
            padding: 32px;
            border-radius: 0;
            box-shadow: none;
            text-align: center;
            transition: all 0.3s ease;
            border: 1px solid var(--border-color);
        }

        .badge-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 12px 40px rgba(0,0,0,0.4);
            border-color: var(--primary-color);
        }

        .badge-card.locked {
            opacity: 0.5;
        }

        .badge-icon {
            font-size: 64px;
            margin-bottom: 16px;
        }

        .badge-name {
            font-size: 18px;
            font-weight: 400;
            color: var(--text-dark);
            margin-bottom: 10px;
            font-family: 'Bebas Neue', sans-serif;
            letter-spacing: 2px;
            text-transform: uppercase;
        }

        .badge-level {
            font-weight: 700;
            font-family: 'Work Sans', sans-serif;
            font-size: 13px;
            letter-spacing: 1px;
            text-transform: uppercase;
        }

        .badge-level.bronze {
            color: #cd7f32;
        }

        .badge-level.silver {
            color: #c0c0c0;
        }

        .badge-level.gold {
            color: #ffd700;
        }

        .badge-level.none {
            color: var(--text-muted);
        }

        /* Chart Tab Styles */
        .chart-tab {
            background: none;
            border: none;
            padding: 12px 24px;
            font-family: 'Work Sans', sans-serif;
            font-size: 13px;
            font-weight: 700;
            letter-spacing: 1px;
            text-transform: uppercase;
            color: var(--text-gray);
            cursor: pointer;
            border-bottom: 3px solid transparent;
            transition: all 0.3s;
        }

        .chart-tab:hover {
            color: var(--primary-color);
        }

        .chart-tab.active {
            color: var(--primary-color);
            border-bottom-color: var(--primary-color);
        }

        .period-tab {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            padding: 8px 16px;
            font-family: 'Work Sans', sans-serif;
            font-size: 12px;
            font-weight: 600;
            letter-spacing: 1px;
            text-transform: uppercase;
            color: var(--text-gray);
            cursor: pointer;
            border-radius: 0;
            transition: all 0.2s ease;
        }

        .period-tab:hover {
            background: var(--bg-elevated);
            border-color: var(--primary-color);
            color: var(--text-dark);
        }

        .period-tab.active {
            background: var(--gradient-main);
            border-color: var(--primary-color);
            color: white;
        }

        /* Food Log Entry Styles */
        .food-log-entry {
            padding: 16px;
            background: var(--bg-card);
            border-radius: 0;
            display: grid;
            grid-template-columns: 2fr 1fr 1fr 1fr auto;
            gap: 15px;
            align-items: center;
            border: 1px solid var(--border-color);
        }

        .food-log-entry.editing {
            background: rgba(255, 107, 122, 0.1);
            border-color: var(--primary-color);
        }

        .favorite-badge {
            display: inline-block;
            padding: 8px 16px;
            background: var(--bg-card);
            border: 2px solid var(--primary-color);
            border-radius: 0;
            cursor: pointer;
            transition: all 0.3s;
            font-family: 'Work Sans', sans-serif;
            font-size: 13px;
            font-weight: 600;
            letter-spacing: 1px;
            text-transform: uppercase;
            color: var(--primary-color);
        }

        .favorite-badge:hover {
            background: var(--primary-color);
            color: white;
        }

        .favorite-badge input {
            width: 60px;
            padding: 6px;
            border: 1px solid var(--border-color);
            border-radius: 0;
            text-align: center;
            font-family: 'Work Sans', sans-serif;
            background: var(--bg-primary);
            color: var(--text-dark);
        }

        /* ========== Player Match Results UI ========== */
        .player-match-results { display: none; }
        .player-match-results.active { display: block; }

        .pm-grid {
            display: grid;
            grid-template-columns: 1fr 380px;
            gap: 40px;
            align-items: start;
        }

        .pm-left { min-width: 0; }
        .pm-right { position: sticky; top: 20px; }

        .pm-list { display: flex; flex-direction: column; gap: 12px; }

        .pm-row {
            display: flex;
            align-items: center;
            gap: 20px;
            padding: 16px 20px;
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .pm-row:hover { border-color: var(--primary-color); transform: translateX(4px); }
        .pm-row-selected { border: 2px solid var(--primary-color); background: rgba(255, 107, 122, 0.1); }

        .pm-rank { font-family: 'Bebas Neue', sans-serif; font-size: 24px; color: var(--text-gray); min-width: 40px; text-align: center; }
        .pm-rank-1 { font-size: 32px; color: var(--primary-color); }

        .pm-info { flex: 1; min-width: 150px; }
        .pm-name { font-weight: 600; font-size: 16px; margin-bottom: 2px; }
        .pm-archetype { font-size: 13px; color: var(--text-gray); }

        .pm-similarity { flex: 1; max-width: 180px; }
        .pm-score { font-weight: 600; margin-bottom: 6px; font-size: 14px; }
        .pm-bar { height: 6px; background: var(--border-color); border-radius: 3px; overflow: hidden; }
        .pm-fill { height: 100%; background: var(--primary-color); border-radius: 3px; }

        .pm-stats { display: flex; gap: 16px; font-size: 13px; color: var(--text-gray); }
        .pm-stats span { white-space: nowrap; }

        /* User Archetype Card */
        .pm-archetype-card {
            background: var(--bg-card);
            border: 2px solid var(--primary-color);
            border-radius: 16px;
            padding: 30px;
            text-align: center;
            margin-bottom: 24px;
        }
        .pm-arch-label { font-size: 12px; text-transform: uppercase; letter-spacing: 2px; color: var(--text-gray); margin-bottom: 12px; }
        .pm-arch-name { font-family: 'Bebas Neue', sans-serif; font-size: 42px; letter-spacing: 2px; color: var(--primary-color); margin-bottom: 12px; }
        .pm-arch-desc { color: var(--text-gray); font-size: 14px; line-height: 1.6; }

        /* Traits & Differences */
        .pm-traits, .pm-differences {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 24px;
            margin-bottom: 16px;
        }
        .pm-section-header { display: flex; align-items: center; gap: 10px; margin-bottom: 16px; padding-bottom: 12px; border-bottom: 1px solid var(--border-color); }
        .pm-section-title { font-size: 14px; font-weight: 600; }
        .pm-player-name { color: var(--primary-color); font-size: 14px; }

        .pm-trait-item, .pm-diff-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px 12px;
            background: var(--bg-dark);
            border-radius: 8px;
            margin-bottom: 12px;
        }
        .pm-trait-item:last-child, .pm-diff-item:last-child { margin-bottom: 0; }

        .pm-trait-icon, .pm-diff-icon {
            width: 32px; height: 32px;
            display: flex; align-items: center; justify-content: center;
            border-radius: 6px; font-size: 16px;
        }
        .pm-trait-icon { background: rgba(255, 107, 122, 0.15); }
        .pm-diff-icon { background: rgba(251, 191, 36, 0.15); }

        .pm-trait-text, .pm-diff-text { flex: 1; }
        .pm-trait-name, .pm-diff-name { font-weight: 500; font-size: 14px; margin-bottom: 2px; }
        .pm-trait-detail, .pm-diff-detail { font-size: 12px; color: var(--text-gray); }
        .pm-trait-match { font-size: 13px; font-weight: 600; color: var(--success-color); }
        .pm-diff-gap { font-size: 13px; font-weight: 600; color: var(--warning-color); }

        /* Quick Fixes */
        .pm-fixes-header { font-family: 'Bebas Neue', sans-serif; font-size: 20px; letter-spacing: 1px; margin: 24px 0 16px; display: flex; align-items: center; gap: 10px; }
        .pm-fix-item { background: var(--bg-card); border: 1px solid var(--border-color); border-radius: 12px; overflow: hidden; margin-bottom: 12px; }
        .pm-fix-toggle {
            width: 100%; background: none; border: none; padding: 16px 20px;
            cursor: pointer; display: flex; align-items: center; gap: 16px;
            color: var(--text-light); transition: all 0.2s ease;
        }
        .pm-fix-toggle:hover { background: rgba(255, 107, 122, 0.05); }
        .pm-fix-item.active .pm-fix-toggle { background: rgba(255, 107, 122, 0.1); }

        .pm-fix-icon { width: 40px; height: 40px; display: flex; align-items: center; justify-content: center; background: rgba(255, 107, 122, 0.15); border-radius: 8px; font-size: 20px; }
        .pm-fix-content { flex: 1; text-align: left; }
        .pm-fix-title { font-weight: 600; font-size: 15px; margin-bottom: 4px; }
        .pm-fix-tip { font-size: 13px; color: var(--text-gray); }
        .pm-fix-arrow { font-size: 16px; color: var(--text-gray); transition: transform 0.3s ease; }
        .pm-fix-item.active .pm-fix-arrow { transform: rotate(180deg); color: var(--primary-color); }

        .pm-drill-content { display: none; padding: 0 20px 20px 20px; }
        .pm-fix-item.active .pm-drill-content { display: block; }
        .pm-drill-card { background: var(--bg-dark); border-radius: 10px; padding: 20px; border: 1px solid var(--border-color); }
        .pm-drill-label { font-size: 11px; text-transform: uppercase; letter-spacing: 1px; color: var(--primary-color); margin-bottom: 8px; }
        .pm-drill-name { font-weight: 600; font-size: 16px; margin-bottom: 10px; }
        .pm-drill-desc { font-size: 13px; color: var(--text-gray); line-height: 1.6; margin-bottom: 14px; }
        .pm-drill-meta { display: flex; gap: 16px; font-size: 12px; color: var(--text-gray); }

        @media (max-width: 900px) {
            .pm-grid { grid-template-columns: 1fr; }
            .pm-right { position: static; order: -1; }
        }
    </style>
    <!-- MediaPipe -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js" crossorigin="anonymous"></script>
    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation"></script>
    <!-- Google Calendar API -->
    <script src="https://apis.google.com/js/api.js" onload="window.gapiLoaded && window.gapiLoaded()" onerror="console.error('Failed to load Google API')"></script>
    <script>
        window.gapiLoaded = function() {
            console.log('Google API loaded');
        };
    </script>
    <!-- EmailJS -->
    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/@emailjs/browser@4/dist/email.min.js"></script>
    <!-- Firebase -->
    <script type="module">
        // Import Firebase modules
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
        import { getAuth, GoogleAuthProvider, signInWithPopup, signOut, onAuthStateChanged } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js';
        import { getFirestore, collection, addDoc, getDocs, query, where, orderBy, limit, doc, getDoc, setDoc, updateDoc, deleteDoc, serverTimestamp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js';
        
        // Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyBnM_7z6rqd0Wnv3LdnTWDtiy_pKiWZeso",
            authDomain: "shotsyn-c24ae.firebaseapp.com",
            projectId: "shotsyn-c24ae",
            storageBucket: "shotsyn-c24ae.firebasestorage.app",
            messagingSenderId: "845157536043",
            appId: "1:845157536043:web:945c7961316be19549b56e"
        };
        
        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        const googleProvider = new GoogleAuthProvider();
        
        // Make Firebase available globally
        window.firebaseAuth = auth;
        window.firebaseDB = db;
        window.googleProvider = googleProvider;
        window.signInWithGoogle = async () => {
            try {
                console.log('signInWithGoogle called');
                if (!auth) {
                    throw new Error('Firebase auth is not initialized');
                }
                if (!googleProvider) {
                    throw new Error('Google provider is not initialized');
                }
                
                console.log('Calling signInWithPopup...');
                const result = await signInWithPopup(auth, googleProvider);
                const user = result.user;
                console.log('Sign-in popup completed, user:', user);
                console.log('User UID:', user.uid);
                console.log('User email:', user.email);
                
                // Verify user is actually signed in
                const currentUser = auth.currentUser;
                if (!currentUser || currentUser.uid !== user.uid) {
                    console.error('User not properly authenticated after sign-in');
                    throw new Error('Authentication failed: User not properly signed in');
                }
                
                console.log('User successfully authenticated');
                return {
                    firstName: user.displayName?.split(' ')[0] || '',
                    lastName: user.displayName?.split(' ').slice(1).join(' ') || '',
                    email: user.email || ''
                };
            } catch (error) {
                console.error('Error signing in:', error);
                console.error('Error details:', {
                    code: error.code,
                    message: error.message,
                    email: error.email,
                    credential: error.credential
                });
                throw error;
            }
        };
        window.signOutUser = () => signOut(auth);
        window.onAuthStateChangedHandler = onAuthStateChanged;
        window.saveUserEmail = async (email, firstName, lastName) => {
            try {
                const user = auth.currentUser;
                if (user) {
                    await addDoc(collection(db, 'users'), {
                        userId: user.uid,
                        email: email,
                        firstName: firstName,
                        lastName: lastName,
                        createdAt: serverTimestamp()
                    });
                }
            } catch (error) {
                console.error('Error saving email:', error);
            }
        };
        window.saveAnalysis = async (userId, analysisData) => {
            try {
                await addDoc(collection(db, 'analyses'), {
                    userId: userId,
                    ...analysisData,
                    createdAt: serverTimestamp()
                });
            } catch (error) {
                console.error('Error saving analysis:', error);
            }
        };
        
        // Save similarity score to training database
        window.saveSimilarityScore = async (userId, player, similarityScore) => {
            try {
                await addDoc(collection(db, 'trainingScores'), {
                    userId: userId,
                    player: player,
                    similarityScore: similarityScore,
                    createdAt: serverTimestamp()
                });
            } catch (error) {
                console.error('Error saving similarity score:', error);
            }
        };
        
        // Save shot tracker data to training database
        window.saveShotTrackerToTrainingDb = async (userId, shotData) => {
            try {
                console.log('Saving shot tracker data:', { userId, shotCount: shotData.shots.length });
                
                // Calculate statistics
                const makes = shotData.shots.filter(s => s.is_make || s.result === 'make').length;
                const attempts = shotData.shots.length;
                const percentage = attempts > 0 ? Math.round((makes / attempts) * 100) : 0;
                
                // Prepare shot locations data
                const shotLocations = shotData.shots.map(shot => ({
                    x: parseFloat(shot.x) || 0.5,
                    y: parseFloat(shot.y) || 0.5,
                    is_make: shot.is_make || shot.result === 'make',
                    timestamp: shot.timestamp || Date.now()
                }));
                
                console.log('Prepared data:', { makes, attempts, percentage, shotLocationsCount: shotLocations.length });
                
                // Save to training database with shot locations
                const docRef = await addDoc(collection(window.firebaseDB, 'trainingScores'), {
                    userId: userId,
                    player: 'shot_tracker', // Special identifier for shot tracker sessions
                    similarityScore: percentage, // Use percentage as similarity score
                    makes: makes,
                    attempts: attempts,
                    shotLocations: shotLocations,
                    sessionType: 'shot_tracker',
                    createdAt: serverTimestamp()
                });
                
                console.log('Successfully saved to Firebase with ID:', docRef.id);
                return { success: true, makes, attempts, percentage };
            } catch (error) {
                console.error('Error saving shot tracker to training database:', error);
                console.error('Error details:', {
                    code: error.code,
                    message: error.message,
                    stack: error.stack
                });
                throw error;
            }
        };
        
        // Get training scores for a user
        window.getTrainingScores = async (userId, player = null) => {
            try {
                let q;
                if (player) {
                    q = query(collection(db, 'trainingScores'), where('userId', '==', userId), where('player', '==', player));
                } else {
                    q = query(collection(db, 'trainingScores'), where('userId', '==', userId));
                }
                const querySnapshot = await getDocs(q);
                const scores = [];
                querySnapshot.forEach((doc) => {
                    scores.push({ id: doc.id, ...doc.data() });
                });
                // Sort by createdAt descending (client-side if orderBy fails)
                scores.sort((a, b) => {
                    const aTime = a.createdAt?.toDate ? a.createdAt.toDate().getTime() : (a.createdAt?.seconds || 0) * 1000;
                    const bTime = b.createdAt?.toDate ? b.createdAt.toDate().getTime() : (b.createdAt?.seconds || 0) * 1000;
                    return bTime - aTime;
                });
                return scores;
            } catch (error) {
                console.error('Error getting training scores:', error);
                // If index error, try without orderBy
                try {
                    let q = query(collection(db, 'trainingScores'), where('userId', '==', userId));
                    if (player) {
                        q = query(collection(db, 'trainingScores'), where('userId', '==', userId), where('player', '==', player));
                    }
                    const querySnapshot = await getDocs(q);
                    const scores = [];
                    querySnapshot.forEach((doc) => {
                        scores.push({ id: doc.id, ...doc.data() });
                    });
                    scores.sort((a, b) => {
                        const aTime = a.createdAt?.toDate ? a.createdAt.toDate().getTime() : (a.createdAt?.seconds || 0) * 1000;
                        const bTime = b.createdAt?.toDate ? b.createdAt.toDate().getTime() : (b.createdAt?.seconds || 0) * 1000;
                        return bTime - aTime;
                    });
                    return scores;
                } catch (retryError) {
                    console.error('Error retrying query:', retryError);
                    return [];
                }
            }
        };
        
        // Track login streak
        window.updateLoginStreak = async (userId) => {
            try {
                const userRef = doc(db, 'users', userId);
                const userDoc = await getDoc(userRef);
                const today = new Date().toDateString();
                
                if (userDoc.exists()) {
                    const userData = userDoc.data();
                    const lastLogin = userData.lastLoginDate;
                    const currentStreak = userData.loginStreak || 0;
                    
                    if (lastLogin === today) {
                        // Already logged in today
                        return currentStreak;
                    }
                    
                    const yesterday = new Date();
                    yesterday.setDate(yesterday.getDate() - 1);
                    const yesterdayStr = yesterday.toDateString();
                    
                    let newStreak = 1;
                    if (lastLogin === yesterdayStr) {
                        // Continuing streak
                        newStreak = currentStreak + 1;
                    }
                    
                    await updateDoc(userRef, {
                        lastLoginDate: today,
                        loginStreak: newStreak
                    });
                    
                    return newStreak;
                } else {
                    // First login
                    await setDoc(userRef, {
                        lastLoginDate: today,
                        loginStreak: 1
                    }, { merge: true });
                    return 1;
                }
            } catch (error) {
                console.error('Error updating login streak:', error);
                return 0;
            }
        };
        
        // Get user badges
        window.getUserBadges = async (userId) => {
            try {
                const userRef = doc(db, 'users', userId);
                const userDoc = await getDoc(userRef);
                if (userDoc.exists()) {
                    return userDoc.data().badges || {};
                }
                return {};
            } catch (error) {
                console.error('Error getting user badges:', error);
                return {};
            }
        };
        
        // Award badge
        window.awardBadge = async (userId, badgeType, level) => {
            try {
                const userRef = doc(db, 'users', userId);
                const userDoc = await getDoc(userRef);
                const badges = userDoc.exists() ? (userDoc.data().badges || {}) : {};
                
                // Only award if user doesn't already have this badge at this level or higher
                const currentLevel = badges[badgeType] || 'none';
                const levels = { 'none': 0, 'bronze': 1, 'silver': 2, 'gold': 3 };
                
                if (levels[level] > levels[currentLevel]) {
                    badges[badgeType] = level;
                    await updateDoc(userRef, {
                        badges: badges
                    }, { merge: true });
                    return true;
                }
                return false;
            } catch (error) {
                console.error('Error awarding badge:', error);
                return false;
            }
        };
        
        // Save nutrition goals
        window.saveNutritionGoals = async (userId, calorieGoal, idealWeight, proteinGoal) => {
            try {
                const userRef = doc(db, 'users', userId);
                await updateDoc(userRef, {
                    nutritionGoals: {
                        calorieGoal: calorieGoal,
                        idealWeight: idealWeight,
                        proteinGoal: proteinGoal
                    }
                }, { merge: true });
                return true;
            } catch (error) {
                console.error('Error saving nutrition goals:', error);
                return false;
            }
        };
        
        // Get nutrition goals
        window.getNutritionGoals = async (userId) => {
            try {
                const userRef = doc(db, 'users', userId);
                const userDoc = await getDoc(userRef);
                if (userDoc.exists()) {
                    return userDoc.data().nutritionGoals || { calorieGoal: 2000, idealWeight: 150, proteinGoal: 150 };
                }
                return { calorieGoal: 2000, idealWeight: 150, proteinGoal: 150 };
            } catch (error) {
                console.error('Error getting nutrition goals:', error);
                return { calorieGoal: 2000, idealWeight: 150, proteinGoal: 150 };
            }
        };
        
        // Save food entry
        window.saveFoodEntry = async (userId, foodData) => {
            try {
                await addDoc(collection(db, 'nutritionEntries'), {
                    userId: userId,
                    ...foodData,
                    createdAt: serverTimestamp()
                });
                return true;
            } catch (error) {
                console.error('Error saving food entry:', error);
                return false;
            }
        };
        
        // Save global benchmark (for all users)
        window.saveGlobalBenchmark = async (benchmarkData) => {
            try {
                console.log('ðŸ’¾ Attempting to save global benchmark to Firebase...');
                console.log('Benchmark data length:', benchmarkData?.length || 0);
                
                if (!benchmarkData || benchmarkData.length === 0) {
                    console.error('âŒ Cannot save: benchmark data is empty');
                    return false;
                }
                
                // Convert nested arrays to Firebase-compatible format
                // Firebase doesn't support nested arrays, so we need to convert landmarks arrays
                const firebaseCompatibleData = benchmarkData.map(frame => {
                    // Convert landmarks array of arrays to array of objects
                    const landmarks = frame.landmarks.map((landmark, index) => {
                        if (Array.isArray(landmark) && landmark.length >= 3) {
                            return {
                                x: landmark[0],
                                y: landmark[1],
                                z: landmark[2],
                                index: index
                            };
                        }
                        return {
                            x: landmark?.x || 0,
                            y: landmark?.y || 0,
                            z: landmark?.z || 0,
                            index: index
                        };
                    });
                    
                    return {
                        state: frame.state,
                        time: frame.time,
                        elbow_angle: frame.elbow_angle,
                        wrist_angle: frame.wrist_angle,
                        arm_angle: frame.arm_angle,
                        landmarks: landmarks
                    };
                });
                
                const benchmarkRef = doc(db, 'globalBenchmark', 'custom');
                await setDoc(benchmarkRef, {
                    data: firebaseCompatibleData,
                    updatedAt: serverTimestamp(),
                    frameCount: firebaseCompatibleData.length
                }, { merge: true });
                
                console.log('âœ… Global benchmark saved successfully to Firebase');
                console.log('Saved to path: globalBenchmark/custom');
                console.log('Frame count:', firebaseCompatibleData.length);
                return true;
            } catch (error) {
                console.error('âŒ Error saving global benchmark:', error);
                console.error('Error details:', error.message, error.code);
                return false;
            }
        };
        
        // Get global benchmark (for all users)
        window.getGlobalBenchmark = async () => {
            try {
                const benchmarkRef = doc(db, 'globalBenchmark', 'custom');
                const benchmarkDoc = await getDoc(benchmarkRef);
                if (benchmarkDoc.exists()) {
                    const data = benchmarkDoc.data();
                    const firebaseData = data.data || [];
                    console.log('âœ… Global benchmark loaded:', firebaseData.length, 'frames');
                    
                    // Convert Firebase format back to original format (landmarks as arrays)
                    const convertedData = firebaseData.map(frame => {
                        // Convert landmarks from objects back to arrays
                        const landmarks = frame.landmarks.map(landmark => {
                            if (landmark && typeof landmark === 'object' && 'x' in landmark) {
                                return [landmark.x, landmark.y, landmark.z];
                            }
                            return landmark; // Already in array format
                        });
                        
                        return {
                            state: frame.state,
                            time: frame.time,
                            elbow_angle: frame.elbow_angle,
                            wrist_angle: frame.wrist_angle,
                            arm_angle: frame.arm_angle,
                            landmarks: landmarks
                        };
                    });
                    
                    return convertedData;
                }
                console.log('No global benchmark found');
                return null;
            } catch (error) {
                console.error('Error getting global benchmark:', error);
                return null;
            }
        };
        
        // Get nutrition entries for a date
        window.getNutritionEntries = async (userId, date = null) => {
            try {
                const targetDate = date || new Date().toDateString();
                let q = query(collection(db, 'nutritionEntries'), where('userId', '==', userId));
                const querySnapshot = await getDocs(q);
                const entries = [];
                querySnapshot.forEach((doc) => {
                    const data = doc.data();
                    const entryDate = data.createdAt?.toDate ? data.createdAt.toDate().toDateString() : new Date().toDateString();
                    if (entryDate === targetDate) {
                        entries.push({ id: doc.id, ...data });
                    }
                });
                // Sort by time (most recent first)
                entries.sort((a, b) => {
                    const aTime = a.createdAt?.toDate ? a.createdAt.toDate().getTime() : 0;
                    const bTime = b.createdAt?.toDate ? b.createdAt.toDate().getTime() : 0;
                    return bTime - aTime;
                });
                return entries;
            } catch (error) {
                console.error('Error getting nutrition entries:', error);
                return [];
            }
        };
        
        // Get all nutrition entries for chart
        window.getAllNutritionEntries = async (userId) => {
            try {
                let q = query(collection(db, 'nutritionEntries'), where('userId', '==', userId));
                const querySnapshot = await getDocs(q);
                const entries = [];
                querySnapshot.forEach((doc) => {
                    entries.push({ id: doc.id, ...doc.data() });
                });
                // Sort by date
                entries.sort((a, b) => {
                    const aTime = a.createdAt?.toDate ? a.createdAt.toDate().getTime() : 0;
                    const bTime = b.createdAt?.toDate ? b.createdAt.toDate().getTime() : 0;
                    return aTime - bTime;
                });
                return entries;
            } catch (error) {
                console.error('Error getting all nutrition entries:', error);
                return [];
            }
        };
        
        // Save weight entry
        window.saveWeightEntry = async (userId, weight, date = null) => {
            try {
                const entryDate = date || new Date().toDateString();
                await addDoc(collection(db, 'weightEntries'), {
                    userId: userId,
                    weight: weight,
                    date: entryDate,
                    createdAt: serverTimestamp()
                });
                return true;
            } catch (error) {
                console.error('Error saving weight entry:', error);
                return false;
            }
        };
        
        // Get weight entries
        window.getWeightEntries = async (userId) => {
            try {
                let q = query(collection(db, 'weightEntries'), where('userId', '==', userId));
                const querySnapshot = await getDocs(q);
                const entries = [];
                querySnapshot.forEach((doc) => {
                    entries.push({ id: doc.id, ...doc.data() });
                });
                entries.sort((a, b) => {
                    const aTime = a.createdAt?.toDate ? a.createdAt.toDate().getTime() : 0;
                    const bTime = b.createdAt?.toDate ? b.createdAt.toDate().getTime() : 0;
                    return aTime - bTime;
                });
                return entries;
            } catch (error) {
                console.error('Error getting weight entries:', error);
                return [];
            }
        };
        
        // Save favorite food
        window.saveFavoriteFood = async (userId, favoriteData) => {
            try {
                const userRef = doc(db, 'users', userId);
                const userDoc = await getDoc(userRef);
                const favorites = userDoc.exists() ? (userDoc.data().favoriteFoods || []) : [];
                
                // Check if favorite already exists
                const existingIndex = favorites.findIndex(f => f.name.toLowerCase() === favoriteData.name.toLowerCase());
                if (existingIndex !== -1) {
                    favorites[existingIndex] = favoriteData;
                } else {
                    favorites.push(favoriteData);
                }
                
                await updateDoc(userRef, {
                    favoriteFoods: favorites
                }, { merge: true });
                return true;
            } catch (error) {
                console.error('Error saving favorite food:', error);
                return false;
            }
        };
        
        // Get favorite foods
        window.getFavoriteFoods = async (userId) => {
            try {
                const userRef = doc(db, 'users', userId);
                const userDoc = await getDoc(userRef);
                if (userDoc.exists()) {
                    return userDoc.data().favoriteFoods || [];
                }
                return [];
            } catch (error) {
                console.error('Error getting favorite foods:', error);
                return [];
            }
        };
        
        // Delete favorite food
        window.deleteFavoriteFood = async (userId, favoriteName) => {
            try {
                const userRef = doc(db, 'users', userId);
                const userDoc = await getDoc(userRef);
                if (userDoc.exists()) {
                    const favorites = userDoc.data().favoriteFoods || [];
                    const updatedFavorites = favorites.filter(f => f.name !== favoriteName);
                    await updateDoc(userRef, {
                        favoriteFoods: updatedFavorites
                    }, { merge: true });
                    return true;
                }
                return false;
            } catch (error) {
                console.error('Error deleting favorite food:', error);
                return false;
            }
        };
        
        // Delete food entry from database
        window.deleteFoodEntryFromDB = async (entryId) => {
            try {
                await deleteDoc(doc(db, 'nutritionEntries', entryId));
                return true;
            } catch (error) {
                console.error('Error deleting food entry:', error);
                return false;
            }
        };
        
        // Update food entry
        window.updateFoodEntry = async (entryId, foodData) => {
            try {
                const entryRef = doc(db, 'nutritionEntries', entryId);
                await updateDoc(entryRef, foodData);
                return true;
            } catch (error) {
                console.error('Error updating food entry:', error);
                return false;
            }
        };
        
        // Save workout entry
        window.saveWorkoutEntry = async (userId, workoutData) => {
            try {
                await addDoc(collection(db, 'workoutEntries'), {
                    userId: userId,
                    ...workoutData,
                    createdAt: serverTimestamp()
                });
                return true;
            } catch (error) {
                console.error('Error saving workout entry:', error);
                return false;
            }
        };
        
        // Get workout entries for a specific date (defaults to today)
        window.getWorkoutEntries = async (userId, date = null) => {
            try {
                const targetDate = date || new Date().toDateString();
                let q = query(collection(db, 'workoutEntries'), where('userId', '==', userId));
                const querySnapshot = await getDocs(q);
                const entries = [];
                querySnapshot.forEach(doc => {
                    const data = doc.data();
                    const entryDate = data.createdAt?.toDate ? data.createdAt.toDate().toDateString() : new Date().toDateString();
                    if (entryDate === targetDate) {
                        entries.push({
                            id: doc.id,
                            ...data
                        });
                    }
                });
                return entries;
            } catch (error) {
                console.error('Error getting workout entries:', error);
                return [];
            }
        };
        
        // Get all workout entries for a user
        window.getAllWorkoutEntries = async (userId) => {
            try {
                let q = query(collection(db, 'workoutEntries'), where('userId', '==', userId));
                const querySnapshot = await getDocs(q);
                const entries = [];
                querySnapshot.forEach(doc => {
                    entries.push({
                        id: doc.id,
                        ...doc.data()
                    });
                });
                return entries;
            } catch (error) {
                console.error('Error getting all workout entries:', error);
                return [];
            }
        };
        
        // Delete workout entry from database
        window.deleteWorkoutEntryFromDB = async (entryId) => {
            try {
                await deleteDoc(doc(db, 'workoutEntries', entryId));
                return true;
            } catch (error) {
                console.error('Error deleting workout entry:', error);
                return false;
            }
        };
        
        // Update workout entry
        window.updateWorkoutEntry = async (entryId, workoutData) => {
            try {
                const entryRef = doc(db, 'workoutEntries', entryId);
                await updateDoc(entryRef, workoutData);
                return true;
            } catch (error) {
                console.error('Error updating workout entry:', error);
                return false;
            }
        };
        
        // Weekly Schedule Functions
        window.saveWeeklySchedule = async (userId, scheduleData) => {
            try {
                const userRef = doc(db, 'users', userId);
                await updateDoc(userRef, {
                    weeklySchedule: scheduleData
                }, { merge: true });
                return true;
            } catch (error) {
                console.error('Error saving weekly schedule:', error);
                return false;
            }
        };
        
        window.getWeeklySchedule = async (userId) => {
            try {
                const userRef = doc(db, 'users', userId);
                const userDoc = await getDoc(userRef);
                if (userDoc.exists()) {
                    return userDoc.data().weeklySchedule || {};
                }
                return {};
            } catch (error) {
                console.error('Error getting weekly schedule:', error);
                return {};
            }
        };
        
        // Custom Gym Workout Functions
        window.saveCustomGymWorkout = async (userId, workoutData) => {
            try {
                await addDoc(collection(db, 'customGymWorkouts'), {
                    userId: userId,
                    ...workoutData,
                    createdAt: serverTimestamp()
                });
                return true;
            } catch (error) {
                console.error('Error saving custom gym workout:', error);
                return false;
            }
        };
        
        window.getCustomGymWorkouts = async (userId) => {
            try {
                let q = query(collection(db, 'customGymWorkouts'), where('userId', '==', userId));
                const querySnapshot = await getDocs(q);
                const workouts = [];
                querySnapshot.forEach(doc => {
                    workouts.push({
                        id: doc.id,
                        ...doc.data()
                    });
                });
                return workouts;
            } catch (error) {
                console.error('Error getting custom gym workouts:', error);
                return [];
            }
        };
        
        window.updateCustomGymWorkout = async (workoutId, workoutData) => {
            try {
                const workoutRef = doc(db, 'customGymWorkouts', workoutId);
                await updateDoc(workoutRef, workoutData);
                return true;
            } catch (error) {
                console.error('Error updating custom gym workout:', error);
                return false;
            }
        };
        
        window.deleteCustomGymWorkout = async (workoutId) => {
            try {
                await deleteDoc(doc(db, 'customGymWorkouts', workoutId));
                return true;
            } catch (error) {
                console.error('Error deleting custom gym workout:', error);
                return false;
            }
        };
        
        // Custom Sports Workout Functions
        window.saveCustomSportsWorkout = async (userId, workoutData) => {
            try {
                await addDoc(collection(db, 'customSportsWorkouts'), {
                    userId: userId,
                    ...workoutData,
                    createdAt: serverTimestamp()
                });
                return true;
            } catch (error) {
                console.error('Error saving custom sports workout:', error);
                return false;
            }
        };
        
        window.getCustomSportsWorkouts = async (userId) => {
            try {
                let q = query(collection(db, 'customSportsWorkouts'), where('userId', '==', userId));
                const querySnapshot = await getDocs(q);
                const workouts = [];
                querySnapshot.forEach(doc => {
                    workouts.push({
                        id: doc.id,
                        ...doc.data()
                    });
                });
                return workouts;
            } catch (error) {
                console.error('Error getting custom sports workouts:', error);
                return [];
            }
        };
        
        window.updateCustomSportsWorkout = async (workoutId, workoutData) => {
            try {
                const workoutRef = doc(db, 'customSportsWorkouts', workoutId);
                await updateDoc(workoutRef, workoutData);
                return true;
            } catch (error) {
                console.error('Error updating custom sports workout:', error);
                return false;
            }
        };
        
        window.deleteCustomSportsWorkout = async (workoutId) => {
            try {
                await deleteDoc(doc(db, 'customSportsWorkouts', workoutId));
                return true;
            } catch (error) {
                console.error('Error deleting custom sports workout:', error);
                return false;
            }
        };
        
        // Custom Diet Plan Functions
        window.saveCustomDietPlan = async (userId, dietPlanData) => {
            try {
                await addDoc(collection(db, 'customDietPlans'), {
                    userId: userId,
                    ...dietPlanData,
                    createdAt: serverTimestamp()
                });
                return true;
            } catch (error) {
                console.error('Error saving custom diet plan:', error);
                return false;
            }
        };
        
        window.getCustomDietPlans = async (userId) => {
            try {
                let q = query(collection(db, 'customDietPlans'), where('userId', '==', userId));
                const querySnapshot = await getDocs(q);
                const dietPlans = [];
                querySnapshot.forEach(doc => {
                    dietPlans.push({
                        id: doc.id,
                        ...doc.data()
                    });
                });
                return dietPlans;
            } catch (error) {
                console.error('Error getting custom diet plans:', error);
                return [];
            }
        };
        
        window.updateCustomDietPlan = async (dietPlanId, dietPlanData) => {
            try {
                const dietPlanRef = doc(db, 'customDietPlans', dietPlanId);
                await updateDoc(dietPlanRef, dietPlanData);
                return true;
            } catch (error) {
                console.error('Error updating custom diet plan:', error);
                return false;
            }
        };
        
        window.deleteCustomDietPlan = async (dietPlanId) => {
            try {
                await deleteDoc(doc(db, 'customDietPlans', dietPlanId));
                return true;
            } catch (error) {
                console.error('Error deleting custom diet plan:', error);
                return false;
            }
        };
        
        // Check and award all badges based on user's training data
        window.checkAllBadges = async (userId) => {
            try {
                const scores = await window.getTrainingScores(userId);
                if (scores.length === 0) return;
                
                const badges = await window.getUserBadges(userId);
                const today = new Date().toDateString();
                
                // Get user document to check session dates
                const userRef = doc(db, 'users', userId);
                const userDoc = await getDoc(userRef);
                const userData = userDoc.exists() ? userDoc.data() : {};
                
                // Calculate statistics
                const totalSessions = scores.length;
                const scoreValues = scores.map(s => s.similarityScore);
                const maxScore = Math.max(...scoreValues);
                const avgScore = scoreValues.reduce((a, b) => a + b, 0) / scoreValues.length;
                
                // Group scores by player
                const playerScores = {};
                scores.forEach(score => {
                    const player = score.player || 'custom';
                    if (!playerScores[player]) playerScores[player] = [];
                    playerScores[player].push(score);
                });
                
                // Get unique players tried
                const uniquePlayers = Object.keys(playerScores);
                const playersWithHighScores = uniquePlayers.filter(player => {
                    const playerMax = Math.max(...playerScores[player].map(s => s.similarityScore));
                    return playerMax >= 85;
                });
                
                // Calculate improvements
                const recentScores = scoreValues.slice(0, 5);
                const olderScores = scoreValues.slice(5, 10);
                const recentAvg = recentScores.length > 0 ? recentScores.reduce((a, b) => a + b, 0) / recentScores.length : 0;
                const olderAvg = olderScores.length > 0 ? olderScores.reduce((a, b) => a + b, 0) / olderScores.length : 0;
                const improvement = recentAvg > 0 && olderAvg > 0 ? recentAvg - olderAvg : 0;
                
                // Check consecutive days with sessions
                const sessionDates = scores.map(s => {
                    const date = s.createdAt?.toDate ? s.createdAt.toDate() : new Date();
                    return date.toDateString();
                });
                const uniqueDates = [...new Set(sessionDates)];
                uniqueDates.sort((a, b) => new Date(a) - new Date(b));
                
                let consecutiveDays = 1;
                let maxConsecutive = 1;
                for (let i = 1; i < uniqueDates.length; i++) {
                    const prevDate = new Date(uniqueDates[i - 1]);
                    const currDate = new Date(uniqueDates[i]);
                    const daysDiff = (currDate - prevDate) / (1000 * 60 * 60 * 24);
                    if (daysDiff === 1) {
                        consecutiveDays++;
                        maxConsecutive = Math.max(maxConsecutive, consecutiveDays);
                    } else {
                        consecutiveDays = 1;
                    }
                }
                
                // Check last 5 consecutive scores
                const last5Scores = scoreValues.slice(0, 5);
                const allLast5High = last5Scores.length === 5 && last5Scores.every(s => s >= 85);
                const last5Consecutive = last5Scores.length === 5 && last5Scores.every(s => s >= 80);
                
                // Practice Warrior badges (total sessions)
                if (totalSessions >= 10 && totalSessions < 50 && (!badges.practiceWarrior || badges.practiceWarrior === 'none')) {
                    await window.awardBadge(userId, 'practiceWarrior', 'bronze');
                } else if (totalSessions >= 50 && totalSessions < 100 && (!badges.practiceWarrior || badges.practiceWarrior === 'bronze')) {
                    await window.awardBadge(userId, 'practiceWarrior', 'silver');
                } else if (totalSessions >= 100 && badges.practiceWarrior !== 'gold') {
                    await window.awardBadge(userId, 'practiceWarrior', 'gold');
                }
                
                // Milestone badges
                if (totalSessions >= 50 && totalSessions < 100 && !badges.halfCentury) {
                    await window.awardBadge(userId, 'halfCentury', 'bronze');
                } else if (totalSessions >= 100 && totalSessions < 300 && badges.halfCentury !== 'silver') {
                    await window.awardBadge(userId, 'halfCentury', 'silver');
                } else if (totalSessions >= 300 && badges.halfCentury !== 'gold') {
                    await window.awardBadge(userId, 'halfCentury', 'gold');
                }
                
                // First Steps
                if (totalSessions >= 1 && totalSessions < 5 && !badges.firstSteps) {
                    await window.awardBadge(userId, 'firstSteps', 'bronze');
                } else if (totalSessions >= 5 && totalSessions < 10 && (!badges.firstSteps || badges.firstSteps === 'bronze')) {
                    await window.awardBadge(userId, 'firstSteps', 'silver');
                } else if (totalSessions >= 10 && badges.firstSteps !== 'gold') {
                    await window.awardBadge(userId, 'firstSteps', 'gold');
                }
                
                // Improvement badges
                if (improvement >= 10 && improvement < 20 && (!badges.risingStar || badges.risingStar === 'none')) {
                    await window.awardBadge(userId, 'risingStar', 'bronze');
                } else if (improvement >= 20 && improvement < 30 && (!badges.risingStar || badges.risingStar === 'bronze')) {
                    await window.awardBadge(userId, 'risingStar', 'silver');
                } else if (improvement >= 30 && badges.risingStar !== 'gold') {
                    await window.awardBadge(userId, 'risingStar', 'gold');
                }
                
                if (improvement >= 15 && improvement < 20 && last5Scores.length >= 3 && (!badges.fastTrack || badges.fastTrack === 'none')) {
                    await window.awardBadge(userId, 'fastTrack', 'bronze');
                } else if (improvement >= 20 && improvement < 25 && last5Scores.length >= 5 && (!badges.fastTrack || badges.fastTrack === 'bronze')) {
                    await window.awardBadge(userId, 'fastTrack', 'silver');
                } else if (improvement >= 25 && last5Scores.length >= 7 && badges.fastTrack !== 'gold') {
                    await window.awardBadge(userId, 'fastTrack', 'gold');
                }
                
                // Check for breakthrough (new personal best)
                // Count how many times user achieved a new PB
                let pbCount = 0;
                if (scoreValues.length >= 2) {
                    let currentMax = scoreValues[scoreValues.length - 1];
                    for (let i = scoreValues.length - 2; i >= 0; i--) {
                        if (scoreValues[i] > currentMax) {
                            pbCount++;
                            currentMax = scoreValues[i];
                        }
                    }
                }
                
                if (pbCount >= 1 && pbCount < 3 && (!badges.breakthrough || badges.breakthrough === 'none')) {
                    await window.awardBadge(userId, 'breakthrough', 'bronze');
                } else if (pbCount >= 3 && pbCount < 5 && (!badges.breakthrough || badges.breakthrough === 'bronze')) {
                    await window.awardBadge(userId, 'breakthrough', 'silver');
                } else if (pbCount >= 5 && badges.breakthrough !== 'gold') {
                    await window.awardBadge(userId, 'breakthrough', 'gold');
                }
                
                // Player mastery badges
                for (const player of ['curry', 'lebron', 'jordan', 'durant', 'clark']) {
                    if (playerScores[player]) {
                        const playerSessions = playerScores[player].length;
                        const playerMax = Math.max(...playerScores[player].map(s => s.similarityScore));
                        const badgeName = player + 'Specialist';
                        
                        if (playerSessions >= 5 && playerMax >= 85 && playerMax < 90 && (!badges[badgeName] || badges[badgeName] === 'none')) {
                            await window.awardBadge(userId, badgeName, 'bronze');
                        } else if (playerSessions >= 10 && playerMax >= 90 && playerMax < 95 && (!badges[badgeName] || badges[badgeName] === 'bronze')) {
                            await window.awardBadge(userId, badgeName, 'silver');
                        } else if (playerSessions >= 15 && playerMax >= 95 && badges[badgeName] !== 'gold') {
                            await window.awardBadge(userId, badgeName, 'gold');
                        }
                    }
                }
                
                // Versatile Shooter
                if (playersWithHighScores.length >= 3 && playersWithHighScores.length < 4 && (!badges.versatileShooter || badges.versatileShooter === 'none')) {
                    await window.awardBadge(userId, 'versatileShooter', 'bronze');
                } else if (playersWithHighScores.length >= 4 && playersWithHighScores.length < 5 && (!badges.versatileShooter || badges.versatileShooter === 'bronze')) {
                    await window.awardBadge(userId, 'versatileShooter', 'silver');
                } else if (playersWithHighScores.length >= 5 && badges.versatileShooter !== 'gold') {
                    await window.awardBadge(userId, 'versatileShooter', 'gold');
                }
                
                // Consistency badges
                if (avgScore >= 80 && avgScore < 90 && totalSessions >= 10 && (!badges.steadyHand || badges.steadyHand === 'none')) {
                    await window.awardBadge(userId, 'steadyHand', 'bronze');
                } else if (avgScore >= 90 && avgScore < 95 && totalSessions >= 20 && (!badges.steadyHand || badges.steadyHand === 'bronze')) {
                    await window.awardBadge(userId, 'steadyHand', 'silver');
                } else if (avgScore >= 95 && totalSessions >= 30 && badges.steadyHand !== 'gold') {
                    await window.awardBadge(userId, 'steadyHand', 'gold');
                }
                
                const last10High = scoreValues.length >= 10 && scoreValues.slice(0, 10).every(s => s >= 85);
                const last15High = scoreValues.length >= 15 && scoreValues.slice(0, 15).every(s => s >= 85);
                
                if (allLast5High && !last10High && (!badges.rockSolid || badges.rockSolid === 'none')) {
                    await window.awardBadge(userId, 'rockSolid', 'bronze');
                } else if (last10High && !last15High && (!badges.rockSolid || badges.rockSolid === 'bronze')) {
                    await window.awardBadge(userId, 'rockSolid', 'silver');
                } else if (last15High && badges.rockSolid !== 'gold') {
                    await window.awardBadge(userId, 'rockSolid', 'gold');
                }
                
                // Perfect form badges
                if (maxScore >= 95 && maxScore < 98 && (!badges.nearPerfect || badges.nearPerfect === 'none')) {
                    await window.awardBadge(userId, 'nearPerfect', 'bronze');
                } else if (maxScore >= 98 && maxScore < 100 && (!badges.nearPerfect || badges.nearPerfect === 'bronze')) {
                    await window.awardBadge(userId, 'nearPerfect', 'silver');
                } else if (maxScore >= 100 && badges.nearPerfect !== 'gold') {
                    await window.awardBadge(userId, 'nearPerfect', 'gold');
                }
                
                const perfectScores = scoreValues.filter(s => s >= 100).length;
                
                if (maxScore >= 98 && maxScore < 100 && (!badges.perfectionist || badges.perfectionist === 'none')) {
                    await window.awardBadge(userId, 'perfectionist', 'bronze');
                } else if (maxScore >= 100 && perfectScores < 3 && badges.perfectionist !== 'silver') {
                    await window.awardBadge(userId, 'perfectionist', 'silver');
                } else if (perfectScores >= 3 && badges.perfectionist !== 'gold') {
                    await window.awardBadge(userId, 'perfectionist', 'gold');
                }
                
                // Dedication badges (consecutive days with sessions)
                if (maxConsecutive >= 7 && maxConsecutive < 30 && (!badges.weekWarrior || badges.weekWarrior === 'none')) {
                    await window.awardBadge(userId, 'weekWarrior', 'bronze');
                } else if (maxConsecutive >= 30 && maxConsecutive < 365 && (!badges.weekWarrior || badges.weekWarrior === 'bronze')) {
                    await window.awardBadge(userId, 'weekWarrior', 'silver');
                } else if (maxConsecutive >= 365 && badges.weekWarrior !== 'gold') {
                    await window.awardBadge(userId, 'weekWarrior', 'gold');
                }
                
                // Daily Grinder
                if (maxConsecutive >= 3 && maxConsecutive < 7 && (!badges.dailyGrinder || badges.dailyGrinder === 'none')) {
                    await window.awardBadge(userId, 'dailyGrinder', 'bronze');
                } else if (maxConsecutive >= 7 && maxConsecutive < 14 && (!badges.dailyGrinder || badges.dailyGrinder === 'bronze')) {
                    await window.awardBadge(userId, 'dailyGrinder', 'silver');
                } else if (maxConsecutive >= 14 && badges.dailyGrinder !== 'gold') {
                    await window.awardBadge(userId, 'dailyGrinder', 'gold');
                }
                
                // Exploration badges
                const hasCustom = playerScores['custom'] && playerScores['custom'].length > 0;
                const allPlayersMastered = playersWithHighScores.length >= 5;
                
                if (uniquePlayers.length >= 5 && !hasCustom && (!badges.explorer || badges.explorer === 'none')) {
                    await window.awardBadge(userId, 'explorer', 'bronze');
                } else if (uniquePlayers.length >= 5 && hasCustom && (!badges.explorer || badges.explorer === 'bronze')) {
                    await window.awardBadge(userId, 'explorer', 'silver');
                } else if (allPlayersMastered && badges.explorer !== 'gold') {
                    await window.awardBadge(userId, 'explorer', 'gold');
                }
                
                if (playerScores['custom'] && playerScores['custom'].length >= 1 && playerScores['custom'].length < 5 && (!badges.adventurer || badges.adventurer === 'none')) {
                    await window.awardBadge(userId, 'adventurer', 'bronze');
                } else if (playerScores['custom'] && playerScores['custom'].length >= 5 && playerScores['custom'].length < 10 && (!badges.adventurer || badges.adventurer === 'bronze')) {
                    await window.awardBadge(userId, 'adventurer', 'silver');
                } else if (playerScores['custom'] && playerScores['custom'].length >= 10 && badges.adventurer !== 'gold') {
                    await window.awardBadge(userId, 'adventurer', 'gold');
                }
                
                // Complete Collection - check for different score thresholds
                const playersAt90 = uniquePlayers.filter(p => {
                    const playerMax = Math.max(...playerScores[p].map(s => s.similarityScore));
                    return playerMax >= 90;
                }).length;
                const playersAt95 = uniquePlayers.filter(p => {
                    const playerMax = Math.max(...playerScores[p].map(s => s.similarityScore));
                    return playerMax >= 95;
                }).length;
                
                if (playersWithHighScores.length >= 5 && playersAt90 < 5 && (!badges.completeCollection || badges.completeCollection === 'none')) {
                    await window.awardBadge(userId, 'completeCollection', 'bronze');
                } else if (playersAt90 >= 5 && playersAt95 < 5 && (!badges.completeCollection || badges.completeCollection === 'bronze')) {
                    await window.awardBadge(userId, 'completeCollection', 'silver');
                } else if (playersAt95 >= 5 && badges.completeCollection !== 'gold') {
                    await window.awardBadge(userId, 'completeCollection', 'gold');
                }
                
                // Quick Learner
                if (totalSessions <= 5 && maxScore >= 80 && maxScore < 85 && (!badges.quickLearner || badges.quickLearner === 'none')) {
                    await window.awardBadge(userId, 'quickLearner', 'bronze');
                } else if (totalSessions <= 5 && maxScore >= 85 && maxScore < 90 && (!badges.quickLearner || badges.quickLearner === 'bronze')) {
                    await window.awardBadge(userId, 'quickLearner', 'silver');
                } else if (totalSessions <= 5 && maxScore >= 90 && badges.quickLearner !== 'gold') {
                    await window.awardBadge(userId, 'quickLearner', 'gold');
                }
                
                // Rapid Rise
                if (scoreValues.length >= 10) {
                    const first5Avg = scoreValues.slice(-10, -5).reduce((a, b) => a + b, 0) / 5;
                    const last5Avg = scoreValues.slice(0, 5).reduce((a, b) => a + b, 0) / 5;
                    if (first5Avg < 60 && last5Avg >= 85 && last5Avg < 90 && (!badges.rapidRise || badges.rapidRise === 'none')) {
                        await window.awardBadge(userId, 'rapidRise', 'bronze');
                    } else if (first5Avg < 60 && last5Avg >= 90 && last5Avg < 95 && (!badges.rapidRise || badges.rapidRise === 'bronze')) {
                        await window.awardBadge(userId, 'rapidRise', 'silver');
                    } else if (first5Avg < 60 && last5Avg >= 95 && badges.rapidRise !== 'gold') {
                        await window.awardBadge(userId, 'rapidRise', 'gold');
                    }
                }
                
            } catch (error) {
                console.error('Error checking badges:', error);
            }
        };
    </script>
</head>
<body>
    <!-- Navbar -->
    <nav class="navbar">
        <div class="nav-container">
            <div class="nav-content">
                <div class="logo">
                    <a href="../index.html" style="display: flex; align-items: center; text-decoration: none;">
                        <img src="/RootsLogo.png" alt="Roots Logo" style="height: 50px; width: auto; cursor: pointer; object-fit: contain;">
                    </a>
                </div>
                <div class="nav-tabs" style="display: flex; gap: 20px; align-items: center; justify-content: center; flex: 1;">
                    <button id="shotSyncTab" class="nav-tab active" onclick="showShotSync()">Shot Sync</button>
                    <a href="/shotlab" class="nav-tab" style="text-decoration: none;">Shot Lab</a>
                    <button id="trainingDbTab" class="nav-tab" onclick="showTrainingDatabase()" style="display: none;">Training Database</button>
                    <button id="progressPicsTab" class="nav-tab" onclick="showProgressPics()" style="display: none;">Progress Pics</button>
                    <button id="badgesTab" class="nav-tab" onclick="showBadges()" style="display: none;">Badges</button>
                    <button id="nutritionTab" class="nav-tab" onclick="showNutrition()" style="display: none;">Nutrition</button>
                    <button id="workoutsTab" class="nav-tab" onclick="showWorkouts()" style="display: none;">Workouts</button>
                </div>
                <div>
                    <button id="backToHomeTab" class="nav-tab">Home</button>
                </div>
            </div>
        </div>
    </nav>

    <div class="container">
        <!-- Profile Dropdown (positioned in nav area) -->
        <div id="profileDropdown" style="position: fixed; top: 20px; right: 20px; display: none; z-index: 100;">
            <button id="profileButton" class="btn" style="background: rgba(255,255,255,0.2); border: 1px solid rgba(255,255,255,0.3); padding: 8px 12px; border-radius: 20px; color: white; cursor: pointer; display: flex; align-items: center; gap: 8px; transition: all 0.2s;">
                <span id="profileInitials" style="width: 32px; height: 32px; border-radius: 50%; background: rgba(255,255,255,0.3); display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 14px;">U</span>
                <span id="profileName" style="max-width: 150px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; font-size: 14px;"></span>
                <span style="font-size: 10px;">â–¼</span>
            </button>
            <div id="profileMenu" style="position: absolute; top: 100%; right: 0; margin-top: 8px; background: white; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); min-width: 200px; display: none; z-index: 1001;">
                <div style="padding: 16px; border-bottom: 1px solid #e0e0e0;">
                    <div id="menuUserName" style="font-weight: bold; color: #333; margin-bottom: 4px;"></div>
                    <div id="menuUserEmail" style="font-size: 12px; color: #666;"></div>
                </div>
                <button id="logoutButton" style="width: 100%; padding: 12px 16px; text-align: left; background: none; border: none; cursor: pointer; color: #333; font-size: 14px; border-radius: 0 0 8px 8px; transition: background 0.2s;">
                    Sign Out
                </button>
            </div>
        </div>

        <div class="main-content">
            <!-- Step 0: User Information -->
            <section id="step0" class="step" style="display: none;">
                <h2>Welcome to <span style="background: linear-gradient(135deg, var(--primary-color) 0%, var(--primary-hover) 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; font-weight: 700;">Shot</span><span>Sync</span></h2>
                <p style="font-size: 18px; color: #666; margin-bottom: 30px; text-align: center;">
                    AI-powered basketball shot analysis to help you improve your shooting form
                </p>

                <!-- Google Sign-In Button (only show if not signed in) -->
                <div id="signInSection" style="text-align: center;">
                    <p style="font-size: 16px; color: #333; margin-bottom: 20px; font-weight: 500;">
                        Sign in with Google to get started
                    </p>
                    <button id="googleSignInBtn" onclick="handleGoogleSignInClick()" class="btn" style="background: white; color: #333; border: 1px solid #ddd; display: inline-flex; align-items: center; gap: 10px; padding: 14px 28px; font-size: 16px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                        <svg width="20" height="20" viewBox="0 0 18 18">
                            <path fill="#4285F4" d="M17.64 9.2c0-.637-.057-1.251-.164-1.84H9v3.481h4.844c-.209 1.125-.843 2.078-1.796 2.717v2.258h2.908c1.702-1.567 2.684-3.874 2.684-6.615z"/>
                            <path fill="#34A853" d="M9 18c2.43 0 4.467-.806 5.956-2.184l-2.908-2.258c-.806.54-1.837.86-3.048.86-2.344 0-4.328-1.584-5.036-3.711H.957v2.332C2.438 15.983 5.482 18 9 18z"/>
                            <path fill="#FBBC05" d="M3.964 10.712c-.18-.54-.282-1.117-.282-1.712 0-.595.102-1.172.282-1.712V4.956H.957C.348 6.175 0 7.55 0 9s.348 2.825.957 4.044l3.007-2.332z"/>
                            <path fill="#EA4335" d="M9 3.58c1.321 0 2.508.454 3.44 1.345l2.582-2.58C13.463.891 11.426 0 9 0 5.482 0 2.438 2.017.957 4.956L3.964 7.288C4.672 5.163 6.656 3.58 9 3.58z"/>
                        </svg>
                        Sign in with Google
                    </button>
                </div>
            </section>

            <!-- Step 1: Record Benchmark -->
            <section id="step1" class="step" style="display: none;">
                <h2 id="step1Title">Step 1: Record Benchmark Shot</h2>
                <p>Record a reference shot to use as your benchmark for comparison.</p>
                <div class="video-container" style="position: relative;">
                    <video id="benchmarkVideo" autoplay playsinline muted style="width: 100%; max-width: 640px; height: auto; display: block; border-radius: 12px; z-index: 1;"></video>
                    <canvas id="benchmarkCanvas" style="display: none;"></canvas>
                    <canvas id="benchmarkOutput" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; max-width: 640px; z-index: 2; pointer-events: none;"></canvas>
                    <div id="benchmarkBodyWarning" class="body-warning-overlay" style="display: none;">
                        <div class="warning-content">
                            <div class="warning-icon">âš ï¸</div>
                            <h3>Full Body Required</h3>
                            <p>Please step back so your entire body is visible in the frame</p>
                        </div>
                    </div>
                </div>
                <div class="controls" style="display: flex; flex-direction: column; gap: 15px; align-items: center;">
                    <!-- All buttons in one horizontal line -->
                    <div style="display: flex; gap: 10px; justify-content: center; flex-wrap: wrap; align-items: center;">
                        <!-- Upload Video Toggle -->
                        <button id="benchmarkUploadModeBtn" class="btn btn-secondary mode-toggle-btn" style="min-width: 140px;">ðŸ“¤ Upload Video</button>
                        
                        <!-- Recording Controls -->
                        <button id="startBenchmark" class="btn btn-primary" style="min-width: 140px;">Start Recording</button>
                        <button id="stopBenchmark" class="btn btn-secondary" disabled style="min-width: 140px;">Stop Recording</button>
                        <button id="retakeBenchmark" class="btn btn-warning" style="display: none; min-width: 140px;">Retake</button>
                        
                        <!-- Upload Controls (hidden by default) -->
                        <input type="file" id="benchmarkVideoUpload" accept="video/mp4,video/mov,video/webm,video/quicktime" style="position: absolute; width: 1px; height: 1px; opacity: 0; overflow: hidden; z-index: -1;">
                        <label for="benchmarkVideoUpload" id="selectBenchmarkVideo" class="btn btn-primary" style="display: none; min-width: 140px; cursor: pointer;">Choose Video File</label>
                        <button id="processBenchmarkVideo" class="btn btn-success" style="display: none; min-width: 140px;">Analyze Video</button>
                    </div>
                    
                    <!-- File name display for upload -->
                    <div id="benchmarkUploadedFileName" style="width: 100%; text-align: center; color: #666; font-size: 14px;"></div>
                </div>
                <div id="benchmarkStatus" class="status" style="display: none;"></div>
            </section>

            <!-- Step 2: Record User Shot -->
            <section id="step2" class="step active" style="padding-top: 20px;">
                <h2 id="step2Title" style="font-family: 'Bebas Neue', sans-serif; text-align: center; letter-spacing: 2px; margin-top: 0;">Record Your Shot</h2>
                <p style="text-align: center;">And our AI will do the rest, select what type of analysis next!</p>
                <div class="video-container" style="position: relative;">
                    <video id="userVideo" playsinline muted style="width: 100%; max-width: 640px; height: auto; display: block; border-radius: 12px; z-index: 1;"></video>
                    <canvas id="userCanvas" style="display: none;"></canvas>
                    <canvas id="userOutput" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; max-width: 640px; z-index: 2; pointer-events: none;"></canvas>
                    <div id="userBodyWarning" class="body-warning-overlay" style="display: none;">
                        <div class="warning-content">
                            <div class="warning-icon">âš ï¸</div>
                            <h3>Full Body Required</h3>
                            <p>Please step back so your entire body is visible in the frame</p>
                        </div>
                    </div>
                    <!-- Video Ready Overlay (blue - waiting for analysis selection) -->
                    <div id="videoReadyOverlay" class="video-ready-overlay" style="display: none;">
                        <div class="ready-content">
                            <div class="ready-icon">âœ“</div>
                            <h3>Video Ready</h3>
                            <p>Select analysis type below</p>
                        </div>
                    </div>
                    <!-- Running Analysis Overlay (green - actually processing) -->
                    <div id="analysisRunningOverlay" class="analysis-overlay" style="display: none;">
                        <div class="analysis-content">
                            <div class="analysis-spinner"></div>
                            <h3>Running Analysis</h3>
                            <p>Processing your video...</p>
                        </div>
                    </div>
                </div>
                <div class="controls" style="display: flex; flex-direction: column; gap: 15px; align-items: center; width: 100%;">
                    <!-- All buttons in one horizontal line -->
                    <div id="recordingControls" style="display: flex; gap: 12px; justify-content: center; flex-wrap: wrap; align-items: center;">
                        <!-- Upload Video - directly triggers file picker -->
                        <label for="userVideoUpload" class="btn btn-secondary" style="min-width: 180px; height: 48px; border-radius: 8px; font-size: 14px; font-weight: 600; display: inline-flex; align-items: center; justify-content: center; cursor: pointer;">UPLOAD VIDEO</label>
                        <input type="file" id="userVideoUpload" accept="video/mp4,video/mov,video/webm,video/quicktime" style="display: none;">

                        <!-- Recording Controls -->
                        <button id="startUser" class="btn btn-primary" style="min-width: 180px; height: 48px; border-radius: 8px; font-size: 14px; font-weight: 600; clip-path: none;">START RECORDING</button>
                        <button id="stopUser" class="btn btn-secondary" disabled style="min-width: 180px; height: 48px; border-radius: 8px; font-size: 14px; font-weight: 600;">STOP RECORDING</button>
                        <button id="retakeUser" class="btn btn-warning" style="display: none; min-width: 180px; height: 48px; border-radius: 8px; font-size: 14px; font-weight: 600;">RETAKE</button>

                        <!-- Hidden buttons (kept for JS compatibility) -->
                        <button id="userUploadModeBtn" style="display: none;"></button>
                        <button id="selectUserVideo" style="display: none;"></button>
                        <button id="processUserVideo" style="display: none;"></button>
                    </div>
                    
                    <!-- File name display for upload -->
                    <div id="uploadedFileName" style="width: 100%; text-align: center; color: #666; font-size: 14px;"></div>
                </div>

                <!-- Analysis Type Selection (shown after video is ready) -->
                <div id="analysisTypeSelection" style="display: none; margin-top: 30px; padding-top: 20px; border-top: 1px solid var(--border-color);">
                    <p style="text-align: center; margin-bottom: 15px; color: var(--text-gray); font-family: 'Work Sans', sans-serif;">
                        Choose your analysis type:
                    </p>
                    <div style="display: flex; gap: 15px; justify-content: center; flex-wrap: wrap; align-items: stretch;">
                        <button id="idealFormBtn" class="analysis-type-btn" data-type="ideal">
                            <span class="analysis-icon">ðŸŽ¯</span>
                            <span class="analysis-title">Ideal Form</span>
                            <span class="analysis-desc">Get feedback on your shooting mechanics</span>
                        </button>
                        <button id="playerSimilarityBtn" class="analysis-type-btn" data-type="similarity">
                            <span class="analysis-icon">ðŸ‘¥</span>
                            <span class="analysis-title">Player Match</span>
                            <span class="analysis-desc">See which pros shoot like you</span>
                        </button>
                        <button id="backToRecordBtn" class="analysis-type-btn" style="background: transparent; border-style: dashed;">
                            <span class="analysis-icon">â†</span>
                            <span class="analysis-title">Back</span>
                            <span class="analysis-desc">Choose a different video</span>
                        </button>
                    </div>
                </div>

                <!-- Status removed - no longer needed -->
            </section>

            <!-- Step 3: Analysis Results -->
            <section id="step3" class="step" style="display: none;">
                <div id="loading" class="loading" style="display: none;">
                    <p>Analyzing your shot...</p>
                    <div class="spinner"></div>
                </div>

                <!-- Player Match Results UI -->
                <div id="playerMatchResults" class="player-match-results">
                    <h1 style="font-family: 'Bebas Neue', sans-serif; font-size: 48px; letter-spacing: 2px; margin-bottom: 10px;">
                        PLAYER <span style="color: var(--primary-color);">MATCH</span>
                    </h1>
                    <p style="color: var(--text-gray); margin-bottom: 40px;">Your top 5 most similar pro players</p>

                    <div class="pm-grid">
                        <!-- Left Column: Player List -->
                        <div class="pm-left">
                            <div class="pm-list">
                                <div class="pm-row pm-row-selected" data-player="curry">
                                    <div class="pm-rank pm-rank-1">1</div>
                                    <div class="pm-info">
                                        <div class="pm-name">Stephen Curry</div>
                                        <div class="pm-archetype">Quick Release</div>
                                    </div>
                                    <div class="pm-similarity">
                                        <div class="pm-score">94%</div>
                                        <div class="pm-bar"><div class="pm-fill" style="width: 94%"></div></div>
                                    </div>
                                    <div class="pm-stats">
                                        <span>6'2"</span>
                                        <span>6'4" WS</span>
                                        <span>Right</span>
                                    </div>
                                </div>
                                <div class="pm-row" data-player="trae">
                                    <div class="pm-rank">2</div>
                                    <div class="pm-info">
                                        <div class="pm-name">Trae Young</div>
                                        <div class="pm-archetype">High Arc</div>
                                    </div>
                                    <div class="pm-similarity">
                                        <div class="pm-score">87%</div>
                                        <div class="pm-bar"><div class="pm-fill" style="width: 87%"></div></div>
                                    </div>
                                    <div class="pm-stats">
                                        <span>6'1"</span>
                                        <span>6'3" WS</span>
                                        <span>Right</span>
                                    </div>
                                </div>
                                <div class="pm-row" data-player="dame">
                                    <div class="pm-rank">3</div>
                                    <div class="pm-info">
                                        <div class="pm-name">Damian Lillard</div>
                                        <div class="pm-archetype">Deep Range</div>
                                    </div>
                                    <div class="pm-similarity">
                                        <div class="pm-score">82%</div>
                                        <div class="pm-bar"><div class="pm-fill" style="width: 82%"></div></div>
                                    </div>
                                    <div class="pm-stats">
                                        <span>6'2"</span>
                                        <span>6'8" WS</span>
                                        <span>Right</span>
                                    </div>
                                </div>
                                <div class="pm-row" data-player="kyrie">
                                    <div class="pm-rank">4</div>
                                    <div class="pm-info">
                                        <div class="pm-name">Kyrie Irving</div>
                                        <div class="pm-archetype">Textbook Form</div>
                                    </div>
                                    <div class="pm-similarity">
                                        <div class="pm-score">78%</div>
                                        <div class="pm-bar"><div class="pm-fill" style="width: 78%"></div></div>
                                    </div>
                                    <div class="pm-stats">
                                        <span>6'2"</span>
                                        <span>6'8" WS</span>
                                        <span>Right</span>
                                    </div>
                                </div>
                                <div class="pm-row" data-player="klay">
                                    <div class="pm-rank">5</div>
                                    <div class="pm-info">
                                        <div class="pm-name">Klay Thompson</div>
                                        <div class="pm-archetype">Set Shot</div>
                                    </div>
                                    <div class="pm-similarity">
                                        <div class="pm-score">74%</div>
                                        <div class="pm-bar"><div class="pm-fill" style="width: 74%"></div></div>
                                    </div>
                                    <div class="pm-stats">
                                        <span>6'6"</span>
                                        <span>6'9" WS</span>
                                        <span>Right</span>
                                    </div>
                                </div>
                            </div>

                            <!-- Quick Fixes -->
                            <div class="pm-fixes-header"><span>ðŸ”§</span> Quick Fixes</div>
                            <div class="pm-fix-item">
                                <button class="pm-fix-toggle">
                                    <div class="pm-fix-icon">ðŸ“</div>
                                    <div class="pm-fix-content">
                                        <div class="pm-fix-title">Increase your arc</div>
                                        <div class="pm-fix-tip">Aim higher on your release to get more arc on your shot</div>
                                    </div>
                                    <span class="pm-fix-arrow">â–¼</span>
                                </button>
                                <div class="pm-drill-content">
                                    <div class="pm-drill-card">
                                        <div class="pm-drill-label">Recommended Drill</div>
                                        <div class="pm-drill-name">Rainbow Flick Drill</div>
                                        <div class="pm-drill-desc">Practice shooting with exaggerated arc. Start close to the basket and focus on getting the ball to peak above the top of the backboard.</div>
                                        <div class="pm-drill-meta"><span>â±ï¸ 10 mins</span><span>ðŸ€ 25 reps</span></div>
                                    </div>
                                </div>
                            </div>
                            <div class="pm-fix-item">
                                <button class="pm-fix-toggle">
                                    <div class="pm-fix-icon">ðŸ¦µ</div>
                                    <div class="pm-fix-content">
                                        <div class="pm-fix-title">Use more leg power</div>
                                        <div class="pm-fix-tip">Generate more force from your legs to power your shot</div>
                                    </div>
                                    <span class="pm-fix-arrow">â–¼</span>
                                </button>
                                <div class="pm-drill-content">
                                    <div class="pm-drill-card">
                                        <div class="pm-drill-label">Recommended Drill</div>
                                        <div class="pm-drill-name">Squat & Shoot</div>
                                        <div class="pm-drill-desc">Start in a low squat position before each shot. Explode up through your legs and transfer that energy into your shot.</div>
                                        <div class="pm-drill-meta"><span>â±ï¸ 15 mins</span><span>ðŸ€ 20 reps</span></div>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Right Column -->
                        <div class="pm-right">
                            <div class="pm-archetype-card">
                                <div class="pm-arch-label">Your Shot Archetype</div>
                                <div class="pm-arch-name">QUICK RELEASE</div>
                                <div class="pm-arch-desc">You have a fast, compact shooting motion with minimal wind-up. Your release point is optimized for getting shots off quickly against defenders.</div>
                            </div>

                            <div class="pm-traits">
                                <div class="pm-section-header">
                                    <span class="pm-section-title">Shared traits with</span>
                                    <span class="pm-player-name">Stephen Curry</span>
                                </div>
                                <div class="pm-trait-item">
                                    <div class="pm-trait-icon">âš¡</div>
                                    <div class="pm-trait-text">
                                        <div class="pm-trait-name">Release Speed</div>
                                        <div class="pm-trait-detail">Sub 0.4 second release time</div>
                                    </div>
                                    <div class="pm-trait-match">98%</div>
                                </div>
                                <div class="pm-trait-item">
                                    <div class="pm-trait-icon">ðŸŽ¯</div>
                                    <div class="pm-trait-text">
                                        <div class="pm-trait-name">Set Point Height</div>
                                        <div class="pm-trait-detail">High release above forehead</div>
                                    </div>
                                    <div class="pm-trait-match">94%</div>
                                </div>
                                <div class="pm-trait-item">
                                    <div class="pm-trait-icon">ðŸ”„</div>
                                    <div class="pm-trait-text">
                                        <div class="pm-trait-name">Follow Through</div>
                                        <div class="pm-trait-detail">Full extension with wrist snap</div>
                                    </div>
                                    <div class="pm-trait-match">91%</div>
                                </div>
                            </div>

                            <div class="pm-differences">
                                <div class="pm-section-header">
                                    <span class="pm-section-title">Key differences from</span>
                                    <span class="pm-player-name">Stephen Curry</span>
                                </div>
                                <div class="pm-diff-item">
                                    <div class="pm-diff-icon">ðŸ“</div>
                                    <div class="pm-diff-text">
                                        <div class="pm-diff-name">Arc Height</div>
                                        <div class="pm-diff-detail">Your arc is flatter than Curry's</div>
                                    </div>
                                    <div class="pm-diff-gap">-12%</div>
                                </div>
                                <div class="pm-diff-item">
                                    <div class="pm-diff-icon">ðŸ¦µ</div>
                                    <div class="pm-diff-text">
                                        <div class="pm-diff-name">Leg Drive</div>
                                        <div class="pm-diff-detail">Less power from lower body</div>
                                    </div>
                                    <div class="pm-diff-gap">-8%</div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="controls" style="display: flex; gap: 15px; justify-content: center; flex-wrap: wrap; margin-top: 30px;">
                        <button id="pmTryOther" class="btn btn-secondary">Try Other Analysis</button>
                        <button id="pmNewComparison" class="btn btn-primary">New Comparison</button>
                    </div>
                </div>

                <!-- Ideal Form Results (original) -->
                <div id="idealFormResults">
                    <h2 style="font-family: 'Forum', serif; text-align: center;">Analysis Results</h2>
                    <div id="results" style="display: none;">
                    <div class="score-section">
                        <h3 id="overallScore">Overall Score: --</h3>
                    </div>
                    <div class="chart-container">
                        <canvas id="comparisonChart"></canvas>
                    </div>
                    <!-- Coordinate Table (Hidden) -->
                    <div id="coordinateTableContainer" style="display: none; margin-top: 30px; overflow-x: auto; max-height: 400px; overflow-y: auto;">
                        <table id="coordinateTable" style="width: 100%; border-collapse: collapse; font-size: 12px; background: white; border-radius: 8px; overflow: hidden;">
                            <thead>
                                <tr style="background: #f3f4f6; position: sticky; top: 0; z-index: 10;">
                                    <th style="padding: 10px; text-align: left; border: 1px solid #e5e7eb; font-weight: 600;">Time (s)</th>
                                    <th style="padding: 10px; text-align: center; border: 1px solid #e5e7eb; font-weight: 600;">Benchmark<br>Wrist (x,y,z)</th>
                                    <th style="padding: 10px; text-align: center; border: 1px solid #e5e7eb; font-weight: 600;">Benchmark<br>Elbow (x,y,z)</th>
                                    <th style="padding: 10px; text-align: center; border: 1px solid #e5e7eb; font-weight: 600;">Benchmark<br>Shoulder (x,y,z)</th>
                                    <th style="padding: 10px; text-align: center; border: 1px solid #e5e7eb; font-weight: 600;">Your Shot<br>Wrist (x,y,z)</th>
                                    <th style="padding: 10px; text-align: center; border: 1px solid #e5e7eb; font-weight: 600;">Your Shot<br>Elbow (x,y,z)</th>
                                    <th style="padding: 10px; text-align: center; border: 1px solid #e5e7eb; font-weight: 600;">Your Shot<br>Shoulder (x,y,z)</th>
                                </tr>
                            </thead>
                            <tbody id="coordinateTableBody">
                                <!-- Table rows will be populated by JavaScript -->
                            </tbody>
                        </table>
                    </div>
                    <!-- Detailed Feedback Section -->
                    <div id="detailedFeedback" class="detailed-feedback-section" style="display: none;">
                        <h3 id="playerComparisonTitle">Shot Analysis</h3>
                        
                        <!-- Player Summary -->
                        <div id="playerSummarySection" class="player-summary-section" style="display: none; background: #f8f9fa; padding: 20px; border-radius: 12px; margin-bottom: 25px; border-left: 4px solid var(--primary-color);">
                            <h4 style="margin-top: 0; color: #333; font-family: 'Bebas Neue', sans-serif;">What Makes This Player's Shot Unique</h4>
                            <div id="playerSummaryText" style="color: #555; line-height: 1.8; white-space: pre-line; font-size: 15px;"></div>
                        </div>
                        
                        <!-- Summary -->
                        <div class="summary-section">
                            <h4>Summary</h4>
                            <p id="shotSummary" class="summary-text"></p>
                        </div>
                        
                        <!-- Strengths -->
                        <div class="strengths-section">
                            <h4>Strengths</h4>
                            <div id="strengthsList" class="feedback-list"></div>
                        </div>

                        <!-- Weaknesses -->
                        <div class="weaknesses-section">
                            <h4>Areas for Improvement</h4>
                            <div id="weaknessesList" class="feedback-list"></div>
                        </div>

                        <!-- Metrics -->
                        <div class="metrics-section">
                            <h4>Detailed Metrics</h4>
                            <div id="metricsList" class="metrics-grid"></div>
                        </div>
                    </div>
                    
                    <!-- Landmark Coordinates Table -->
                    <div id="landmarkTableSection" class="landmark-table-section" style="display: none;">
                        <h4>ðŸ” Interpolated Landmark Coordinates</h4>
                        <p style="font-size: 0.9em; color: #666; margin-bottom: 15px;">
                            All 33 MediaPipe landmarks with their x, y, z coordinates after linear interpolation.
                            Missing landmarks are filled in using linear interpolation between last seen and first reseen positions.
                        </p>
                        <div id="landmarkTableContainer" style="overflow-x: auto; max-height: 500px; overflow-y: auto;">
                            <table id="landmarkTable" class="landmark-table">
                                <thead>
                                    <tr>
                                        <th>Landmark</th>
                                        <th>Name</th>
                                        <th>Weight</th>
                                        <th>Avg X</th>
                                        <th>Avg Y</th>
                                        <th>Avg Z</th>
                                        <th>Frames</th>
                                    </tr>
                                </thead>
                                <tbody id="landmarkTableBody">
                                </tbody>
                            </table>
                        </div>
                    </div>
                    
                    <!-- Old Feedback Section (hidden by default) -->
                    <div class="feedback-section" style="display: none;">
                        <h3>Feedback & Recommendations</h3>
                        <div id="feedbackList"></div>
                    </div>
                    
                    <div class="controls" style="display: flex; gap: 15px; justify-content: center; flex-wrap: wrap; margin-top: 30px;">
                        <button id="tryOtherAnalysis" class="btn btn-secondary">Try Other Analysis</button>
                        <button id="newComparison" class="btn btn-primary">New Comparison</button>
                    </div>
                    </div>
                </div>
            </section>

            <!-- Shot Tracker Section - Uses ONLY AI-Basketball-Shot-Detection-Tracker -->
            <section id="shotTrackerSection" class="step" style="display: none;">
                <h2 style="text-align: center; font-family: 'Forum', serif; margin-bottom: 12px;">
                    <span style="background: linear-gradient(135deg, var(--primary-color) 0%, var(--primary-hover) 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; font-weight: 700;">Shooting Percentage</span> Tracker
                </h2>
                <p style="text-align: center; color: #666; margin-bottom: 30px; font-size: 16px;">
                    Track your makes and misses in real-time. Uses <strong>AI-Basketball-Shot-Detection-Tracker</strong> exclusively.
                </p>

                <!-- Upload Form - EXACT COPY from original -->
                <div style="max-width: 800px; margin: 0 auto 30px; background: white; padding: 25px; border-radius: 15px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                    <form id="shotTrackerUploadForm" enctype="multipart/form-data" style="display: flex; flex-direction: column; align-items: center; gap: 15px;">
                        <input type="file" id="shotTrackerFileInput" name="video" accept="video/*" required style="display: none;">
                        <label for="shotTrackerFileInput" class="btn btn-primary" style="cursor: pointer; display: inline-block; padding: 12px 30px; font-size: 16px; border-radius: 10px;">
                            ðŸ“ Choose Video File
                        </label>
                        <div id="uploadedFileName" style="margin-top: 10px; font-size: 14px; color: #666;"></div>
                        <button type="submit" id="uploadBtn" class="btn btn-success" style="padding: 12px 40px; font-size: 16px; border-radius: 10px;">Upload & Analyze Video</button>
                        <div id="uploadMessage" style="margin-top: 15px; padding: 10px; border-radius: 8px; display: none; width: 100%; text-align: center;"></div>
                    </form>
                </div>

                <!-- Video Stream - Clean video without overlays (overlays are drawn by ShotDetectorWeb but we'll show stats separately) -->
                <div class="video-container" style="text-align: center; margin-bottom: 30px; max-width: 800px; margin-left: auto; margin-right: auto; position: relative;">
                    <img id="shotTrackerVideoStream" src="/api/video_feed" alt="Video Stream" style="max-width: 100%; border-radius: 15px; background: #000;">
                    <!-- Algorithm Indicator -->
                    <div id="algorithmIndicator" style="position: absolute; top: 10px; left: 10px; background: rgba(0,0,0,0.85); color: white; padding: 12px 16px; border-radius: 8px; font-size: 11px; display: block; z-index: 3; border: 2px solid rgba(255,255,255,0.3); box-shadow: 0 2px 8px rgba(0,0,0,0.5);">
                        <div style="font-weight: 700; margin-bottom: 6px; font-size: 13px; color: #4ade80;">ðŸ€ Model: AI-Basketball-Shot-Detection-Tracker</div>
                        <div style="font-weight: 600; margin-bottom: 4px; font-size: 11px; color: #94a3b8;">YOLOv8 (best.pt)</div>
                    </div>
                    </div>

                <!-- Stats Bar - Above Heatmap -->
                <div style="max-width: 800px; margin: 30px auto; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); padding: 20px; border-radius: 15px; box-shadow: 0 4px 12px rgba(0,0,0,0.15);">
                    <div style="display: flex; justify-content: space-around; align-items: center; flex-wrap: wrap; gap: 20px; color: white;">
                        <div style="text-align: center;">
                            <div style="font-size: 14px; opacity: 0.9; margin-bottom: 5px; text-transform: uppercase; letter-spacing: 1px;">Makes</div>
                            <div style="font-size: 48px; font-weight: 700; font-family: 'Bebas Neue', sans-serif;" id="makesCount">0</div>
                    </div>
                        <div style="text-align: center;">
                            <div style="font-size: 14px; opacity: 0.9; margin-bottom: 5px; text-transform: uppercase; letter-spacing: 1px;">Attempts</div>
                            <div style="font-size: 48px; font-weight: 700; font-family: 'Bebas Neue', sans-serif;" id="attemptsCount">0</div>
                </div>
                        <div style="text-align: center;">
                            <div style="font-size: 14px; opacity: 0.9; margin-bottom: 5px; text-transform: uppercase; letter-spacing: 1px;">Percentage</div>
                            <div style="font-size: 48px; font-weight: 700; font-family: 'Bebas Neue', sans-serif;" id="percentage">0%</div>
                    </div>
                        <div style="text-align: center;">
                            <div style="font-size: 14px; opacity: 0.9; margin-bottom: 5px; text-transform: uppercase; letter-spacing: 1px;">Last Shot</div>
                            <div id="lastShotResult" style="font-size: 32px; font-weight: 700; font-family: 'Bebas Neue', sans-serif;">-</div>
                        </div>
                    </div>
                </div>

                <!-- Heatmap - EXACT COPY from original -->
                <div style="max-width: 800px; margin: 30px auto; background: white; padding: 20px; border-radius: 15px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                    <div style="font-size: 24px; font-weight: bold; margin-bottom: 15px; text-align: center;">Shot Heatmap</div>
                    <canvas id="shotTrackerHeatmap" width="800" height="600" style="background: rgba(0, 0, 0, 0.3); border-radius: 10px; max-width: 100%; height: auto; display: block; margin: 0 auto;"></canvas>
                    <div style="margin-top: 15px; font-size: 14px; text-align: center;">
                        <span style="color: #00ff00;">â— Makes</span> | 
                        <span style="color: #ff0000;">âœ• Misses</span>
                    </div>
                </div>
                
                <!-- Shot Tracker Stats Bar -->
                <div id="shotTrackerStatsBar" style="max-width: 800px; margin: 20px auto; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); padding: 20px; border-radius: 15px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); display: none;">
                    <div style="display: flex; justify-content: space-around; align-items: center; flex-wrap: wrap; gap: 20px; color: white;">
                        <div style="text-align: center;">
                            <div style="font-size: 14px; opacity: 0.9; margin-bottom: 5px; text-transform: uppercase; letter-spacing: 1px;">Total Makes</div>
                            <div style="font-size: 36px; font-weight: 700; font-family: 'Bebas Neue', sans-serif;" id="trackerTotalMakes">0</div>
                        </div>
                        <div style="text-align: center;">
                            <div style="font-size: 14px; opacity: 0.9; margin-bottom: 5px; text-transform: uppercase; letter-spacing: 1px;">Total Attempts</div>
                            <div style="font-size: 36px; font-weight: 700; font-family: 'Bebas Neue', sans-serif;" id="trackerTotalAttempts">0</div>
                        </div>
                        <div style="text-align: center;">
                            <div style="font-size: 14px; opacity: 0.9; margin-bottom: 5px; text-transform: uppercase; letter-spacing: 1px;">Shot Percentage</div>
                            <div style="font-size: 36px; font-weight: 700; font-family: 'Bebas Neue', sans-serif;" id="trackerShotPercentage">0%</div>
                        </div>
                    </div>
                </div>

                <!-- Save to Training Database Button -->
                <div style="text-align: center; margin-top: 30px; max-width: 800px; margin-left: auto; margin-right: auto;">
                    <button id="saveToTrainingDbBtn" class="btn btn-primary" onclick="if(typeof window.saveShotTrackerToTrainingDbLocal === 'function') { window.saveShotTrackerToTrainingDbLocal(); } else if(typeof saveShotTrackerToTrainingDb === 'function') { saveShotTrackerToTrainingDb(); } else { console.error('saveShotTrackerToTrainingDb function not found'); alert('Error: Save function not loaded. Please check console.'); }" style="min-width: 200px; padding: 12px 24px; font-size: 16px; font-weight: 600; background: linear-gradient(135deg, var(--primary-color) 0%, var(--primary-hover) 100%); border: none; box-shadow: 0 4px 12px rgba(0,0,0,0.15); cursor: pointer;">
                        ðŸ’¾ Save to Training Database
                    </button>
                    <div id="saveTrainingDbMessage" style="margin-top: 15px; padding: 10px; border-radius: 8px; display: none; width: 100%; text-align: center; font-size: 14px;"></div>
                        </div>

                <!-- Back Button -->
                <div style="text-align: center; margin-top: 20px;">
                        <button id="backToShotSyncFromTracker" class="btn btn-secondary" style="min-width: 160px; padding: 12px 24px; font-size: 16px;">â† Back to Shot Sync</button>
                </div>
            </section>
        </div>
    </div>

    <!-- Training Database View -->
    <div id="trainingDatabaseView" class="tab-view" style="display: none;">
        <div class="container" style="max-width: 1200px; margin: 40px auto; padding: 20px;">
            <h2 style="font-family: 'Bebas Neue', sans-serif; margin-bottom: 30px;">Training Database</h2>

            <!-- Shooting Percentage Tracker Button -->
            <div style="text-align: center; margin-bottom: 30px;">
                <button id="shotTrackerBtn" class="btn btn-primary" style="background: linear-gradient(135deg, var(--primary-color) 0%, var(--primary-hover) 100%); color: white; border: none; padding: 12px 28px; font-size: 16px; font-weight: 600; border-radius: 8px; cursor: pointer; box-shadow: 0 4px 12px rgba(255, 107, 122, 0.3); transition: all 0.3s ease;" onclick="showShotTracker()">
                    ðŸ€ Shooting Percentage Tracker
                </button>
            </div>

            <div style="margin-bottom: 20px;">
                <label for="playerFilter" style="display: block; margin-bottom: 10px; font-weight: 600;">Filter by Player:</label>
                <select id="playerFilter" style="padding: 10px 15px; border: 2px solid #ddd; border-radius: 8px; font-size: 16px; font-family: 'Bebas Neue', sans-serif; min-width: 200px;">
                    <option value="">All Players</option>
                    <option value="curry">Stephen Curry</option>
                    <option value="lebron">LeBron James</option>
                    <option value="jordan">Michael Jordan</option>
                    <option value="durant">Kevin Durant</option>
                    <option value="clark">Caitlin Clark</option>
                    <option value="custom">Custom</option>
                </select>
            </div>
            <div style="background: white; padding: 30px; border-radius: 12px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                <canvas id="trainingChart" style="max-height: 400px;"></canvas>
            </div>
            
            <!-- Form Similarity Stats Bar -->
            <div id="formSimilarityStats" style="max-width: 1200px; margin: 20px auto; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); padding: 20px; border-radius: 15px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); display: none;">
                <div style="display: flex; justify-content: space-around; align-items: center; flex-wrap: wrap; gap: 20px; color: white;">
                    <div style="text-align: center;">
                        <div style="font-size: 14px; opacity: 0.9; margin-bottom: 5px; text-transform: uppercase; letter-spacing: 1px;">Total Sessions</div>
                        <div style="font-size: 36px; font-weight: 700; font-family: 'Bebas Neue', sans-serif;" id="formTotalSessions">0</div>
                    </div>
                    <div style="text-align: center;">
                        <div style="font-size: 14px; opacity: 0.9; margin-bottom: 5px; text-transform: uppercase; letter-spacing: 1px;">Average Score</div>
                        <div style="font-size: 36px; font-weight: 700; font-family: 'Bebas Neue', sans-serif;" id="formAvgScore">0%</div>
                    </div>
                    <div style="text-align: center;">
                        <div style="font-size: 14px; opacity: 0.9; margin-bottom: 5px; text-transform: uppercase; letter-spacing: 1px;">Best Score</div>
                        <div style="font-size: 36px; font-weight: 700; font-family: 'Bebas Neue', sans-serif;" id="formBestScore">0%</div>
                    </div>
                    <div style="text-align: center;">
                        <div style="font-size: 14px; opacity: 0.9; margin-bottom: 5px; text-transform: uppercase; letter-spacing: 1px;">Recent Average</div>
                        <div style="font-size: 36px; font-weight: 700; font-family: 'Bebas Neue', sans-serif;" id="formRecentAvg">0%</div>
                    </div>
                </div>
            </div>
            <div style="background: white; padding: 30px; border-radius: 12px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); margin-top: 30px;">
                <h3 style="font-family: 'Bebas Neue', sans-serif; margin-bottom: 20px; color: #333;">Shot Location Heatmap</h3>
                <p style="color: #666; margin-bottom: 20px; font-size: 14px;">Visualize your shot locations over time. Filter by time period to see your shooting patterns.</p>
                
                <!-- Shot Tracker Stats Bar for Training Database -->
                <div id="trainingDbShotTrackerStats" style="max-width: 100%; margin: 20px auto; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); padding: 20px; border-radius: 15px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); display: none;">
                    <div style="display: flex; justify-content: space-around; align-items: center; flex-wrap: wrap; gap: 20px; color: white;">
                        <div style="text-align: center;">
                            <div style="font-size: 14px; opacity: 0.9; margin-bottom: 5px; text-transform: uppercase; letter-spacing: 1px;">Total Makes</div>
                            <div style="font-size: 36px; font-weight: 700; font-family: 'Bebas Neue', sans-serif;" id="trainingDbTotalMakes">0</div>
                        </div>
                        <div style="text-align: center;">
                            <div style="font-size: 14px; opacity: 0.9; margin-bottom: 5px; text-transform: uppercase; letter-spacing: 1px;">Total Attempts</div>
                            <div style="font-size: 36px; font-weight: 700; font-family: 'Bebas Neue', sans-serif;" id="trainingDbTotalAttempts">0</div>
                        </div>
                        <div style="text-align: center;">
                            <div style="font-size: 14px; opacity: 0.9; margin-bottom: 5px; text-transform: uppercase; letter-spacing: 1px;">Shot Percentage</div>
                            <div style="font-size: 36px; font-weight: 700; font-family: 'Bebas Neue', sans-serif;" id="trainingDbShotPercentage">0%</div>
                        </div>
                    </div>
                </div>
                
                <!-- Time Interval Toggles -->
                <div style="margin-bottom: 20px; display: flex; gap: 10px; flex-wrap: wrap; justify-content: center;">
                    <button class="heatmap-interval-btn active" data-interval="session" onclick="setHeatmapInterval('session')" style="padding: 8px 16px; border: 2px solid var(--primary-color); background: var(--primary-color); color: white; border-radius: 8px; cursor: pointer; font-family: 'Bebas Neue', sans-serif; font-size: 14px; font-weight: 600;">Previous Session</button>
                    <button class="heatmap-interval-btn" data-interval="3" onclick="setHeatmapInterval(3)" style="padding: 8px 16px; border: 2px solid #ddd; background: white; color: #666; border-radius: 8px; cursor: pointer; font-family: 'Bebas Neue', sans-serif; font-size: 14px;">3 Sessions</button>
                    <button class="heatmap-interval-btn" data-interval="7" onclick="setHeatmapInterval(7)" style="padding: 8px 16px; border: 2px solid #ddd; background: white; color: #666; border-radius: 8px; cursor: pointer; font-family: 'Bebas Neue', sans-serif; font-size: 14px;">7 Sessions</button>
                    <button class="heatmap-interval-btn" data-interval="15" onclick="setHeatmapInterval(15)" style="padding: 8px 16px; border: 2px solid #ddd; background: white; color: #666; border-radius: 8px; cursor: pointer; font-family: 'Bebas Neue', sans-serif; font-size: 14px;">15 Sessions</button>
                    <button class="heatmap-interval-btn" data-interval="30" onclick="setHeatmapInterval(30)" style="padding: 8px 16px; border: 2px solid #ddd; background: white; color: #666; border-radius: 8px; cursor: pointer; font-family: 'Bebas Neue', sans-serif; font-size: 14px;">30 Sessions</button>
                    <button class="heatmap-interval-btn" data-interval="60" onclick="setHeatmapInterval(60)" style="padding: 8px 16px; border: 2px solid #ddd; background: white; color: #666; border-radius: 8px; cursor: pointer; font-family: 'Bebas Neue', sans-serif; font-size: 14px;">60 Sessions</button>
                    <button class="heatmap-interval-btn" data-interval="all" onclick="setHeatmapInterval('all')" style="padding: 8px 16px; border: 2px solid #ddd; background: white; color: #666; border-radius: 8px; cursor: pointer; font-family: 'Bebas Neue', sans-serif; font-size: 14px;">All Time</button>
                </div>
                
                <div style="position: relative; width: 100%; height: 500px; border: 2px solid #ddd; border-radius: 8px; background: #f8f9fa;">
                    <canvas id="shotHeatmap" style="width: 100%; height: 100%; border-radius: 6px;"></canvas>
                </div>
                <div style="margin-top: 15px; display: flex; gap: 20px; align-items: center; justify-content: center; flex-wrap: wrap;">
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <div style="width: 20px; height: 20px; background: #00ff00; border-radius: 50%; border: 2px solid #333;"></div>
                        <span style="font-size: 14px; color: #666;">Make</span>
                    </div>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <div style="width: 20px; height: 20px; background: #ff0000; border-radius: 50%; border: 2px solid #333;"></div>
                        <span style="font-size: 14px; color: #666;">Miss</span>
                    </div>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <div style="width: 20px; height: 20px; background: linear-gradient(to right, rgba(0,255,0,0.1), rgba(255,0,0,0.8)); border-radius: 4px; border: 1px solid #333;"></div>
                        <span style="font-size: 14px; color: #666;">Heat Intensity</span>
                    </div>
                </div>
            </div>
            <div id="trainingStats" style="margin-top: 30px; display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px;">
                <!-- Stats will be populated here -->
            </div>
        </div>
    </div>

    <!-- Progress Pics View -->
    <div id="progressPicsView" class="tab-view" style="display: none;">
        <div class="container" style="max-width: 1200px; margin: 40px auto; padding: 20px;">
            <h2 style="font-family: 'Bebas Neue', sans-serif; margin-bottom: 30px;">ðŸ“¸ Progress Pics</h2>
            <p style="color: var(--text-gray); margin-bottom: 30px; text-align: center;">
                Track your progress by uploading photos daily. See how far you've come!
            </p>
            
            <!-- Upload Section -->
            <div style="background: var(--bg-surface); padding: 30px; border-radius: 12px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); margin-bottom: 30px;">
                <h3 style="font-family: 'Bebas Neue', sans-serif; margin-bottom: 20px; color: var(--text-dark);">Add New Progress Pic</h3>
                <div style="display: flex; flex-direction: column; gap: 15px; align-items: center;">
                    <input type="file" id="progressPicUpload" accept="image/*" capture="environment" style="display: none;">
                    <button id="selectProgressPicBtn" class="btn btn-primary" style="min-width: 200px; padding: 12px 24px;">
                        ðŸ“· Choose Photo
                    </button>
                    <div id="progressPicPreview" style="display: none; margin-top: 20px; width: 100%; max-width: 300px;">
                        <img id="previewImage" src="" alt="Preview" style="max-width: 100%; max-height: 300px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.2); display: block; margin: 0 auto;">
                        <div style="margin-top: 15px; width: 100%;">
                            <label style="display: block; margin-bottom: 5px; font-weight: 600; font-size: 14px; color: var(--text-dark); font-family: 'Bebas Neue', sans-serif;">Caption (optional):</label>
                            <input type="text" id="progressPicCaption" placeholder="e.g., Weight: 180 lbs, Body Fat: 12%" style="width: 100%; padding: 10px; border: 2px solid #ddd; border-radius: 8px; font-family: 'Bebas Neue', sans-serif; font-size: 14px; box-sizing: border-box;">
                            <div style="font-size: 12px; color: var(--text-gray); margin-top: 5px; font-family: 'Bebas Neue', sans-serif;">Add weight, body fat %, or any notes</div>
                        </div>
                        <div style="margin-top: 15px; display: flex; gap: 10px; justify-content: center;">
                            <button id="saveProgressPicBtn" class="btn btn-success" style="min-width: 150px;">ðŸ’¾ Save Photo</button>
                            <button id="cancelProgressPicBtn" class="btn btn-secondary" style="min-width: 150px;">âŒ Cancel</button>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Gallery Section -->
            <div style="background: var(--bg-surface); padding: 30px; border-radius: 12px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                <h3 style="font-family: 'Bebas Neue', sans-serif; margin-bottom: 20px; color: var(--text-dark);">Your Progress Gallery</h3>
                <div id="progressPicsGallery" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(250px, 1fr)); gap: 20px;">
                    <p style="grid-column: 1 / -1; text-align: center; color: var(--text-gray); padding: 40px;">
                        No progress pics yet. Upload your first photo to get started!
                    </p>
                </div>
            </div>
        </div>
    </div>

    <!-- Badges View -->
    <div id="badgesView" class="tab-view" style="display: none;">
        <div class="container" style="max-width: 1200px; margin: 40px auto; padding: 20px;">
            <h2 style="font-family: 'Bebas Neue', sans-serif; margin-bottom: 30px;">Your Badges</h2>
            <div id="badgesContainer" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(250px, 1fr)); gap: 30px;">
                <!-- Badges will be populated here -->
            </div>
        </div>
    </div>

    <!-- Workouts View -->
    <div id="workoutsView" class="tab-view" style="display: none;">
        <div class="container" style="max-width: 1200px; margin: 40px auto; padding: 20px;">
            <h2 style="font-family: 'Bebas Neue', sans-serif; margin-bottom: 30px;">Workout Tracker</h2>
            
            <!-- Tabs for different workout sections -->
            <div style="display: flex; gap: 10px; border-bottom: 2px solid #e2e8f0; margin-bottom: 30px;">
                <button id="weeklyScheduleTab" class="chart-tab active" onclick="switchWorkoutTab('schedule')" style="padding: 10px 20px; background: none; border: none; border-bottom: 3px solid var(--primary-color); color: var(--primary-color); font-weight: 600; cursor: pointer; font-family: 'Bebas Neue', sans-serif;">Weekly Schedule</button>
                <button id="customGymTab" class="chart-tab" onclick="switchWorkoutTab('gym')" style="padding: 10px 20px; background: none; border: none; border-bottom: 3px solid transparent; color: #aaa; cursor: pointer; font-family: 'Bebas Neue', sans-serif;">Custom Gym Workouts</button>
                <button id="customSportsTab" class="chart-tab" onclick="switchWorkoutTab('sports')" style="padding: 10px 20px; background: none; border: none; border-bottom: 3px solid transparent; color: #aaa; cursor: pointer; font-family: 'Bebas Neue', sans-serif;">Custom Sports Workouts</button>
            </div>
            
            <!-- Weekly Schedule Section -->
            <div id="weeklyScheduleSection" class="workout-section">
                <div style="background: white; padding: 30px; border-radius: 12px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); margin-bottom: 30px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                        <h3 style="font-family: 'Bebas Neue', sans-serif; margin: 0;">Weekly Workout Schedule</h3>
                        <div style="display: flex; gap: 10px; align-items: center;">
                            <!-- Google Calendar sync button hidden for now -->
                            <!-- <button id="syncToCalendarBtn" onclick="syncToGoogleCalendar()" class="btn" style="padding: 8px 16px; background: #34a853; color: white;">
                                ðŸ“… Sync to Google Calendar
                            </button> -->
                            <button id="editScheduleBtn" onclick="toggleScheduleEditMode()" class="btn btn-secondary" style="padding: 8px 16px;">Edit</button>
                        </div>
                    </div>
                    <!-- Google Calendar status hidden for now -->
                    <!-- <div id="calendarStatus" style="margin-bottom: 15px; padding: 10px; background: #f8f9fa; border-radius: 8px; font-family: 'Bebas Neue', sans-serif; font-size: 14px; color: #666;">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <span id="calendarStatusText">Click "Connect Google Calendar" to sync your schedule</span>
                            <a href="https://calendar.google.com" target="_blank" style="color: #4285f4; text-decoration: none; font-weight: 600; margin-left: 10px;">
                                ðŸ“… Open Google Calendar â†’
                            </a>
                        </div>
                    </div> -->
                    <div style="overflow-x: auto;">
                        <div id="weeklyScheduleContainer" style="display: grid; grid-template-columns: repeat(7, 1fr); gap: 15px; font-family: 'Bebas Neue', sans-serif;">
                            <!-- Weekly schedule will be populated here -->
                        </div>
                    </div>
                </div>
                
                <!-- Add Workout to Day Modal/Form -->
                <div id="addWorkoutToDayForm" style="background: white; padding: 30px; border-radius: 12px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); display: none;">
                    <h3 style="font-family: 'Bebas Neue', sans-serif; margin-bottom: 20px;">Add Workout to <span id="selectedDayName"></span></h3>
                    <div style="margin-bottom: 15px;">
                        <label style="display: block; margin-bottom: 5px; font-weight: 600; font-size: 14px;">Select Workout:</label>
                        <select id="workoutSelect" style="width: 100%; padding: 10px; border: 2px solid #ddd; border-radius: 8px; font-family: 'Bebas Neue', sans-serif;">
                            <option value="">-- Select a workout --</option>
                        </select>
                    </div>
                    <div style="display: flex; gap: 10px;">
                        <button onclick="addWorkoutToDay()" class="btn" style="padding: 10px 20px; background: #6b7280; color: white;">Add</button>
                        <button onclick="cancelAddWorkoutToDay()" class="btn btn-secondary" style="padding: 10px 20px;">Cancel</button>
                    </div>
                </div>
            </div>
            
            <!-- Custom Gym Workouts Section -->
            <div id="customGymSection" class="workout-section" style="display: none;">
                <div style="background: white; padding: 30px; border-radius: 12px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); margin-bottom: 30px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                        <h3 style="font-family: 'Bebas Neue', sans-serif; margin: 0;">My Custom Gym Workouts</h3>
                        <button onclick="showCreateGymWorkoutForm()" class="btn" style="padding: 10px 20px; background: #6b7280; color: white;">Create New Workout</button>
                    </div>
                    <div id="customGymWorkoutsList">
                        <!-- Custom gym workouts will be populated here -->
                    </div>
                </div>
                
                <!-- Create/Edit Gym Workout Form -->
                <div id="createGymWorkoutForm" style="background: white; padding: 30px; border-radius: 12px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); display: none;">
                    <h3 style="font-family: 'Bebas Neue', sans-serif; margin-bottom: 20px;" id="gymWorkoutFormTitle">Create Custom Gym Workout</h3>
                    <div style="margin-bottom: 20px;">
                        <label style="display: block; margin-bottom: 5px; font-weight: 600; font-size: 14px;">Workout Name:</label>
                        <input type="text" id="gymWorkoutName" placeholder="e.g., Push Day" style="width: 100%; padding: 10px; border: 2px solid #ddd; border-radius: 8px; font-family: 'Bebas Neue', sans-serif;">
                    </div>
                    <div style="margin-bottom: 20px;">
                        <label style="display: block; margin-bottom: 10px; font-weight: 600; font-size: 14px;">Days of the Week:</label>
                        <div style="display: flex; flex-wrap: wrap; gap: 15px; font-family: 'Bebas Neue', sans-serif;">
                            <label style="display: flex; align-items: center; cursor: pointer; color: #1a1a1a; font-weight: 500;">
                                <input type="checkbox" id="gymWorkoutDay-Monday" value="Monday" style="margin-right: 8px; width: 18px; height: 18px; cursor: pointer;">
                                Monday
                            </label>
                            <label style="display: flex; align-items: center; cursor: pointer; color: #1a1a1a; font-weight: 500;">
                                <input type="checkbox" id="gymWorkoutDay-Tuesday" value="Tuesday" style="margin-right: 8px; width: 18px; height: 18px; cursor: pointer;">
                                Tuesday
                            </label>
                            <label style="display: flex; align-items: center; cursor: pointer; color: #1a1a1a; font-weight: 500;">
                                <input type="checkbox" id="gymWorkoutDay-Wednesday" value="Wednesday" style="margin-right: 8px; width: 18px; height: 18px; cursor: pointer;">
                                Wednesday
                            </label>
                            <label style="display: flex; align-items: center; cursor: pointer; color: #1a1a1a; font-weight: 500;">
                                <input type="checkbox" id="gymWorkoutDay-Thursday" value="Thursday" style="margin-right: 8px; width: 18px; height: 18px; cursor: pointer;">
                                Thursday
                            </label>
                            <label style="display: flex; align-items: center; cursor: pointer; color: #1a1a1a; font-weight: 500;">
                                <input type="checkbox" id="gymWorkoutDay-Friday" value="Friday" style="margin-right: 8px; width: 18px; height: 18px; cursor: pointer;">
                                Friday
                            </label>
                            <label style="display: flex; align-items: center; cursor: pointer; color: #1a1a1a; font-weight: 500;">
                                <input type="checkbox" id="gymWorkoutDay-Saturday" value="Saturday" style="margin-right: 8px; width: 18px; height: 18px; cursor: pointer;">
                                Saturday
                            </label>
                            <label style="display: flex; align-items: center; cursor: pointer; color: #1a1a1a; font-weight: 500;">
                                <input type="checkbox" id="gymWorkoutDay-Sunday" value="Sunday" style="margin-right: 8px; width: 18px; height: 18px; cursor: pointer;">
                                Sunday
                            </label>
                        </div>
                    </div>
                    <div id="gymWorkoutExercises" style="margin-bottom: 20px;">
                        <h4 style="font-family: 'Bebas Neue', sans-serif; margin-bottom: 15px;">Exercises</h4>
                        <div id="gymWorkoutExercisesList">
                            <!-- Exercises will be added here -->
                        </div>
                        <button onclick="addExerciseToGymWorkout()" class="btn btn-secondary" style="padding: 8px 16px; margin-top: 10px;">+ Add Exercise</button>
                    </div>
                    <div style="display: flex; gap: 10px;">
                        <button onclick="saveGymWorkout()" class="btn" style="padding: 10px 20px; background: #6b7280; color: white;">Save Workout</button>
                        <button onclick="cancelGymWorkoutForm()" class="btn btn-secondary" style="padding: 10px 20px;">Cancel</button>
                    </div>
                </div>
            </div>
            
            <!-- Custom Sports Workouts Section -->
            <div id="customSportsSection" class="workout-section" style="display: none;">
                <div style="background: white; padding: 30px; border-radius: 12px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); margin-bottom: 30px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                        <h3 style="font-family: 'Bebas Neue', sans-serif; margin: 0;">My Custom Sports Workouts</h3>
                        <button onclick="showCreateSportsWorkoutForm()" class="btn" style="padding: 10px 20px; background: #6b7280; color: white;">Create New Workout</button>
                    </div>
                    <div id="customSportsWorkoutsList">
                        <!-- Custom sports workouts will be populated here -->
                    </div>
                </div>
                
                <!-- Create/Edit Sports Workout Form -->
                <div id="createSportsWorkoutForm" style="background: white; padding: 30px; border-radius: 12px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); display: none;">
                    <h3 style="font-family: 'Bebas Neue', sans-serif; margin-bottom: 20px;" id="sportsWorkoutFormTitle">Create Custom Sports Workout</h3>
                    <div style="margin-bottom: 20px;">
                        <label style="display: block; margin-bottom: 5px; font-weight: 600; font-size: 14px;">Workout Name:</label>
                        <input type="text" id="sportsWorkoutName" placeholder="e.g., Shooting Practice" style="width: 100%; padding: 10px; border: 2px solid #ddd; border-radius: 8px; font-family: 'Bebas Neue', sans-serif;">
                    </div>
                    <div style="margin-bottom: 20px;">
                        <label style="display: block; margin-bottom: 10px; font-weight: 600; font-size: 14px;">Days of the Week:</label>
                        <div style="display: flex; flex-wrap: wrap; gap: 15px; font-family: 'Bebas Neue', sans-serif;">
                            <label style="display: flex; align-items: center; cursor: pointer; color: #1a1a1a; font-weight: 500;">
                                <input type="checkbox" id="sportsWorkoutDay-Monday" value="Monday" style="margin-right: 8px; width: 18px; height: 18px; cursor: pointer;">
                                Monday
                            </label>
                            <label style="display: flex; align-items: center; cursor: pointer; color: #1a1a1a; font-weight: 500;">
                                <input type="checkbox" id="sportsWorkoutDay-Tuesday" value="Tuesday" style="margin-right: 8px; width: 18px; height: 18px; cursor: pointer;">
                                Tuesday
                            </label>
                            <label style="display: flex; align-items: center; cursor: pointer; color: #1a1a1a; font-weight: 500;">
                                <input type="checkbox" id="sportsWorkoutDay-Wednesday" value="Wednesday" style="margin-right: 8px; width: 18px; height: 18px; cursor: pointer;">
                                Wednesday
                            </label>
                            <label style="display: flex; align-items: center; cursor: pointer; color: #1a1a1a; font-weight: 500;">
                                <input type="checkbox" id="sportsWorkoutDay-Thursday" value="Thursday" style="margin-right: 8px; width: 18px; height: 18px; cursor: pointer;">
                                Thursday
                            </label>
                            <label style="display: flex; align-items: center; cursor: pointer; color: #1a1a1a; font-weight: 500;">
                                <input type="checkbox" id="sportsWorkoutDay-Friday" value="Friday" style="margin-right: 8px; width: 18px; height: 18px; cursor: pointer;">
                                Friday
                            </label>
                            <label style="display: flex; align-items: center; cursor: pointer; color: #1a1a1a; font-weight: 500;">
                                <input type="checkbox" id="sportsWorkoutDay-Saturday" value="Saturday" style="margin-right: 8px; width: 18px; height: 18px; cursor: pointer;">
                                Saturday
                            </label>
                            <label style="display: flex; align-items: center; cursor: pointer; color: #1a1a1a; font-weight: 500;">
                                <input type="checkbox" id="sportsWorkoutDay-Sunday" value="Sunday" style="margin-right: 8px; width: 18px; height: 18px; cursor: pointer;">
                                Sunday
                            </label>
                        </div>
                    </div>
                    <div style="margin-bottom: 20px;">
                        <label style="display: block; margin-bottom: 5px; font-weight: 600; font-size: 14px;">Workout Details:</label>
                        <textarea id="sportsWorkoutDetails" placeholder="e.g., Shoot 1000 shots from the three-point line, focusing on form and consistency" rows="5" style="width: 100%; padding: 10px; border: 2px solid #ddd; border-radius: 8px; font-family: 'Bebas Neue', sans-serif; resize: vertical;"></textarea>
                    </div>
                    <div style="display: flex; gap: 10px;">
                        <button onclick="saveSportsWorkout()" class="btn" style="padding: 10px 20px; background: #6b7280; color: white;">Save Workout</button>
                        <button onclick="cancelSportsWorkoutForm()" class="btn btn-secondary" style="padding: 10px 20px;">Cancel</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Nutrition View -->
    <div id="nutritionView" class="tab-view" style="display: none;">
        <div class="container" style="max-width: 1200px; margin: 40px auto; padding: 20px;">
            <h2 style="font-family: 'Bebas Neue', sans-serif; margin-bottom: 30px;">Nutrition Tracker</h2>
            
            <!-- Settings for goals -->
            <div style="background: white; padding: 20px; border-radius: 12px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); margin-bottom: 30px;">
                <h3 style="font-family: 'Bebas Neue', sans-serif; margin-bottom: 15px; color: #333;">Daily Goals</h3>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                    <div>
                        <label style="display: block; margin-bottom: 5px; font-weight: 600; color: #333;">Daily Calorie Goal:</label>
                        <input type="number" id="calorieGoal" placeholder="2000" style="width: 100%; padding: 8px; border: 2px solid #ddd; border-radius: 8px; font-family: 'Bebas Neue', sans-serif; color: #333;">
                    </div>
                    <div>
                        <label style="display: block; margin-bottom: 5px; font-weight: 600; color: #333;">Ideal Weight (lbs):</label>
                        <input type="number" id="idealWeight" placeholder="150" style="width: 100%; padding: 8px; border: 2px solid #ddd; border-radius: 8px; font-family: 'Bebas Neue', sans-serif; color: #333;">
                    </div>
                    <div>
                        <label style="display: block; margin-bottom: 5px; font-weight: 600; color: #333;">Daily Protein Goal (g):</label>
                        <input type="number" id="proteinGoal" placeholder="150" style="width: 100%; padding: 8px; border: 2px solid #ddd; border-radius: 8px; font-family: 'Bebas Neue', sans-serif; color: #333;">
                    </div>
                    <div style="display: flex; align-items: flex-end;">
                        <button onclick="saveNutritionGoalsLocal()" class="btn btn-primary" style="width: 100%;">Save Goals</button>
                    </div>
                </div>
            </div>

            <!-- Nutrition Section Tabs -->
            <div style="display: flex; gap: 10px; border-bottom: 2px solid #e2e8f0; margin-bottom: 30px;">
                <button id="nutritionTrackerTab" class="chart-tab active" onclick="switchNutritionTab('tracker')" style="padding: 10px 20px; background: none; border: none; border-bottom: 3px solid var(--primary-color); color: var(--primary-color); font-weight: 600; cursor: pointer; font-family: 'Bebas Neue', sans-serif;">Nutrition Tracker</button>
                <button id="customDietPlansTab" class="chart-tab" onclick="switchNutritionTab('dietPlans')" style="padding: 10px 20px; background: none; border: none; border-bottom: 3px solid transparent; color: #aaa; cursor: pointer; font-family: 'Bebas Neue', sans-serif;">Custom Diet Plans</button>
            </div>

            <!-- Nutrition Tracker Section -->
            <div id="nutritionTrackerSection" class="nutrition-section">
            <!-- Chart Tabs -->
            <div style="background: white; padding: 30px; border-radius: 12px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); margin-bottom: 30px;">
                <div style="display: flex; gap: 10px; border-bottom: 2px solid #e2e8f0; margin-bottom: 15px;">
                    <button id="calorieChartTab" class="chart-tab active" onclick="switchNutritionChart('calories')">Daily Calories</button>
                    <button id="weightChartTab" class="chart-tab" onclick="switchNutritionChart('weight')">Weight</button>
                </div>
                <div style="display: flex; gap: 8px; margin-bottom: 20px; flex-wrap: wrap;">
                    <button class="period-tab" data-days="3" onclick="switchTimePeriod(3, this)">Past 3 days</button>
                    <button class="period-tab active" data-days="7" onclick="switchTimePeriod(7, this)">Past 7 days</button>
                    <button class="period-tab" data-days="15" onclick="switchTimePeriod(15, this)">Past 15 days</button>
                    <button class="period-tab" data-days="30" onclick="switchTimePeriod(30, this)">Past 30 days</button>
                    <button class="period-tab" data-days="60" onclick="switchTimePeriod(60, this)">Past 60 days</button>
                </div>
                <canvas id="nutritionChart" style="max-height: 400px;"></canvas>
                <!-- Weight Entry Form (shown only on weight tab) -->
                <div id="weightEntryForm" style="display: none; margin-top: 20px; padding-top: 20px; border-top: 2px solid #e2e8f0;">
                    <h4 style="font-family: 'Bebas Neue', sans-serif; margin-bottom: 15px;">Add Weight Entry</h4>
                    <div style="display: grid; grid-template-columns: 1fr auto; gap: 10px; align-items: end;">
                        <div>
                            <label style="display: block; margin-bottom: 5px; font-weight: 600; font-size: 14px;">Weight (lbs):</label>
                            <input type="number" id="weightInput" placeholder="150" step="0.1" min="0" style="width: 100%; padding: 10px; border: 2px solid #ddd; border-radius: 8px; font-family: 'Bebas Neue', sans-serif;">
                        </div>
                        <div>
                            <button onclick="addWeightEntry()" class="btn" style="padding: 10px 20px; background: #6b7280; color: white;">Add Weight</button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Daily Food Log -->
            <div id="foodLogSection" style="background: white; padding: 30px; border-radius: 12px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); margin-bottom: 30px;">
                <h3 id="foodLogTitle" style="font-family: 'Bebas Neue', sans-serif; margin-bottom: 20px;">Today's Food Log</h3>
                <div id="dailyFoodLog" style="display: flex; flex-direction: column; gap: 10px;">
                    <!-- Food log entries will be populated here -->
                </div>
                <div id="dailyTotals" style="margin-top: 20px; padding-top: 20px; border-top: 2px solid #e2e8f0; display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 15px;">
                    <!-- Totals will be calculated and displayed here -->
                </div>
            </div>

            <!-- Food Entry Section -->
            <div style="background: white; padding: 30px; border-radius: 12px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); margin-bottom: 30px;">
                <h3 style="font-family: 'Bebas Neue', sans-serif; margin-bottom: 20px;">Add Food</h3>
                
                <!-- Regular Food Entry -->
                <div id="regularFoodEntry" style="display: grid; grid-template-columns: 2fr 1fr 1fr 1fr auto; gap: 10px; margin-bottom: 20px; align-items: end;">
                    <div>
                        <label style="display: block; margin-bottom: 5px; font-weight: 600; font-size: 14px;">Food Name:</label>
                        <input type="text" id="foodName" placeholder="e.g., Grilled Chicken" style="width: 100%; padding: 10px; border: 2px solid #ddd; border-radius: 8px; font-family: 'Bebas Neue', sans-serif;">
                    </div>
                    <div>
                        <label style="display: block; margin-bottom: 5px; font-weight: 600; font-size: 14px;">Servings:</label>
                        <input type="number" id="foodServings" placeholder="1" step="0.25" min="0" style="width: 100%; padding: 10px; border: 2px solid #ddd; border-radius: 8px; font-family: 'Bebas Neue', sans-serif;">
                    </div>
                    <div>
                        <label style="display: block; margin-bottom: 5px; font-weight: 600; font-size: 14px;">Calories per serving:</label>
                        <input type="number" id="foodCalories" placeholder="200" min="0" style="width: 100%; padding: 10px; border: 2px solid #ddd; border-radius: 8px; font-family: 'Bebas Neue', sans-serif;">
                    </div>
                    <div>
                        <label style="display: block; margin-bottom: 5px; font-weight: 600; font-size: 14px;">Protein per serving (g):</label>
                        <input type="number" id="foodProtein" placeholder="25" min="0" step="0.1" style="width: 100%; padding: 10px; border: 2px solid #ddd; border-radius: 8px; font-family: 'Bebas Neue', sans-serif;">
                    </div>
                    <div>
                        <button onclick="addFood()" class="btn" style="padding: 10px 20px; background: #6b7280; color: white;">Add</button>
                    </div>
                </div>

                <!-- Favorites Section -->
                <div style="border-top: 2px solid #e2e8f0; padding-top: 20px;">
                    <h4 style="font-family: 'Bebas Neue', sans-serif; margin-bottom: 15px;">Favorites</h4>
                    <div style="display: grid; grid-template-columns: 2fr 1fr 1fr auto; gap: 10px; align-items: end; margin-bottom: 20px;">
                        <div>
                            <label style="display: block; margin-bottom: 5px; font-weight: 600; font-size: 14px;">Add to Favorites:</label>
                            <input type="text" id="favoriteFoodName" placeholder="Food name" style="width: 100%; padding: 10px; border: 2px solid #ddd; border-radius: 8px; font-family: 'Bebas Neue', sans-serif;">
                        </div>
                        <div>
                            <label style="display: block; margin-bottom: 5px; font-weight: 600; font-size: 14px;">Calories per serving:</label>
                            <input type="number" id="favoriteCalories" placeholder="200" min="0" style="width: 100%; padding: 10px; border: 2px solid #ddd; border-radius: 8px; font-family: 'Bebas Neue', sans-serif;">
                        </div>
                        <div>
                            <label style="display: block; margin-bottom: 5px; font-weight: 600; font-size: 14px;">Protein per serving (g):</label>
                            <input type="number" id="favoriteProtein" placeholder="25" min="0" step="0.1" style="width: 100%; padding: 10px; border: 2px solid #ddd; border-radius: 8px; font-family: 'Bebas Neue', sans-serif;">
                        </div>
                        <div>
                            <button onclick="addFavorite()" class="btn" style="padding: 10px 20px; white-space: nowrap; background: #6b7280; color: white;">Save Favorite</button>
                        </div>
                    </div>
                    <div id="favoritesList" style="display: flex; flex-direction: column; gap: 10px;">
                        <!-- Favorites will be populated here -->
                    </div>
                </div>
            </div>
            </div>

            <!-- Custom Diet Plans Section -->
            <div id="customDietPlansSection" class="nutrition-section" style="display: none;">
                <div style="background: white; padding: 30px; border-radius: 12px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); margin-bottom: 30px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                        <h3 style="font-family: 'Bebas Neue', sans-serif; margin: 0;">My Custom Diet Plans</h3>
                        <button onclick="showCreateDietPlanForm()" class="btn" style="padding: 10px 20px; background: #6b7280; color: white;">Create New Diet Plan</button>
                    </div>
                    <div id="customDietPlansList">
                        <!-- Custom diet plans will be populated here -->
                    </div>
                </div>
                
                <!-- Create/Edit Diet Plan Form -->
                <div id="createDietPlanForm" style="background: white; padding: 30px; border-radius: 12px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); display: none;">
                    <h3 style="font-family: 'Bebas Neue', sans-serif; margin-bottom: 20px;" id="dietPlanFormTitle">Create Custom Diet Plan</h3>
                    <div style="margin-bottom: 20px;">
                        <label style="display: block; margin-bottom: 5px; font-weight: 600; font-size: 14px;">Plan Name:</label>
                        <input type="text" id="dietPlanName" placeholder="e.g., High Protein Cutting Plan" style="width: 100%; padding: 10px; border: 2px solid #ddd; border-radius: 8px; font-family: 'Bebas Neue', sans-serif;">
                    </div>
                    <div style="margin-bottom: 20px;">
                        <label style="display: block; margin-bottom: 10px; font-weight: 600; font-size: 14px;">Days of the Week:</label>
                        <div style="display: flex; flex-wrap: wrap; gap: 15px; font-family: 'Bebas Neue', sans-serif;">
                            <label style="display: flex; align-items: center; cursor: pointer; color: #1a1a1a; font-weight: 500;">
                                <input type="checkbox" id="dietPlanDay-Monday" value="Monday" style="margin-right: 8px; width: 18px; height: 18px; cursor: pointer;">
                                Monday
                            </label>
                            <label style="display: flex; align-items: center; cursor: pointer; color: #1a1a1a; font-weight: 500;">
                                <input type="checkbox" id="dietPlanDay-Tuesday" value="Tuesday" style="margin-right: 8px; width: 18px; height: 18px; cursor: pointer;">
                                Tuesday
                            </label>
                            <label style="display: flex; align-items: center; cursor: pointer; color: #1a1a1a; font-weight: 500;">
                                <input type="checkbox" id="dietPlanDay-Wednesday" value="Wednesday" style="margin-right: 8px; width: 18px; height: 18px; cursor: pointer;">
                                Wednesday
                            </label>
                            <label style="display: flex; align-items: center; cursor: pointer; color: #1a1a1a; font-weight: 500;">
                                <input type="checkbox" id="dietPlanDay-Thursday" value="Thursday" style="margin-right: 8px; width: 18px; height: 18px; cursor: pointer;">
                                Thursday
                            </label>
                            <label style="display: flex; align-items: center; cursor: pointer; color: #1a1a1a; font-weight: 500;">
                                <input type="checkbox" id="dietPlanDay-Friday" value="Friday" style="margin-right: 8px; width: 18px; height: 18px; cursor: pointer;">
                                Friday
                            </label>
                            <label style="display: flex; align-items: center; cursor: pointer; color: #1a1a1a; font-weight: 500;">
                                <input type="checkbox" id="dietPlanDay-Saturday" value="Saturday" style="margin-right: 8px; width: 18px; height: 18px; cursor: pointer;">
                                Saturday
                            </label>
                            <label style="display: flex; align-items: center; cursor: pointer; color: #1a1a1a; font-weight: 500;">
                                <input type="checkbox" id="dietPlanDay-Sunday" value="Sunday" style="margin-right: 8px; width: 18px; height: 18px; cursor: pointer;">
                                Sunday
                            </label>
                        </div>
                    </div>
                    <div id="dietPlanMeals" style="margin-bottom: 20px;">
                        <h4 style="font-family: 'Bebas Neue', sans-serif; margin-bottom: 15px;">Meals</h4>
                        <div style="margin-bottom: 10px; padding: 10px; background: #f8f9fa; border-radius: 4px; font-size: 12px; color: #666; font-family: 'Bebas Neue', sans-serif;">
                            <strong>Time fields:</strong> Hour (1-12), Minute (0-59), AM/PM
                        </div>
                        <div id="dietPlanMealsList">
                            <!-- Meals will be added here -->
                        </div>
                        <button onclick="addMealToDietPlan()" class="btn btn-secondary" style="padding: 8px 16px; margin-top: 10px;">+ Add Meal</button>
                    </div>
                    <div id="dietPlanTotals" style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; font-family: 'Bebas Neue', sans-serif;">
                            <div>
                                <strong>Total Calories:</strong> <span id="dietPlanTotalCalories">0</span>
                            </div>
                            <div>
                                <strong>Total Protein:</strong> <span id="dietPlanTotalProtein">0</span> g
                            </div>
                        </div>
                    </div>
                    <div style="display: flex; gap: 10px;">
                        <button onclick="saveDietPlan()" class="btn" style="padding: 10px 20px; background: #6b7280; color: white;">Save Diet Plan</button>
                        <button onclick="cancelDietPlanForm()" class="btn btn-secondary" style="padding: 10px 20px;">Cancel</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Player Benchmark Data -->
    <script src="/tool/player_data/lebron_benchmark.js"></script>
    <script src="/tool/player_data/curry_benchmark.js"></script>
    <script>
        // ====================== API CONFIGURATION ======================
        // Set the backend API base URL
        // If running Flask on a different port, change this to match (e.g., 'http://localhost:5001')
        // Set to empty string to disable backend and use only client-side detection
        // Using Python backend with AI-Basketball-Shot-Detection-Tracker (YOLOv8)
        const API_BASE_URL = 'http://localhost:5001';  // Python backend with YOLOv8 detection
        
        // ====================== GLOBAL STATE ======================
        // Make lebron_data available globally
        if (typeof lebron_data !== 'undefined') {
            window.lebron_benchmark_data = lebron_data;
        }
        // Make curry_data available globally
        if (typeof curry_data !== 'undefined') {
            window.curry_benchmark_data = curry_data;
        }
    </script>
    <script src="/tool/app.js"></script>
    <script>
        // Tab navigation functions
        let trainingChart = null;
        
        function showShotSync() {
            // Hide all tab views
            document.querySelectorAll('.tab-view').forEach(view => view.style.display = 'none');
            
            // Hide shot tracker section
            const shotTrackerSection = document.getElementById('shotTrackerSection');
            if (shotTrackerSection) shotTrackerSection.style.display = 'none';
            
            // Show ShotSync header
            const header = document.querySelector('header');
            if (header) header.style.display = 'block';
            
            // Show main content (player selection page)
            const mainContent = document.querySelector('.main-content');
            if (mainContent) mainContent.style.display = 'block';
            
            // Show step2 (record shot) by default - skip player selection
            document.querySelectorAll('.step').forEach(step => step.style.display = 'none');
            const step2 = document.getElementById('step2');
            if (step2) step2.style.display = 'block';
            
            // Update nav tabs
            document.querySelectorAll('.nav-tab').forEach(tab => tab.classList.remove('active'));
            document.getElementById('shotSyncTab').classList.add('active');
            
            // Save active tab to localStorage
            localStorage.setItem('activeTab', 'shotSync');
        }
        
        window.showWorkouts = showWorkouts;
        
        function showTrainingDatabase() {
            // Hide all views
            document.querySelectorAll('.tab-view').forEach(view => view.style.display = 'none');
            const mainContent = document.querySelector('.main-content');
            if (mainContent) mainContent.style.display = 'none';
            
            // Hide ShotSync header on Training Database page
            const header = document.querySelector('header');
            if (header) header.style.display = 'none';

            // Show training database
            document.getElementById('trainingDatabaseView').style.display = 'block';
            
            // Update nav tabs
            document.querySelectorAll('.nav-tab').forEach(tab => tab.classList.remove('active'));
            document.getElementById('trainingDbTab').classList.add('active');
            
            // Save active tab to localStorage
            localStorage.setItem('activeTab', 'trainingDatabase');
            
            // Load training data
            loadTrainingDatabase();
        }
        
        function showProgressPics() {
            // Hide all views
            document.querySelectorAll('.tab-view').forEach(view => view.style.display = 'none');
            const mainContent = document.querySelector('.main-content');
            if (mainContent) mainContent.style.display = 'none';

            // Hide ShotSync header on Progress Pics page
            const header = document.querySelector('header');
            if (header) header.style.display = 'none';

            // Show progress pics
            document.getElementById('progressPicsView').style.display = 'block';
            
            // Update nav tabs
            document.querySelectorAll('.nav-tab').forEach(tab => tab.classList.remove('active'));
            document.getElementById('progressPicsTab').classList.add('active');
            
            // Save active tab to localStorage
            localStorage.setItem('activeTab', 'progressPics');
            
            // Load progress pics
            loadProgressPics();
        }
        
        function showBadges() {
            // Hide all views
            document.querySelectorAll('.tab-view').forEach(view => view.style.display = 'none');
            const mainContent = document.querySelector('.main-content');
            if (mainContent) mainContent.style.display = 'none';

            // Hide ShotSync header on Badges page
            const header = document.querySelector('header');
            if (header) header.style.display = 'none';

            // Show badges
            document.getElementById('badgesView').style.display = 'block';
            
            // Update nav tabs
            document.querySelectorAll('.nav-tab').forEach(tab => tab.classList.remove('active'));
            document.getElementById('badgesTab').classList.add('active');
            
            // Save active tab to localStorage
            localStorage.setItem('activeTab', 'badges');
            
            // Load badges
            loadBadges();
        }
        
        function showMainContent() {
            // Hide all tab views
            document.querySelectorAll('.tab-view').forEach(view => view.style.display = 'none');
            
            // Show main content
            const mainContent = document.querySelector('.main-content');
            if (mainContent) mainContent.style.display = 'block';
            
            // Update nav tabs
            document.querySelectorAll('.nav-tab').forEach(tab => tab.classList.remove('active'));
        }
        
        async function loadTrainingDatabase() {
            const user = window.firebaseAuth?.currentUser;
            if (!user) {
                document.getElementById('trainingChart').parentElement.innerHTML = '<p style="text-align: center; padding: 40px;">Please sign in to view your training database.</p>';
                return;
            }
            
            const playerFilter = document.getElementById('playerFilter').value;
            // Get all scores (including shot tracker sessions) - don't filter by player for shot tracker
            let scores = await window.getTrainingScores(user.uid, null);
            
            // If player filter is set and not empty, filter out shot tracker sessions (they're separate)
            if (playerFilter) {
                scores = scores.filter(s => s.player === playerFilter);
            } else {
                // Include all sessions (form sessions and shot tracker sessions)
                // No filtering needed
            }
            
            if (scores.length === 0) {
                document.getElementById('trainingChart').parentElement.innerHTML = '<p style="text-align: center; padding: 40px;">No training data yet. Start practicing to see your progress!</p>';
                document.getElementById('trainingStats').innerHTML = '';
                return;
            }
            
            // Prepare chart data
            const labels = [];
            const dataPoints = [];
            const playerNames = {
                'curry': 'Stephen Curry',
                'lebron': 'LeBron James',
                'jordan': 'Michael Jordan',
                'durant': 'Kevin Durant',
                'clark': 'Caitlin Clark',
                'custom': 'Custom',
                'shot_tracker': 'Shot Tracker'
            };
            
            // Create a copy for processing (don't modify original)
            const scoresCopy = [...scores];
            
            // Reverse to show chronological order
            scoresCopy.reverse().forEach((score, index) => {
                const date = score.createdAt?.toDate ? score.createdAt.toDate() : new Date();
                labels.push(date.toLocaleDateString());
                // Use similarityScore (which is percentage for shot tracker sessions)
                dataPoints.push(score.similarityScore || 0);
            });
            
            console.log('Loaded scores:', scores.length, 'shot tracker sessions:', scores.filter(s => s.sessionType === 'shot_tracker').length);
            
            // Create or update chart
            const ctx = document.getElementById('trainingChart').getContext('2d');
            if (trainingChart) {
                trainingChart.destroy();
            }
            
            trainingChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Similarity Score (%)',
                        data: dataPoints,
                        borderColor: 'rgb(255, 107, 122)',
                        backgroundColor: 'rgba(255, 107, 122, 0.1)',
                        tension: 0.4,
                        fill: true
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    plugins: {
                        title: {
                            display: true,
                            text: `Training Progress ${playerFilter ? `- ${playerNames[playerFilter] || playerFilter}` : ''}`,
                            font: {
                                size: 18,
                                family: "'Courier Prime', monospace"
                            }
                        },
                        legend: {
                            display: true
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            max: 100,
                            ticks: {
                                callback: function(value) {
                                    return value + '%';
                                }
                            }
                        }
                    }
                }
            });
            
            // Calculate stats - include shot tracker sessions
            const allScores = dataPoints;
            const shotTrackerSessions = scores.filter(s => s.sessionType === 'shot_tracker');
            const formSessions = scores.filter(s => !s.sessionType || s.sessionType !== 'shot_tracker');
            
            // Calculate form-based stats (only from form sessions, not shot tracker)
            const formScores = formSessions.map(s => s.similarityScore || 0);
            const avgScore = formScores.length > 0 ? formScores.reduce((a, b) => a + b, 0) / formScores.length : 0;
            const maxScore = formScores.length > 0 ? Math.max(...formScores) : 0;
            const minScore = formScores.length > 0 ? Math.min(...formScores) : 0;
            const recentFormScores = formScores.slice(-5);
            const recentAvg = recentFormScores.length > 0 ? recentFormScores.reduce((a, b) => a + b, 0) / recentFormScores.length : 0;
            
            // Calculate shot tracker stats
            const totalMakes = shotTrackerSessions.reduce((sum, s) => sum + (s.makes || 0), 0);
            const totalAttempts = shotTrackerSessions.reduce((sum, s) => sum + (s.attempts || 0), 0);
            const shotPercentage = totalAttempts > 0 ? Math.round((totalMakes / totalAttempts) * 100) : 0;
            
            // Update form similarity stats bar
            const formStatsBar = document.getElementById('formSimilarityStats');
            if (formStatsBar && formSessions.length > 0) {
                formStatsBar.style.display = 'block';
                document.getElementById('formTotalSessions').textContent = formSessions.length;
                document.getElementById('formAvgScore').textContent = avgScore.toFixed(1) + '%';
                document.getElementById('formBestScore').textContent = maxScore.toFixed(1) + '%';
                document.getElementById('formRecentAvg').textContent = recentAvg.toFixed(1) + '%';
            } else if (formStatsBar) {
                formStatsBar.style.display = 'none';
            }
            
            // Update shot tracker stats bar (will be updated by heatmap function based on interval)
            
            document.getElementById('trainingStats').innerHTML = `
                <div class="stat-card">
                    <div class="stat-label">Total Sessions</div>
                    <div class="stat-value">${scores.length}</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Form Sessions</div>
                    <div class="stat-value">${formSessions.length}</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Shot Tracker Sessions</div>
                    <div class="stat-value">${shotTrackerSessions.length}</div>
                </div>
            `;
            
            // Store scores and labels for heatmap filtering
            window.trainingScores = scoresCopy;
            window.trainingDateLabels = labels;
            
            // Load and render heatmap with current interval
            const currentInterval = window.currentHeatmapInterval || 'session';
            loadShotHeatmap(scoresCopy, labels, currentInterval);
        }
        
        // Heatmap interval state
        window.currentHeatmapInterval = 'session';
        
        function setHeatmapInterval(interval) {
            window.currentHeatmapInterval = interval;
            
            // Update button styles
            document.querySelectorAll('.heatmap-interval-btn').forEach(btn => {
                btn.classList.remove('active');
                btn.style.border = '2px solid #ddd';
                btn.style.background = 'white';
                btn.style.color = '#666';
            });
            
            const activeBtn = document.querySelector(`.heatmap-interval-btn[data-interval="${interval}"]`);
            if (activeBtn) {
                activeBtn.classList.add('active');
                activeBtn.style.border = '2px solid var(--primary-color)';
                activeBtn.style.background = 'var(--primary-color)';
                activeBtn.style.color = 'white';
            }
            
            // Reload heatmap with new interval
            if (window.trainingScores && window.trainingDateLabels) {
                loadShotHeatmap(window.trainingScores, window.trainingDateLabels, interval);
            }
        }
        
        async function loadShotHeatmap(scores, dateLabels, interval = 'session') {
            try {
                const heatmapCanvas = document.getElementById('shotHeatmap');
                if (!heatmapCanvas) return;
                
                const ctx = heatmapCanvas.getContext('2d');
                const rect = heatmapCanvas.parentElement.getBoundingClientRect();
                heatmapCanvas.width = rect.width;
                heatmapCanvas.height = 500;
                
                // Clear canvas
                ctx.clearRect(0, 0, heatmapCanvas.width, heatmapCanvas.height);
                
                // Get shot data from backend
                const user = window.firebaseAuth?.currentUser;
                if (!user) return;
                
                // Get date range from scores
                if (scores.length === 0) {
                    ctx.fillStyle = '#999';
                    ctx.font = '16px "Courier Prime", monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText('No shot data available', heatmapCanvas.width / 2, heatmapCanvas.height / 2);
                    return;
                }
                
                // Filter scores based on interval
                // IMPORTANT: scores array is already sorted by date (newest first) from getTrainingScores
                let filteredScores = [];
                if (interval === 'session') {
                    // Previous session only (most recent) - prioritize shot tracker sessions
                    if (scores.length > 0) {
                        // Find the most recent shot tracker session, or fall back to most recent any session
                        const shotTrackerSession = scores.find(s => s.sessionType === 'shot_tracker');
                        filteredScores = shotTrackerSession ? [shotTrackerSession] : [scores[0]]; // scores[0] is newest
                    }
                } else if (interval === 'all') {
                    // All time
                    filteredScores = scores;
                } else if (typeof interval === 'number') {
                    // Number of sessions (most recent N sessions)
                    filteredScores = scores.slice(0, interval); // Already sorted newest first
                } else {
                    filteredScores = scores;
                }
                
                console.log('Filtered scores for heatmap:', filteredScores.length, 'sessions, interval:', interval, 'first session type:', filteredScores[0]?.sessionType);
                
                if (filteredScores.length === 0) {
                    ctx.fillStyle = '#999';
                    ctx.font = '16px "Courier Prime", monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText('No data for selected interval', heatmapCanvas.width / 2, heatmapCanvas.height / 2);
                    return;
                }
                
                const firstDate = filteredScores[0].createdAt?.toDate ? filteredScores[0].createdAt.toDate() : new Date();
                const lastDate = filteredScores[filteredScores.length - 1].createdAt?.toDate ? filteredScores[filteredScores.length - 1].createdAt.toDate() : new Date();
                
                // Fetch shot locations from backend AND from Firebase training database
                const [backendResponse, firebaseShots] = await Promise.all([
                    fetch('/api/get_shot_heatmap_data', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            start_date: firstDate.toISOString().split('T')[0],
                            end_date: lastDate.toISOString().split('T')[0]
                        })
                    }),
                    // Also get shot tracker sessions from Firebase
                    (async () => {
                        try {
                            const user = window.firebaseAuth?.currentUser;
                            if (!user) return [];
                            
                            const q = query(
                                collection(window.firebaseDB, 'trainingScores'),
                                where('userId', '==', user.uid),
                                where('sessionType', '==', 'shot_tracker')
                            );
                            const querySnapshot = await getDocs(q);
                            const sessions = [];
                            querySnapshot.forEach((doc) => {
                                const data = doc.data();
                                if (data.shotLocations && Array.isArray(data.shotLocations)) {
                                    sessions.push({
                                        shotLocations: data.shotLocations,
                                        createdAt: data.createdAt
                                    });
                                }
                            });
                            return sessions;
                        } catch (error) {
                            console.error('Error fetching Firebase shot data:', error);
                            return [];
                        }
                    })()
                ]);
                
                const backendData = await backendResponse.json();
                let allShots = [];
                
                // Add backend shots
                if (backendData.success && backendData.shots && backendData.shots.length > 0) {
                    allShots = allShots.concat(backendData.shots.map(shot => ({
                        ...shot,
                        source: 'backend'
                    })));
                }
                
                // Add Firebase shots (from saved training database sessions)
                // Filter by the selected interval
                firebaseShots.forEach(session => {
                    const sessionDate = session.createdAt?.toDate ? session.createdAt.toDate() : new Date();
                    
                    // Check if this session matches the filtered scores
                    const sessionMatches = filteredScores.some(score => {
                        const scoreDate = score.createdAt?.toDate ? score.createdAt.toDate() : new Date();
                        // Match by date (same day) or by sessionType if it's a shot tracker session
                        return (score.sessionType === 'shot_tracker' && 
                                Math.abs(sessionDate.getTime() - scoreDate.getTime()) < 60000) || // Within 1 minute
                               (sessionDate.toDateString() === scoreDate.toDateString());
                    });
                    
                    if (sessionMatches && sessionDate >= firstDate && sessionDate <= lastDate) {
                        session.shotLocations.forEach(shot => {
                            allShots.push({
                                x: shot.x,
                                y: shot.y,
                                is_make: shot.is_make,
                                result: shot.is_make ? 'make' : 'miss',
                                timestamp: shot.timestamp || sessionDate.getTime() / 1000,
                                source: 'firebase'
                            });
                        });
                    }
                });
                
                console.log('Total shots after filtering:', allShots.length, 'from backend:', backendData.shots?.length || 0, 'from firebase:', firebaseShots.length);
                
                if (allShots.length === 0) {
                    ctx.fillStyle = '#999';
                    ctx.font = '16px "Courier Prime", monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText('No shot locations recorded yet', heatmapCanvas.width / 2, heatmapCanvas.height / 2);
                    return;
                }
                
                // Filter shots to match the selected interval
                const filteredShots = allShots.filter(shot => {
                    const shotDate = new Date((shot.timestamp || 0) * 1000);
                    return shotDate >= firstDate && shotDate <= lastDate;
                });
                
                if (filteredShots.length === 0) {
                    ctx.fillStyle = '#999';
                    ctx.font = '16px "Courier Prime", monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText('No shots in selected interval', heatmapCanvas.width / 2, heatmapCanvas.height / 2);
                    return;
                }
                
                // Use the same drawing function as shot tracker
                // Draw basketball court background
                drawBasketballCourtForHeatmap(ctx, heatmapCanvas.width, heatmapCanvas.height);
                
                // Calculate and display stats for this interval
                const intervalShotTrackerSessions = filteredScores.filter(s => s.sessionType === 'shot_tracker');
                const intervalMakes = intervalShotTrackerSessions.reduce((sum, s) => sum + (s.makes || 0), 0);
                const intervalAttempts = intervalShotTrackerSessions.reduce((sum, s) => sum + (s.attempts || 0), 0);
                const intervalPercentage = intervalAttempts > 0 ? Math.round((intervalMakes / intervalAttempts) * 100) : 0;
                
                // Update shot tracker stats bar (for shot tracker section)
                const trackerStatsBar = document.getElementById('shotTrackerStatsBar');
                if (trackerStatsBar && intervalShotTrackerSessions.length > 0) {
                    trackerStatsBar.style.display = 'block';
                    document.getElementById('trackerTotalMakes').textContent = intervalMakes;
                    document.getElementById('trackerTotalAttempts').textContent = intervalAttempts;
                    document.getElementById('trackerShotPercentage').textContent = intervalPercentage + '%';
                } else if (trackerStatsBar) {
                    trackerStatsBar.style.display = 'none';
                }
                
                // Update shot tracker stats bar (for training database)
                const trainingDbStatsBar = document.getElementById('trainingDbShotTrackerStats');
                if (trainingDbStatsBar && intervalShotTrackerSessions.length > 0) {
                    trainingDbStatsBar.style.display = 'block';
                    document.getElementById('trainingDbTotalMakes').textContent = intervalMakes;
                    document.getElementById('trainingDbTotalAttempts').textContent = intervalAttempts;
                    document.getElementById('trainingDbShotPercentage').textContent = intervalPercentage + '%';
                } else if (trainingDbStatsBar) {
                    trainingDbStatsBar.style.display = 'none';
                }
                
                // Draw each shot using the same mapping as shot tracker (EXACT COPY from drawHeatmap)
                const courtX = heatmapCanvas.width * 0.05;
                const courtY = heatmapCanvas.height * 0.1;
                const courtWidth = heatmapCanvas.width * 0.9;
                const courtHeight = heatmapCanvas.height * 0.85;
                
                filteredShots.forEach(shot => {
                    // EXACT COPY from shot tracker drawHeatmap function
                    // X coordinate: 0 = left edge of court, 1 = right edge of court
                    const x = courtX + (shot.x * courtWidth);
                    
                    // Y coordinate: Map to court height (0 = top/hoop, 1 = bottom/3pt)
                    const y = courtY + (shot.y * courtHeight);
                    
                    // Draw shot marker
                    if (shot.is_make || shot.result === 'make') {
                        // Green circle for makes
                        ctx.fillStyle = 'rgba(0, 255, 0, 0.8)';
                        ctx.strokeStyle = 'rgba(0, 200, 0, 1)';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(x, y, 12, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.stroke();
                    } else {
                        // Red X for misses
                        ctx.strokeStyle = 'rgba(255, 0, 0, 1)';
                        ctx.lineWidth = 3;
                        const size = 10;
                        ctx.beginPath();
                        ctx.moveTo(x - size, y - size);
                        ctx.lineTo(x + size, y + size);
                        ctx.moveTo(x + size, y - size);
                        ctx.lineTo(x - size, y + size);
                        ctx.stroke();
                    }
                });
                
                
            } catch (error) {
                console.error('Error loading heatmap:', error);
                const ctx = heatmapCanvas.getContext('2d');
                ctx.fillStyle = '#999';
                ctx.font = '14px "Courier Prime", monospace';
                ctx.textAlign = 'center';
                ctx.fillText('Error loading heatmap data', heatmapCanvas.width / 2, heatmapCanvas.height / 2);
            }
        }
        
        async function loadBadges() {
            const user = window.firebaseAuth?.currentUser;
            if (!user) {
                document.getElementById('badgesContainer').innerHTML = '<p style="text-align: center; padding: 40px;">Please sign in to view your badges.</p>';
                return;
            }
            
            // Check all badges first
            if (window.checkAllBadges) {
                await window.checkAllBadges(user.uid);
            }
            
            const badges = await window.getUserBadges(user.uid);
            const loginStreak = await window.updateLoginStreak(user.uid);
            
            // Get training data for calculations
            const scores = await window.getTrainingScores(user.uid);
            const totalSessions = scores.length;
            const scoreValues = scores.map(s => s.similarityScore);
            const maxSimilarity = scoreValues.length > 0 ? Math.max(...scoreValues) : 0;
            const avgScore = scoreValues.length > 0 ? scoreValues.reduce((a, b) => a + b, 0) / scoreValues.length : 0;
            
            // Group by player
            const playerScores = {};
            scores.forEach(score => {
                const player = score.player || 'custom';
                if (!playerScores[player]) playerScores[player] = [];
                playerScores[player].push(score);
            });
            const uniquePlayers = Object.keys(playerScores);
            const playersWithHighScores = uniquePlayers.filter(player => {
                const playerMax = Math.max(...playerScores[player].map(s => s.similarityScore));
                return playerMax >= 85;
            });
            
            // Calculate consecutive days
            const sessionDates = scores.map(s => {
                const date = s.createdAt?.toDate ? s.createdAt.toDate() : new Date();
                return date.toDateString();
            });
            const uniqueDates = [...new Set(sessionDates)];
            uniqueDates.sort((a, b) => new Date(a) - new Date(b));
            let maxConsecutive = 1;
            let consecutiveDays = 1;
            for (let i = 1; i < uniqueDates.length; i++) {
                const prevDate = new Date(uniqueDates[i - 1]);
                const currDate = new Date(uniqueDates[i]);
                const daysDiff = (currDate - prevDate) / (1000 * 60 * 60 * 24);
                if (daysDiff === 1) {
                    consecutiveDays++;
                    maxConsecutive = Math.max(maxConsecutive, consecutiveDays);
                } else {
                    consecutiveDays = 1;
                }
            }
            
            // Calculate improvements
            const recentScores = scoreValues.slice(0, 5);
            const olderScores = scoreValues.slice(5, 10);
            const recentAvg = recentScores.length > 0 ? recentScores.reduce((a, b) => a + b, 0) / recentScores.length : 0;
            const olderAvg = olderScores.length > 0 ? olderScores.reduce((a, b) => a + b, 0) / olderScores.length : 0;
            const improvement = recentAvg > 0 && olderAvg > 0 ? recentAvg - olderAvg : 0;
            
            // Player-specific stats
            const playerStats = {};
            ['curry', 'lebron', 'jordan', 'durant', 'clark'].forEach(player => {
                if (playerScores[player]) {
                    playerStats[player] = {
                        sessions: playerScores[player].length,
                        maxScore: Math.max(...playerScores[player].map(s => s.similarityScore))
                    };
                }
            });
            
            // Display all badges
            const badgeDefinitions = [
                {
                    id: 'loginStreak',
                    name: 'Consistency Champion',
                    description: 'Log in consecutive days',
                    icon: 'ðŸ”¥',
                    levels: [
                        { level: 'bronze', requirement: '5 days', current: loginStreak + ' days' },
                        { level: 'silver', requirement: '10 days', current: loginStreak + ' days' },
                        { level: 'gold', requirement: '30 days', current: loginStreak + ' days' }
                    ]
                },
                {
                    id: 'similarity',
                    name: 'Form Master',
                    description: 'Achieve high similarity scores',
                    icon: 'ðŸŽ¯',
                    levels: [
                        { level: 'bronze', requirement: '80%', current: maxSimilarity.toFixed(1) + '%' },
                        { level: 'silver', requirement: '90%', current: maxSimilarity.toFixed(1) + '%' },
                        { level: 'gold', requirement: '95%', current: maxSimilarity.toFixed(1) + '%' }
                    ]
                },
                {
                    id: 'practiceWarrior',
                    name: 'Practice Warrior',
                    description: 'Complete training sessions',
                    icon: 'ðŸ’ª',
                    levels: [
                        { level: 'bronze', requirement: '10 sessions', current: totalSessions + ' sessions' },
                        { level: 'silver', requirement: '50 sessions', current: totalSessions + ' sessions' },
                        { level: 'gold', requirement: '100 sessions', current: totalSessions + ' sessions' }
                    ]
                },
                {
                    id: 'firstSteps',
                    name: 'First Steps',
                    description: 'Complete your first analysis',
                    icon: 'ðŸ‘£',
                    levels: [
                        { level: 'bronze', requirement: '1 session', current: totalSessions + ' sessions' },
                        { level: 'silver', requirement: '5 sessions', current: totalSessions + ' sessions' },
                        { level: 'gold', requirement: '10 sessions', current: totalSessions + ' sessions' }
                    ]
                },
                {
                    id: 'halfCentury',
                    name: 'Milestone Master',
                    description: 'Reach session milestones',
                    icon: 'ðŸ†',
                    levels: [
                        { level: 'bronze', requirement: '50 sessions', current: totalSessions + ' sessions' },
                        { level: 'silver', requirement: '100 sessions', current: totalSessions + ' sessions' },
                        { level: 'gold', requirement: '300 sessions', current: totalSessions + ' sessions' }
                    ]
                },
                {
                    id: 'risingStar',
                    name: 'Rising Star',
                    description: 'Improve your scores over time',
                    icon: 'â­',
                    levels: [
                        { level: 'bronze', requirement: '10% improvement', current: improvement.toFixed(1) + '%' },
                        { level: 'silver', requirement: '20% improvement', current: improvement.toFixed(1) + '%' },
                        { level: 'gold', requirement: '30% improvement', current: improvement.toFixed(1) + '%' }
                    ]
                },
                {
                    id: 'fastTrack',
                    name: 'Fast Track',
                    description: 'Rapid improvement in sessions',
                    icon: 'âš¡',
                    levels: [
                        { level: 'bronze', requirement: '15% in 3 sessions', current: improvement.toFixed(1) + '%' },
                        { level: 'silver', requirement: '20% in 5 sessions', current: improvement.toFixed(1) + '%' },
                        { level: 'gold', requirement: '25% in 7 sessions', current: improvement.toFixed(1) + '%' }
                    ]
                },
                {
                    id: 'breakthrough',
                    name: 'Breakthrough',
                    description: 'Achieve new personal bests',
                    icon: 'ðŸ’¥',
                    levels: [
                        { level: 'bronze', requirement: '1 new PB', current: maxSimilarity.toFixed(1) + '%' },
                        { level: 'silver', requirement: '3 new PBs', current: maxSimilarity.toFixed(1) + '%' },
                        { level: 'gold', requirement: '5 new PBs', current: maxSimilarity.toFixed(1) + '%' }
                    ]
                },
                {
                    id: 'versatileShooter',
                    name: 'Versatile Shooter',
                    description: 'Master multiple players',
                    icon: 'ðŸŽ¨',
                    levels: [
                        { level: 'bronze', requirement: '3 players at 85%+', current: playersWithHighScores.length + ' players' },
                        { level: 'silver', requirement: '4 players at 85%+', current: playersWithHighScores.length + ' players' },
                        { level: 'gold', requirement: '5 players at 85%+', current: playersWithHighScores.length + ' players' }
                    ]
                },
                {
                    id: 'steadyHand',
                    name: 'Steady Hand',
                    description: 'Maintain consistent high scores',
                    icon: 'ðŸ¤²',
                    levels: [
                        { level: 'bronze', requirement: '80%+ avg (10 sessions)', current: avgScore.toFixed(1) + '% avg' },
                        { level: 'silver', requirement: '90%+ avg (20 sessions)', current: avgScore.toFixed(1) + '% avg' },
                        { level: 'gold', requirement: '95%+ avg (30 sessions)', current: avgScore.toFixed(1) + '% avg' }
                    ]
                },
                {
                    id: 'rockSolid',
                    name: 'Rock Solid',
                    description: 'Consecutive sessions at 85%+',
                    icon: 'ðŸª¨',
                    levels: [
                        { level: 'bronze', requirement: '5x 85%+', current: recentScores.length >= 5 ? recentScores.every(s => s >= 85) ? 'Achieved!' : 'In progress' : 'Need 5 sessions' },
                        { level: 'silver', requirement: '10x 85%+', current: scoreValues.length >= 10 ? scoreValues.slice(0, 10).every(s => s >= 85) ? 'Achieved!' : 'In progress' : 'Need 10 sessions' },
                        { level: 'gold', requirement: '15x 85%+', current: scoreValues.length >= 15 ? scoreValues.slice(0, 15).every(s => s >= 85) ? 'Achieved!' : 'In progress' : 'Need 15 sessions' }
                    ]
                },
                {
                    id: 'nearPerfect',
                    name: 'Near Perfect',
                    description: 'Achieve near-perfect scores',
                    icon: 'âœ¨',
                    levels: [
                        { level: 'bronze', requirement: '95%', current: maxSimilarity.toFixed(1) + '%' },
                        { level: 'silver', requirement: '98%', current: maxSimilarity.toFixed(1) + '%' },
                        { level: 'gold', requirement: '100%', current: maxSimilarity.toFixed(1) + '%' }
                    ]
                },
                {
                    id: 'perfectionist',
                    name: 'Perfectionist',
                    description: 'Achieve perfect form',
                    icon: 'ðŸ’Ž',
                    levels: [
                        { level: 'bronze', requirement: '98%', current: maxSimilarity.toFixed(1) + '%' },
                        { level: 'silver', requirement: '100%', current: maxSimilarity.toFixed(1) + '%' },
                        { level: 'gold', requirement: '100% multiple times', current: maxSimilarity.toFixed(1) + '%' }
                    ]
                },
                {
                    id: 'weekWarrior',
                    name: 'Week Warrior',
                    description: 'Practice consecutive days',
                    icon: 'ðŸ“…',
                    levels: [
                        { level: 'bronze', requirement: '7 days', current: maxConsecutive + ' days' },
                        { level: 'silver', requirement: '30 days', current: maxConsecutive + ' days' },
                        { level: 'gold', requirement: '365 days', current: maxConsecutive + ' days' }
                    ]
                },
                {
                    id: 'dailyGrinder',
                    name: 'Daily Grinder',
                    description: 'Consecutive days with sessions',
                    icon: 'ðŸŒ…',
                    levels: [
                        { level: 'bronze', requirement: '3 days', current: maxConsecutive + ' days' },
                        { level: 'silver', requirement: '7 days', current: maxConsecutive + ' days' },
                        { level: 'gold', requirement: '14 days', current: maxConsecutive + ' days' }
                    ]
                },
                {
                    id: 'explorer',
                    name: 'Explorer',
                    description: 'Try all pro players',
                    icon: 'ðŸ—ºï¸',
                    levels: [
                        { level: 'bronze', requirement: '5 players', current: uniquePlayers.length + ' players' },
                        { level: 'silver', requirement: '5 players + custom', current: uniquePlayers.length + ' players' },
                        { level: 'gold', requirement: 'All players mastered', current: playersWithHighScores.length + ' mastered' }
                    ]
                },
                {
                    id: 'adventurer',
                    name: 'Adventurer',
                    description: 'Try custom benchmarks',
                    icon: 'ðŸ§­',
                    levels: [
                        { level: 'bronze', requirement: '1 custom session', current: playerScores['custom'] ? playerScores['custom'].length + ' sessions' : 'Not yet' },
                        { level: 'silver', requirement: '5 custom sessions', current: playerScores['custom'] ? playerScores['custom'].length + ' sessions' : 'Not yet' },
                        { level: 'gold', requirement: '10 custom sessions', current: playerScores['custom'] ? playerScores['custom'].length + ' sessions' : 'Not yet' }
                    ]
                },
                {
                    id: 'completeCollection',
                    name: 'Complete Collection',
                    description: 'Master all players (85%+)',
                    icon: 'ðŸ“š',
                    levels: [
                        { level: 'bronze', requirement: 'All 5 players', current: playersWithHighScores.length + '/5 players' },
                        { level: 'silver', requirement: 'All 5 at 90%+', current: uniquePlayers.filter(p => {
                            const playerMax = Math.max(...playerScores[p].map(s => s.similarityScore));
                            return playerMax >= 90;
                        }).length + '/5 players' },
                        { level: 'gold', requirement: 'All 5 at 95%+', current: uniquePlayers.filter(p => {
                            const playerMax = Math.max(...playerScores[p].map(s => s.similarityScore));
                            return playerMax >= 95;
                        }).length + '/5 players' }
                    ]
                },
                {
                    id: 'quickLearner',
                    name: 'Quick Learner',
                    description: 'Reach high scores quickly',
                    icon: 'ðŸ§ ',
                    levels: [
                        { level: 'bronze', requirement: '80%+ in 5 sessions', current: totalSessions <= 5 && maxSimilarity >= 80 ? 'Achieved!' : totalSessions > 5 ? 'Time passed' : 'In progress' },
                        { level: 'silver', requirement: '85%+ in 5 sessions', current: totalSessions <= 5 && maxSimilarity >= 85 ? 'Achieved!' : totalSessions > 5 ? 'Time passed' : 'In progress' },
                        { level: 'gold', requirement: '90%+ in 5 sessions', current: totalSessions <= 5 && maxSimilarity >= 90 ? 'Achieved!' : totalSessions > 5 ? 'Time passed' : 'In progress' }
                    ]
                },
                {
                    id: 'rapidRise',
                    name: 'Rapid Rise',
                    description: 'Dramatic improvement in 10 sessions',
                    icon: 'ðŸš€',
                    levels: [
                        { level: 'bronze', requirement: '<60% to >85%', current: scoreValues.length >= 10 ? (scoreValues.slice(-10, -5).reduce((a, b) => a + b, 0) / 5 < 60 && recentAvg >= 85 ? 'Achieved!' : 'In progress') : 'Need 10 sessions' },
                        { level: 'silver', requirement: '<60% to >90%', current: scoreValues.length >= 10 ? (scoreValues.slice(-10, -5).reduce((a, b) => a + b, 0) / 5 < 60 && recentAvg >= 90 ? 'Achieved!' : 'In progress') : 'Need 10 sessions' },
                        { level: 'gold', requirement: '<60% to >95%', current: scoreValues.length >= 10 ? (scoreValues.slice(-10, -5).reduce((a, b) => a + b, 0) / 5 < 60 && recentAvg >= 95 ? 'Achieved!' : 'In progress') : 'Need 10 sessions' }
                    ]
                }
            ];
            
            // Player icon mapping
            const playerIcons = {
                'curry': '/tool/stephrootsicon.jpeg',
                'lebron': '/tool/lebron_icon.jpeg',
                'jordan': '/tool/jordan_icon.jpeg',
                'durant': '/tool/kd_icon.webp',
                'clark': '/tool/caitlin_icon.webp'
            };
            
            // Add player-specific badges
            ['curry', 'lebron', 'jordan', 'durant', 'clark'].forEach(player => {
                const playerName = player.charAt(0).toUpperCase() + player.slice(1);
                const stats = playerStats[player];
                if (stats) {
                    badgeDefinitions.push({
                        id: player + 'Specialist',
                        name: playerName + ' Specialist',
                        description: `Master ${playerName}'s form`,
                        icon: 'ðŸ€',
                        playerIcon: playerIcons[player], // Store player icon path
                        levels: [
                            { level: 'bronze', requirement: '5 sessions at 85%+', current: stats.sessions + ' sessions, ' + stats.maxScore.toFixed(1) + '% max' },
                            { level: 'silver', requirement: '10 sessions at 90%+', current: stats.sessions + ' sessions, ' + stats.maxScore.toFixed(1) + '% max' },
                            { level: 'gold', requirement: '15 sessions at 95%+', current: stats.sessions + ' sessions, ' + stats.maxScore.toFixed(1) + '% max' }
                        ]
                    });
                } else {
                    badgeDefinitions.push({
                        id: player + 'Specialist',
                        name: playerName + ' Specialist',
                        description: `Master ${playerName}'s form`,
                        icon: 'ðŸ€',
                        playerIcon: playerIcons[player], // Store player icon path
                        levels: [
                            { level: 'bronze', requirement: '5 sessions at 85%+', current: 'Not started' },
                            { level: 'silver', requirement: '10 sessions at 90%+', current: 'Not started' },
                            { level: 'gold', requirement: '15 sessions at 95%+', current: 'Not started' }
                        ]
                    });
                }
            });
            
            let badgesHTML = '';
            badgeDefinitions.forEach(badge => {
                const currentLevel = badges[badge.id] || 'none';
                const isUnlocked = currentLevel !== 'none';
                
                // Use player icon for specialist badges, otherwise use emoji icon
                const iconHTML = badge.playerIcon 
                    ? `<img src="${badge.playerIcon}" alt="${badge.name}" style="width: 64px; height: 64px; border-radius: 50%; object-fit: cover; margin: 0 auto;">`
                    : `<div class="badge-icon">${badge.icon}</div>`;
                
                badgesHTML += `
                    <div class="badge-card ${!isUnlocked ? 'locked' : ''}">
                        ${iconHTML}
                        <div class="badge-name">${badge.name}</div>
                        <div style="color: #666; margin-bottom: 15px; font-size: 14px;">${badge.description}</div>
                        ${badge.levels.map(levelInfo => {
                            const isAchieved = currentLevel === levelInfo.level || 
                                (levelInfo.level === 'bronze' && currentLevel !== 'none') ||
                                (levelInfo.level === 'silver' && (currentLevel === 'silver' || currentLevel === 'gold')) ||
                                (levelInfo.level === 'gold' && currentLevel === 'gold');
                            
                            return `
                                <div style="margin: 10px 0; padding: 10px; background: ${isAchieved ? '#f0f9ff' : '#f5f5f5'}; border-radius: 8px;">
                                    <div style="display: flex; justify-content: space-between; align-items: center;">
                                        <span style="font-weight: 600;">${levelInfo.level.charAt(0).toUpperCase() + levelInfo.level.slice(1)}</span>
                                        <span class="badge-level ${isAchieved ? levelInfo.level : 'none'}">
                                            ${isAchieved ? 'âœ“' : 'â—‹'} ${levelInfo.requirement}
                                        </span>
                                    </div>
                                    <div style="font-size: 12px; color: #666; margin-top: 5px;">
                                        Current: ${levelInfo.current}
                                    </div>
                                </div>
                            `;
                        }).join('')}
                    </div>
                `;
            });
            
            document.getElementById('badgesContainer').innerHTML = badgesHTML;
        }
        
        // Add event listener for player filter
        // Restore active tab from localStorage on page load
        function restoreActiveTab() {
            // Only restore tab if we're on the tool page (not the landing page)
            const pathname = window.location.pathname;
            if (!pathname.includes('/tool/') && !pathname.endsWith('/tool/index.html')) {
                return; // Don't restore tab if we're not on the tool page
            }
            
            const activeTab = localStorage.getItem('activeTab');
            // Removed shotTracker tab - functionality moved to Shot Sync tab
            if (activeTab) {
                switch(activeTab) {
                    case 'shotSync':
                        showShotSync();
                        break;
                    case 'trainingDatabase':
                        showTrainingDatabase();
                        break;
                    case 'progressPics':
                        showProgressPics();
                        break;
                    case 'badges':
                        showBadges();
                        break;
                    case 'nutrition':
                        showNutrition();
                        break;
                    case 'workouts':
                        showWorkouts();
                        break;
                    default:
                        showShotSync();
                }
            } else {
                // Default to shot sync if no saved tab
                showShotSync();
            }
            
            // Re-attach sign-in button handlers after tab restoration
            // This ensures handlers work even if buttons were hidden/shown during tab switch
            setTimeout(() => {
                // Check if handlers are available (from app.js)
                if (typeof handleGoogleSignIn !== 'undefined' && window.signInWithGoogle) {
                    const googleSignInBtn = document.getElementById('googleSignInBtn');
                    if (googleSignInBtn) {
                        // Clone to remove old listeners and re-add
                        const newBtn = googleSignInBtn.cloneNode(true);
                        googleSignInBtn.parentNode.replaceChild(newBtn, googleSignInBtn);
                        newBtn.addEventListener('click', handleGoogleSignIn);
                    }
                }
                
                if (typeof handlePlayerPageSignIn !== 'undefined' && window.signInWithGoogle) {
                    const playerGoogleSignInBtn = document.getElementById('playerGoogleSignInBtn');
                    if (playerGoogleSignInBtn) {
                        // Clone to remove old listeners and re-add
                        const newBtn = playerGoogleSignInBtn.cloneNode(true);
                        playerGoogleSignInBtn.parentNode.replaceChild(newBtn, playerGoogleSignInBtn);
                        newBtn.addEventListener('click', handlePlayerPageSignIn);
                    }
                }
            }, 500);
        }
        
        document.addEventListener('DOMContentLoaded', () => {
            const playerFilter = document.getElementById('playerFilter');
            if (playerFilter) {
                playerFilter.addEventListener('change', loadTrainingDatabase);
            }
            
            // Add click handler for Home button
            const homeButton = document.getElementById('backToHomeTab');
            if (homeButton) {
                homeButton.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    goToHome();
                });
            }
            
            // Restore active tab after a delay to ensure all scripts (including app.js) are loaded
            // Wait for app.js to attach handlers first, then restore tab
            setTimeout(() => {
                restoreActiveTab();
            }, 300);
        });
        
        function goToHome() {
            console.log('goToHome called');
            // Clear the activeTab from localStorage so it doesn't restore a tab when returning
            localStorage.removeItem('activeTab');
            
            // Navigate to the root index.html (landing page) - go up one directory from /tool/
            // Use replace instead of href to prevent back button from going back to tool page
            const baseUrl = window.location.origin;
            const pathParts = window.location.pathname.split('/').filter(p => p); // Remove empty strings
            const toolIndex = pathParts.indexOf('tool');
            console.log('pathParts:', pathParts, 'toolIndex:', toolIndex);
            
            if (toolIndex > 0) {
                const basePath = '/' + pathParts.slice(0, toolIndex).join('/');
                const targetUrl = baseUrl + basePath + '/index.html';
                console.log('Navigating to:', targetUrl);
                window.location.replace(targetUrl);
            } else {
                console.log('Using relative path: ../index.html');
                window.location.replace('../index.html');
            }
        }
        
        function showWorkouts() {
            // Hide all views
            document.querySelectorAll('.tab-view').forEach(view => view.style.display = 'none');
            const mainContent = document.querySelector('.main-content');
            if (mainContent) mainContent.style.display = 'none';
            
            // Hide ShotSync header/tagline on workouts page (but keep logo)
            const header = document.querySelector('header');
            if (header) header.style.display = 'none';
            
            // Show workouts
            document.getElementById('workoutsView').style.display = 'block';
            
            // Update nav tabs
            document.querySelectorAll('.nav-tab').forEach(tab => tab.classList.remove('active'));
            document.getElementById('workoutsTab').classList.add('active');
            
            // Save active tab to localStorage
            localStorage.setItem('activeTab', 'workouts');
            
            // Load workouts data
            loadWorkouts();
        }
        
        function showNutrition() {
            // Hide all views
            document.querySelectorAll('.tab-view').forEach(view => view.style.display = 'none');
            const mainContent = document.querySelector('.main-content');
            if (mainContent) mainContent.style.display = 'none';
            
            // Hide ShotSync header/tagline on nutrition page (but keep logo)
            const header = document.querySelector('header');
            if (header) header.style.display = 'none';
            
            // Show nutrition
            document.getElementById('nutritionView').style.display = 'block';
            
            // Update nav tabs
            document.querySelectorAll('.nav-tab').forEach(tab => tab.classList.remove('active'));
            document.getElementById('nutritionTab').classList.add('active');
            
            // Save active tab to localStorage
            localStorage.setItem('activeTab', 'nutrition');
            
            // Load nutrition data
            loadNutrition();
            
            // Make sure Custom Diet Plans tab shows correctly if it was previously selected
            const customDietPlansSection = document.getElementById('customDietPlansSection');
            if (customDietPlansSection && customDietPlansSection.style.display !== 'none') {
                const user = window.firebaseAuth?.currentUser;
                if (user) {
                    loadCustomDietPlans(user.uid);
                }
            }
        }
        
        // Wait for Firebase to be ready
        async function waitForFirebase(maxWait = 5000) {
            const startTime = Date.now();
            while (!window.signInWithGoogle && (Date.now() - startTime) < maxWait) {
                await new Promise(resolve => setTimeout(resolve, 100));
            }
            return !!window.signInWithGoogle;
        }
        
        // Wrapper functions for sign-in buttons (call handlers from app.js)
        async function handleGoogleSignInClick() {
            // Wait for Firebase to be ready
            const firebaseReady = await waitForFirebase();
            if (!firebaseReady) {
                alert('Sign-in is not ready yet. Please wait a moment and try again, or refresh the page.');
                return;
            }
            
            if (typeof handleGoogleSignIn !== 'undefined') {
                try {
                    await handleGoogleSignIn();
                } catch (error) {
                    console.error('Sign-in error:', error);
                    // The handler should show its own error, but if it doesn't, show a generic one
                }
            } else {
                // Fallback: try to sign in directly and update UI
                if (window.signInWithGoogle) {
                    try {
                        console.log('Attempting Google sign-in...');
                        const userData = await window.signInWithGoogle();
                        console.log('Sign-in successful, user data:', userData);
                        
                        // Wait a moment for auth state to update
                        await new Promise(resolve => setTimeout(resolve, 300));
                        
                        // Check if user is actually signed in
                        const currentUser = window.firebaseAuth?.currentUser;
                        console.log('Current user after sign-in:', currentUser);
                        
                        if (currentUser) {
                            console.log('User is signed in, updating UI...');
                            
                            // Update UI directly instead of reloading
                            const signInSection = document.getElementById('signInSection');
                            if (signInSection) {
                                signInSection.style.display = 'none';
                            }
                            
                            const playerSelectionContainer = document.getElementById('playerSelectionContainer');
                            if (playerSelectionContainer) {
                                playerSelectionContainer.style.opacity = '1';
                                playerSelectionContainer.style.pointerEvents = 'auto';
                            }
                            
                            // Move to record shot step (skip player selection)
                            const step0 = document.getElementById('step0');
                            const step2 = document.getElementById('step2');
                            if (step0) {
                                step0.classList.remove('active');
                                step0.style.display = 'none';
                            }
                            if (step2) {
                                step2.classList.add('active');
                                step2.style.display = 'block';
                            }
                            
                            // Save user email
                            if (window.saveUserEmail) {
                                await window.saveUserEmail(userData.email, userData.firstName, userData.lastName);
                            }
                            
                            console.log('UI updated successfully');
                        } else {
                            console.error('User is not signed in after sign-in attempt');
                            alert('Sign-in completed but authentication state was not updated. Please refresh the page manually.');
                        }
                    } catch (error) {
                        console.error('Error signing in:', error);
                        let errorMessage = 'Failed to sign in with Google. ';
                        if (error.code === 'auth/popup-closed-by-user') {
                            errorMessage = 'Sign-in was cancelled. Please try again.';
                        } else if (error.code) {
                            errorMessage += `Error code: ${error.code}. `;
                        }
                        if (error.message) {
                            errorMessage += error.message;
                        } else {
                            errorMessage += 'Please check the browser console for details.';
                        }
                        alert(errorMessage);
                    }
                } else {
                    alert('Sign-in functionality is not available. Please refresh the page.');
                }
            }
        }
        
        async function handlePlayerPageSignInClick() {
            // Wait for Firebase to be ready
            const firebaseReady = await waitForFirebase();
            if (!firebaseReady) {
                alert('Sign-in is not ready yet. Please wait a moment and try again, or refresh the page.');
                return;
            }
            
            if (typeof handlePlayerPageSignIn !== 'undefined') {
                try {
                    await handlePlayerPageSignIn();
                } catch (error) {
                    console.error('Sign-in error:', error);
                    // The handler should show its own error, but if it doesn't, show a generic one
                }
            } else {
                // Fallback: try to sign in directly and update UI
                if (window.signInWithGoogle) {
                    try {
                        console.log('Attempting Google sign-in (player page)...');
                        const userData = await window.signInWithGoogle();
                        console.log('Sign-in successful, user data:', userData);
                        
                        // Wait a moment for auth state to update
                        await new Promise(resolve => setTimeout(resolve, 300));
                        
                        // Check if user is actually signed in
                        const currentUser = window.firebaseAuth?.currentUser;
                        console.log('Current user after sign-in:', currentUser);
                        
                        if (currentUser) {
                            console.log('User is signed in, updating UI...');
                            
                            // Update UI directly instead of reloading
                            const playerSelectionContainer = document.getElementById('playerSelectionContainer');
                            if (playerSelectionContainer) {
                                playerSelectionContainer.style.opacity = '1';
                                playerSelectionContainer.style.pointerEvents = 'auto';
                            }
                            
                            const playerSignInSection = document.getElementById('playerSignInSection');
                            if (playerSignInSection) {
                                playerSignInSection.style.display = 'none';
                            }
                            
                            // Save user email
                            if (window.saveUserEmail) {
                                await window.saveUserEmail(userData.email, userData.firstName, userData.lastName);
                            }
                            
                            console.log('UI updated successfully');
                        } else {
                            console.error('User is not signed in after sign-in attempt');
                            alert('Sign-in completed but authentication state was not updated. Please refresh the page manually.');
                        }
                    } catch (error) {
                        console.error('Error signing in:', error);
                        let errorMessage = 'Failed to sign in with Google. ';
                        if (error.code === 'auth/popup-closed-by-user') {
                            errorMessage = 'Sign-in was cancelled. Please try again.';
                        } else if (error.code) {
                            errorMessage += `Error code: ${error.code}. `;
                        }
                        if (error.message) {
                            errorMessage += error.message;
                        } else {
                            errorMessage += 'Please check the browser console for details.';
                        }
                        alert(errorMessage);
                    }
                } else {
                    alert('Sign-in functionality is not available. Please refresh the page.');
                }
            }
        }
        
        // Make functions globally available
        window.showShotSync = showShotSync;
        window.showTrainingDatabase = showTrainingDatabase;
        window.showProgressPics = showProgressPics;
        window.showBadges = showBadges;
        window.showNutrition = showNutrition;
        
        // ====================== SHOT TRACKER FUNCTIONALITY ======================
        
        let shotTrackerStream = null;
        let shotTrackerCamera = null;
        let shotTrackerActive = false;
        let shotTrackerStats = {
            total: 0,
            makes: 0,
            misses: 0
        };
        let shotHistory = [];
        let shotTrackerRenderLoopId = null;
        let shotTrackerMode = 'live'; // 'live' or 'upload'
        let uploadedVideoFile = null;
        let videoAnalysisActive = false;
        let videoAnalysisPaused = false;
        
        // Client-side detection state
        let clientSideTrackerState = {
            ballPositions: [],
            rimPosition: null,
            rimRadius: null,
            lastShotTime: 0,
            useBackend: false // Will be set based on backend availability
        };
        
        function showShotTracker() {
            // Hide all tab views
            document.querySelectorAll('.tab-view').forEach(view => view.style.display = 'none');
            
            // Hide all steps
            document.querySelectorAll('.step').forEach(step => step.style.display = 'none');
            
            // Show shot tracker section
            const shotTrackerSection = document.getElementById('shotTrackerSection');
            if (shotTrackerSection) {
                shotTrackerSection.style.display = 'block';
            }
            
            // Ensure main content is visible
            const mainContent = document.querySelector('.main-content');
            if (mainContent) mainContent.style.display = 'block';
            
            // Setup event listeners for shot tracker (in case they weren't set up yet)
            setupShotTrackerEventListeners();
            
            // Start polling stats (EXACT COPY from original)
            startStatsPolling();
        }
        
        function setupShotTrackerEventListeners() {
            // EXACT COPY from original shot_detector_web_simple.py HTML template
            const fileInput = document.getElementById('shotTrackerFileInput');
            const uploadForm = document.getElementById('shotTrackerUploadForm');
            
            // File input handler - show filename
            if (fileInput) {
                fileInput.addEventListener('change', function(e) {
                    const fileName = e.target.files[0] ? e.target.files[0].name : '';
                    document.getElementById('uploadedFileName').textContent = fileName ? 'Selected: ' + fileName : '';
                });
            }
            
            // Upload form handler - EXACT COPY from original
            if (uploadForm) {
                uploadForm.addEventListener('submit', function(e) {
                    e.preventDefault();
                    const formData = new FormData();
                    const fileInput = document.getElementById('shotTrackerFileInput');
                    
                    if (!fileInput.files[0]) {
                        showMessage('Please select a video file', 'error');
                        return;
                    }
                    
                    formData.append('video', fileInput.files[0]);
                    const uploadBtn = document.getElementById('uploadBtn');
                    uploadBtn.disabled = true;
                    uploadBtn.textContent = 'Uploading...';
                    
                    fetch('/api/upload', {
                        method: 'POST',
                        body: formData
                    })
                    .then(response => response.json())
                    .then(data => {
                        if (data.success) {
                            showMessage('Video uploaded successfully! Processing...', 'success');
                            setTimeout(() => {
                                const videoStream = document.getElementById('shotTrackerVideoStream');
                                videoStream.src = '/api/video_feed?t=' + new Date().getTime();
                            }, 1000);
                        } else {
                            showMessage(data.message || 'Upload failed', 'error');
                        }
                    })
                    .catch(error => {
                        showMessage('Error uploading video: ' + error.message, 'error');
                    })
                    .finally(() => {
                        uploadBtn.disabled = false;
                        uploadBtn.textContent = 'Upload & Analyze Video';
                    });
                });
            }
            
            // Reset button
            const resetBtn = document.getElementById('resetShotTracker');
            if (resetBtn) {
                resetBtn.addEventListener('click', function() {
                    fetch('/api/reset_shot_tracker', { method: 'POST' })
                        .then(() => {
                            // Reload stats
                            fetch('/api/stats')
                                .then(response => response.json())
                                .then(data => updateStats(data));
                        });
                });
            }
            
            // Save to Training Database button
            const saveBtn = document.getElementById('saveToTrainingDbBtn');
            console.log('Setting up save button:', saveBtn);
            if (saveBtn) {
                saveBtn.addEventListener('click', async function(e) {
                    e.preventDefault();
                    console.log('Save button clicked!');
                    try {
                        await saveShotTrackerToTrainingDb();
                    } catch (error) {
                        console.error('Error in save button handler:', error);
                        showPopup('Error: ' + error.message, 'error');
                    }
                });
                console.log('Save button event listener added');
            } else {
                console.error('Save button not found!');
            }
            
            // Back button
            const backBtn = document.getElementById('backToShotSyncFromTracker');
            if (backBtn) {
                backBtn.addEventListener('click', function() {
                    // Hide shot tracker section
                    document.getElementById('shotTrackerSection').style.display = 'none';
                    // Show first step
                    document.querySelector('.step').style.display = 'block';
                });
            }
        }
        
        // Popup notification function
        function showPopup(message, type = 'success') {
            console.log('showPopup called with:', message, type);
            
            // Remove existing popup if any
            const existingPopup = document.getElementById('savePopup');
            if (existingPopup) {
                existingPopup.remove();
            }
            
            // Create popup element
            const popup = document.createElement('div');
            popup.id = 'savePopup';
            popup.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: ${type === 'success' ? 'linear-gradient(135deg, #4ade80 0%, #22c55e 100%)' : 'linear-gradient(135deg, #ef4444 0%, #dc2626 100%)'};
                color: white;
                padding: 30px 50px;
                border-radius: 15px;
                box-shadow: 0 10px 40px rgba(0,0,0,0.3);
                z-index: 10000;
                font-size: 24px;
                font-weight: 700;
                font-family: 'Bebas Neue', sans-serif;
                text-align: center;
                animation: popupFadeIn 0.3s ease-out;
            `;
            popup.textContent = message;
            
            console.log('Popup element created, appending to body');
            
            // Add animation
            const style = document.createElement('style');
            style.textContent = `
                @keyframes popupFadeIn {
                    from {
                        opacity: 0;
                        transform: translate(-50%, -50%) scale(0.8);
                    }
                    to {
                        opacity: 1;
                        transform: translate(-50%, -50%) scale(1);
                    }
                }
                @keyframes popupFadeOut {
                    from {
                        opacity: 1;
                        transform: translate(-50%, -50%) scale(1);
                    }
                    to {
                        opacity: 0;
                        transform: translate(-50%, -50%) scale(0.8);
                    }
                }
            `;
            if (!document.getElementById('popupStyles')) {
                style.id = 'popupStyles';
                document.head.appendChild(style);
            }
            
            document.body.appendChild(popup);
            console.log('Popup appended to body');
            
            // Remove after 2 seconds
            setTimeout(() => {
                if (popup && popup.parentNode) {
                    popup.style.animation = 'popupFadeOut 0.3s ease-out';
                    setTimeout(() => {
                        if (popup && popup.parentNode) {
                            popup.remove();
                        }
                    }, 300);
                }
            }, 2000);
        }
        
        async function saveShotTrackerToTrainingDb() {
            console.log('saveShotTrackerToTrainingDb called');
            
            const user = window.firebaseAuth?.currentUser;
            console.log('Current user:', user);
            if (!user) {
                console.log('No user, showing sign in message');
                showPopup('Please sign in to save', 'error');
                return;
            }
            
            const saveBtn = document.getElementById('saveToTrainingDbBtn');
            const messageDiv = document.getElementById('saveTrainingDbMessage');
            
            if (!saveBtn) {
                console.error('Save button not found in saveShotTrackerToTrainingDb!');
                showPopup('Error: Button not found', 'error');
                return;
            }
            
            // Disable button and show loading
            saveBtn.disabled = true;
            const originalText = saveBtn.textContent;
            saveBtn.textContent = 'ðŸ’¾ Saving...';
            if (messageDiv) messageDiv.style.display = 'none';
            
            try {
                console.log('Fetching stats from /api/stats');
                // Get current stats and heatmap data from backend
                const statsResponse = await fetch('/api/stats');
                console.log('Stats response:', statsResponse);
                const statsData = await statsResponse.json();
                console.log('Stats data:', statsData);
                
                if (!statsData.heatmap || statsData.heatmap.length === 0) {
                    console.log('No heatmap data found');
                    // Don't show error popup, just return silently
                    saveBtn.disabled = false;
                    saveBtn.textContent = originalText;
                    if (messageDiv) {
                        showSaveMessage('No shot data to save. Please analyze a video first.', 'error');
                    }
                    return;
                }
                
                console.log('Preparing shot data, count:', statsData.heatmap.length);
                // Prepare shot data
                const shotData = {
                    shots: statsData.heatmap.map(shot => ({
                        x: shot.x,
                        y: shot.y,
                        is_make: shot.is_make,
                        result: shot.is_make ? 'make' : 'miss',
                        timestamp: Date.now() // Use current timestamp
                    }))
                };
                
                console.log('Calling window.saveShotTrackerToTrainingDb with:', shotData);
                // Save to training database
                let result;
                try {
                    result = await window.saveShotTrackerToTrainingDb(user.uid, shotData);
                    console.log('Save result:', result);
                } catch (saveError) {
                    console.error('Error in saveShotTrackerToTrainingDb:', saveError);
                    // Re-throw to be caught by outer catch
                    throw saveError;
                }
                
                if (result && result.success) {
                    // Show popup notification
                    console.log('Showing success popup');
                    showPopup('âœ… Saved!', 'success');
                    
                    // Also update message div
                    if (messageDiv) {
                        showSaveMessage(
                            `Saved successfully! ${result.makes} makes, ${result.attempts} attempts (${result.percentage}%)`,
                            'success'
                        );
                    }
                } else {
                    console.log('Save failed, result:', result);
                    showPopup('Failed to save', 'error');
                    if (messageDiv) showSaveMessage('Failed to save to training database', 'error');
                }
            } catch (error) {
                console.error('Error saving to training database:', error);
                console.error('Error stack:', error.stack);
                // Only show error popup for unexpected errors
                const errorMessage = error.message || 'Unknown error';
                if (!errorMessage.includes('No shot data') && 
                    error.code !== 'auth/popup-closed-by-user' &&
                    !errorMessage.includes('Button not found')) {
                    showPopup('Error: ' + errorMessage, 'error');
                }
                if (messageDiv && !errorMessage.includes('No shot data')) {
                    showSaveMessage('Error saving to training database: ' + errorMessage, 'error');
                }
            } finally {
                if (saveBtn) {
                    saveBtn.disabled = false;
                    saveBtn.textContent = originalText;
                }
            }
        }
        
        // Make functions globally available (note: window.saveShotTrackerToTrainingDb is the Firebase save function at line 380)
        // This local function handles the UI logic
        window.saveShotTrackerToTrainingDbLocal = saveShotTrackerToTrainingDb;
        window.showPopup = showPopup;
        
        function showSaveMessage(text, type) {
            const messageDiv = document.getElementById('saveTrainingDbMessage');
            messageDiv.textContent = text;
            messageDiv.style.display = 'block';
            if (type === 'success') {
                messageDiv.style.background = 'rgba(0, 255, 0, 0.2)';
                messageDiv.style.color = '#00aa00';
                messageDiv.style.border = '1px solid #00aa00';
            } else if (type === 'error') {
                messageDiv.style.background = 'rgba(255, 0, 0, 0.2)';
                messageDiv.style.color = '#cc0000';
                messageDiv.style.border = '1px solid #cc0000';
            }
            setTimeout(() => {
                messageDiv.textContent = '';
                messageDiv.style.display = 'none';
            }, 5000);
        }
        
        function showMessage(text, type) {
            const messageDiv = document.getElementById('uploadMessage');
            messageDiv.textContent = text;
            messageDiv.style.display = 'block';
            if (type === 'success') {
                messageDiv.style.background = 'rgba(0, 255, 0, 0.2)';
                messageDiv.style.color = '#00ff00';
            } else if (type === 'error') {
                messageDiv.style.background = 'rgba(255, 0, 0, 0.2)';
                messageDiv.style.color = '#ff0000';
            }
            setTimeout(() => {
                messageDiv.textContent = '';
                messageDiv.style.display = 'none';
            }, 5000);
        }
        
        function updateStats(data) {
            const makes = data.makes || 0;
            const attempts = data.attempts || 0;
            const percentage = attempts > 0 ? Math.round((makes / attempts) * 100) : 0;
            
            document.getElementById('makesCount').textContent = makes;
            document.getElementById('attemptsCount').textContent = attempts;
            document.getElementById('percentage').textContent = percentage + '%';
            
            // Update last shot result
            const lastShotResult = document.getElementById('lastShotResult');
            if (data.overlay_text === 'Make') {
                lastShotResult.textContent = 'âœ… MAKE';
                lastShotResult.style.color = '#00ff00';
            } else if (data.overlay_text === 'Miss') {
                lastShotResult.textContent = 'âŒ MISS';
                lastShotResult.style.color = '#ff0000';
            } else {
                lastShotResult.textContent = '-';
                lastShotResult.style.color = 'rgba(255, 255, 255, 0.7)';
            }
            
            // Update heatmap if new shots detected
            if (data.heatmap) {
                drawHeatmap(data.heatmap);
            }
        }
        
        // Heatmap drawing - EXACT COPY from original
        let lastHeatmapLength = 0;
        const canvas = document.getElementById('shotTrackerHeatmap');
        let ctx = null;
        if (canvas) {
            ctx = canvas.getContext('2d');
        }
        
        // Drawing function for Training Database heatmap (reuses same logic)
        function drawBasketballCourtForHeatmap(ctx, width, height) {
            // Draw a grid instead of court for debugging
            ctx.fillStyle = 'rgba(240, 240, 240, 0.8)';
            ctx.fillRect(0, 0, width, height);
            
            // Draw grid lines
            ctx.strokeStyle = 'rgba(200, 200, 200, 0.6)';
            ctx.lineWidth = 1;
            
            // Vertical lines (10 columns)
            const numCols = 10;
            for (let i = 0; i <= numCols; i++) {
                const x = (width / numCols) * i;
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, height);
                ctx.stroke();
            }
            
            // Horizontal lines (10 rows)
            const numRows = 10;
            for (let i = 0; i <= numRows; i++) {
                const y = (height / numRows) * i;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                ctx.stroke();
            }
            
            // Draw coordinate labels
            ctx.fillStyle = 'rgba(100, 100, 100, 0.8)';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            // Label columns (X: 0.0 to 1.0)
            for (let i = 0; i <= numCols; i++) {
                const x = (width / numCols) * i;
                const label = (i / numCols).toFixed(1);
                ctx.fillText(label, x, 15);
            }
            
            // Label rows (Y: 0.0 to 1.0)
            ctx.textAlign = 'left';
            for (let i = 0; i <= numRows; i++) {
                const y = (height / numRows) * i;
                const label = (i / numRows).toFixed(1);
                ctx.fillText(label, 5, y);
            }
            
            // Mark center (0.5, 0.5) and hoop position
            ctx.strokeStyle = 'rgba(255, 0, 0, 0.8)';
            ctx.lineWidth = 2;
            const centerX = width * 0.5;
            const centerY = height * 0.5;
            ctx.beginPath();
            ctx.arc(centerX, centerY, 5, 0, Math.PI * 2);
            ctx.stroke();
            ctx.fillStyle = 'rgba(255, 0, 0, 0.8)';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('CENTER (0.5, 0.5)', centerX, centerY - 20);
            
            // Mark hoop position - EXACT COPY from original
            const courtY = height * 0.1;
            const courtHeight = height * 0.85;
            const hoopX = width * 0.5;
            const hoopY = courtY + courtHeight * 0.05;  // 5% down from court top (matches original)
            ctx.strokeStyle = 'rgba(0, 0, 255, 0.8)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(hoopX, hoopY, 8, 0, Math.PI * 2);
            ctx.stroke();
            ctx.fillStyle = 'rgba(0, 0, 255, 0.8)';
            ctx.fillText('HOOP (0.5, ~0.14)', hoopX, hoopY - 25);
        }
        
        function drawBasketballCourt(ctx, width, height) {
            // Draw a grid instead of court for debugging
            ctx.fillStyle = 'rgba(240, 240, 240, 0.8)';
            ctx.fillRect(0, 0, width, height);
            
            // Draw grid lines
            ctx.strokeStyle = 'rgba(200, 200, 200, 0.6)';
            ctx.lineWidth = 1;
            
            // Vertical lines (10 columns)
            const numCols = 10;
            for (let i = 0; i <= numCols; i++) {
                const x = (width / numCols) * i;
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, height);
                ctx.stroke();
            }
            
            // Horizontal lines (10 rows)
            const numRows = 10;
            for (let i = 0; i <= numRows; i++) {
                const y = (height / numRows) * i;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                ctx.stroke();
            }
            
            // Draw coordinate labels
            ctx.fillStyle = 'rgba(100, 100, 100, 0.8)';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            // Label columns (X: 0.0 to 1.0)
            for (let i = 0; i <= numCols; i++) {
                const x = (width / numCols) * i;
                const label = (i / numCols).toFixed(1);
                ctx.fillText(label, x, 15);
            }
            
            // Label rows (Y: 0.0 to 1.0)
            ctx.textAlign = 'left';
            for (let i = 0; i <= numRows; i++) {
                const y = (height / numRows) * i;
                const label = (i / numRows).toFixed(1);
                ctx.fillText(label, 5, y);
            }
            
            // Mark center (0.5, 0.5) and hoop position
            ctx.strokeStyle = 'rgba(255, 0, 0, 0.8)';
            ctx.lineWidth = 2;
            const centerX = width * 0.5;
            const centerY = height * 0.5;
            ctx.beginPath();
            ctx.arc(centerX, centerY, 5, 0, Math.PI * 2);
            ctx.stroke();
            ctx.fillStyle = 'rgba(255, 0, 0, 0.8)';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('CENTER (0.5, 0.5)', centerX, centerY - 20);
            
            // Mark hoop position - EXACT COPY from original
            // Court area: courtY = height * 0.1, courtHeight = height * 0.85
            // Hoop is at: courtY + courtHeight * 0.05 = height * 0.1 + height * 0.85 * 0.05 = height * 0.1425
            const courtY = height * 0.1;
            const courtHeight = height * 0.85;
            const hoopX = width * 0.5;
            const hoopY = courtY + courtHeight * 0.05;  // 5% down from court top (matches original)
            ctx.strokeStyle = 'rgba(0, 0, 255, 0.8)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(hoopX, hoopY, 8, 0, Math.PI * 2);
            ctx.stroke();
            ctx.fillStyle = 'rgba(0, 0, 255, 0.8)';
            ctx.fillText('HOOP (0.5, ~0.14)', hoopX, hoopY - 25);
        }
        
        function drawHeatmap(heatmapData) {
            if (!ctx || !canvas) return;
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw basketball court (image or drawn)
            drawBasketballCourt(ctx, canvas.width, canvas.height);
            
            // Court area mapping - EXACT COPY from original shot_detector_web_simple.py (line 1667-1674)
            const courtX = canvas.width * 0.05;  // Left edge of court
            const courtY = canvas.height * 0.1;  // Top edge of court
            const courtWidth = canvas.width * 0.9;  // Court width
            const courtHeight = canvas.height * 0.85;  // Court height
            
            // Hoop position (matches drawBasketballCourt function - EXACT COPY from original line 1673-1674)
            const hoopX = courtX + courtWidth / 2;  // Hoop X (center of court)
            const hoopY = courtY + courtHeight * 0.05;  // Hoop Y (5% down from court top)
            
            heatmapData.forEach((shot, index) => {
                // EXACT COPY from original (line 1681-1689)
                // X coordinate: 0 = left edge of court, 1 = right edge of court
                // shot.x = 0.5 should be at hoop center (which is at court center)
                const x = courtX + (shot.x * courtWidth);
                
                // Y coordinate: Map to court height
                // The court drawing shows hoop at top (y = courtY + 5% of courtHeight)
                // shot.y values from backend: smaller = closer to hoop, larger = farther
                // Map directly: 0 = top of court (hoop area), 1 = bottom of court (3pt line)
                const y = courtY + (shot.y * courtHeight);
                
                if (shot.is_make) {
                    // Green circle for makes
                    ctx.fillStyle = 'rgba(0, 255, 0, 0.8)';
                    ctx.strokeStyle = 'rgba(0, 200, 0, 1)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(x, y, 12, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                } else {
                    // Red X for misses
                    ctx.strokeStyle = 'rgba(255, 0, 0, 1)';
                    ctx.lineWidth = 3;
                    const size = 10;
                    ctx.beginPath();
                    ctx.moveTo(x - size, y - size);
                    ctx.lineTo(x + size, y + size);
                    ctx.moveTo(x + size, y - size);
                    ctx.lineTo(x - size, y + size);
                    ctx.stroke();
                }
            });
        }
        
        // Poll stats every 500ms - EXACT COPY from original
        let statsInterval = null;
        function startStatsPolling() {
            if (statsInterval) return; // Already polling
            
            statsInterval = setInterval(function() {
                fetch('/api/stats')
                    .then(response => response.json())
                    .then(data => {
                        updateStats(data);
                        
                        // Update heatmap if new shots detected
                        if (data.heatmap) {
                            if (data.heatmap.length !== lastHeatmapLength || (lastHeatmapLength === 0 && data.heatmap.length > 0)) {
                                drawHeatmap(data.heatmap);
                                lastHeatmapLength = data.heatmap.length;
                            }
                        }
                    })
                    .catch(error => console.error('Error fetching stats:', error));
            }, 500);
        }
        
        function stopStatsPolling() {
            if (statsInterval) {
                clearInterval(statsInterval);
                statsInterval = null;
            }
        }
        
        // Old functions removed - now using AI-Basketball-Shot-Detection-Tracker exclusively
        // Stats are updated via polling /api/stats endpoint
        
        // Placeholder to prevent errors if any old code references these
        function resetShotTracker() {
            fetch('/api/reset_shot_tracker', { method: 'POST' })
                .then(() => {
                    fetch('/api/stats')
                        .then(response => response.json())
                        .then(data => updateStats(data));
                });
        }
        
        // Old processShotTrackerFrame removed - now using video stream from /api/video_feed
        // This function is no longer needed
        async function processShotTrackerFrame() {
            if (!shotTrackerActive) return;
            
            const video = document.getElementById('shotTrackerVideo');
            const canvas = document.getElementById('shotTrackerCanvas');
            const outputCanvas = document.getElementById('shotTrackerOutput');
            
            if (video.readyState === video.HAVE_ENOUGH_DATA) {
                const ctx = canvas.getContext('2d');
                const outputCtx = outputCanvas.getContext('2d');
                
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                outputCanvas.width = video.videoWidth;
                outputCanvas.height = video.videoHeight;
                
                ctx.drawImage(video, 0, 0);
                
                // Try backend first (YOLOv8), fallback to client-side detection
                let result = null;
                
                // Try backend first if available (uses AI-Basketball-Shot-Detection-Tracker YOLOv8)
                if (API_BASE_URL) {
                    try {
                        const response = await fetch(`${API_BASE_URL}/api/detect_shot`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ frame: canvas.toDataURL('image/jpeg', 0.7) })
                        });
                        
                        if (response.ok) {
                            const backendResult = await response.json();
                            if (backendResult.success) {
                                // Use backend result (AI-Basketball-Shot-Detection-Tracker YOLOv8 detection)
                                console.log('âœ“ Using YOLOv8 backend detection:', backendResult.tracker || 'AI-Basketball-Shot-Detection-Tracker (YOLOv8)');
                                result = {
                                    algorithm: 'yolo8',
                                    tracker: backendResult.tracker || 'AI-Basketball-Shot-Detection-Tracker (YOLOv8)',
                                    ball_detected: backendResult.ball_detected,
                                    ball_x: backendResult.ball_x,
                                    ball_y: backendResult.ball_y,
                                    ball_radius: backendResult.ball_radius,
                                    ball_box: backendResult.ball_box,  // Bounding box from YOLOv8
                                    rim_detected: backendResult.rim_detected,
                                    rim_x: backendResult.rim_x,
                                    rim_y: backendResult.rim_y,
                                    rim_radius: backendResult.rim_radius,
                                    rim_box: backendResult.rim_box,  // Bounding box from YOLOv8
                                    shot_result: backendResult.shot_result,
                                    makes: backendResult.makes || 0,
                                    attempts: backendResult.attempts || 0,
                                    confidence: (backendResult.ball_detected ? 0.9 : 0) + (backendResult.rim_detected ? 0.1 : 0),
                                    processed_frame: backendResult.processed_frame  // Frame with yellow lines, corner rectangles, shot counter
                                };
                                
                                // Update stats from backend (YOLOv8 tracker counts)
                                if (backendResult.makes !== undefined && backendResult.attempts !== undefined) {
                                    shotTrackerStats.makes = backendResult.makes;
                                    shotTrackerStats.total = backendResult.attempts;
                                    shotTrackerStats.misses = backendResult.attempts - backendResult.makes;
                                    updateShotTrackerDisplay();
                                }
                                
                                clientSideTrackerState.useBackend = true;
                            }
                        }
                    } catch (error) {
                        // Backend not available - log error and disable backend
                        console.error('Backend detection error:', error);
                        clientSideTrackerState.useBackend = false;
                    }
                }
                
                // Only use client-side if backend is completely unavailable
                // Do NOT fallback if backend exists but just didn't detect anything this frame
                if (!result && !API_BASE_URL) {
                    console.warn('âš ï¸ Using client-side detection (backend not configured)');
                    result = detectBallAndRimClientSide(ctx, canvas.width, canvas.height);
                    if (result) {
                        result.tracker = 'Client-side (fallback)';
                    }
                } else if (!result && API_BASE_URL) {
                    // Backend is available but didn't detect anything - that's OK, don't fallback
                    console.log('Backend active but no detection this frame (normal)');
                }
                
                // Store result for algorithm indicator
                if (result) {
                    latestDetectionResult = result;
                    updateAlgorithmIndicator();
                }
                
                if (result) {
                    // Draw detection results on output canvas
                    outputCtx.clearRect(0, 0, outputCanvas.width, outputCanvas.height);
                    
                    // Draw ball bounding box if available (YOLOv8)
                    if (result.ball_box && result.ball_box.length === 4) {
                        const [x1, y1, x2, y2] = result.ball_box;
                        outputCtx.strokeStyle = '#00ff00';
                        outputCtx.lineWidth = 3;
                        outputCtx.strokeRect(x1, y1, x2 - x1, y2 - y1);
                        
                        // Draw label
                        outputCtx.fillStyle = '#00ff00';
                        outputCtx.font = '14px Arial';
                        outputCtx.fillText('Basketball', x1, y1 - 5);
                    } else if (result.ball_detected && result.ball_x > 0 && result.ball_y > 0) {
                        // Fallback to circle if no bounding box
                        outputCtx.strokeStyle = '#00ff00';
                        outputCtx.lineWidth = 3;
                        outputCtx.beginPath();
                        outputCtx.arc(result.ball_x, result.ball_y, Math.max(result.ball_radius, 10), 0, 2 * Math.PI);
                        outputCtx.stroke();
                        
                        // Draw ball center
                        outputCtx.fillStyle = '#00ff00';
                        outputCtx.beginPath();
                        outputCtx.arc(result.ball_x, result.ball_y, 5, 0, 2 * Math.PI);
                        outputCtx.fill();
                    }
                    
                    // Draw rim bounding box if available (YOLOv8)
                    if (result.rim_box && result.rim_box.length === 4) {
                        const [x1, y1, x2, y2] = result.rim_box;
                        outputCtx.strokeStyle = '#ff0000';
                        outputCtx.lineWidth = 3;
                        outputCtx.strokeRect(x1, y1, x2 - x1, y2 - y1);
                        
                        // Draw label
                        outputCtx.fillStyle = '#ff0000';
                        outputCtx.font = '14px Arial';
                        outputCtx.fillText('Basketball Hoop', x1, y1 - 5);
                    } else if ((result.rim_detected || result.rim_x > 0) && result.rim_y > 0) {
                        // Fallback to circle if no bounding box
                        outputCtx.strokeStyle = '#ff0000';
                        outputCtx.lineWidth = 3;
                        outputCtx.beginPath();
                        outputCtx.arc(result.rim_x, result.rim_y, Math.max(result.rim_radius, 20), 0, 2 * Math.PI);
                        outputCtx.stroke();
                    }
                    
                    // Handle shot result
                    if (result.shot_result) {
                        handleShotResult(result.shot_result);
                    }
                }
            }
            
            if (shotTrackerActive) {
                shotTrackerRenderLoopId = requestAnimationFrame(processShotTrackerFrame);
            }
        }
        
        // ====================== MULTIPLE DETECTION ALGORITHMS ======================
        // Track results from all algorithms
        let algorithmResults = {
            colorBased: null,
            motionBased: null,
            contourBased: null,
            trajectoryBased: null,
            hsvBased: null,
            edgeBased: null,
            roiBased: null
        };
        
        // Algorithm 1: Color-based detection (fallback)
        function detectBallAndRimColorBased(ctx, width, height) {
            const imageData = ctx.getImageData(0, 0, width, height);
            const data = imageData.data;
            
            let ballDetected = false;
            let ballX = 0, ballY = 0, ballRadius = 0;
            let rimDetected = false;
            let rimX = 0, rimY = 0, rimRadius = 0;
            
            // Sample every 4th pixel for performance
            const step = 4;
            const ballCandidates = [];
            const rimCandidates = [];
            
            for (let y = 0; y < height; y += step) {
                for (let x = 0; x < width; x += step) {
                    const idx = (y * width + x) * 4;
                    const r = data[idx];
                    const g = data[idx + 1];
                    const b = data[idx + 2];
                    
                    // Detect orange/red basketball (typical colors) - more lenient thresholds
                    // Orange: high red, medium green, low blue
                    // Red: very high red, low green, low blue
                    // Also detect brown/tan basketballs
                    const isOrangeRed = (r > 120 && r > g * 1.1 && b < g * 0.9) || 
                                       (r > 180 && g < 120 && b < 120) ||
                                       (r > 100 && g > 80 && b < 60 && r > b * 1.5); // Brown/tan ball
                    
                    if (isOrangeRed) {
                        ballCandidates.push({x, y, r, g, b});
                    }
                    
                    // Detect white/bright rim (high brightness, low saturation)
                    const brightness = (r + g + b) / 3;
                    const maxColor = Math.max(r, g, b);
                    const minColor = Math.min(r, g, b);
                    const saturation = maxColor > 0 ? (maxColor - minColor) / maxColor : 0;
                    
                    // Detect rim: white, metallic, or bright colors (more lenient)
                    if (brightness > 180 && saturation < 0.4) {
                        rimCandidates.push({x, y, brightness});
                    }
                }
            }
            
            // Find ball: cluster orange/red pixels (lower threshold for better detection)
            if (ballCandidates.length > 20) {
                // Simple clustering: find center of mass
                let sumX = 0, sumY = 0, count = 0;
                let minX = width, maxX = 0, minY = height, maxY = 0;
                
                ballCandidates.forEach(p => {
                    sumX += p.x;
                    sumY += p.y;
                    count++;
                    minX = Math.min(minX, p.x);
                    maxX = Math.max(maxX, p.x);
                    minY = Math.min(minY, p.y);
                    maxY = Math.max(maxY, p.y);
                });
                
                if (count > 0) {
                    ballX = Math.round(sumX / count);
                    ballY = Math.round(sumY / count);
                    ballRadius = Math.max((maxX - minX) / 2, (maxY - minY) / 2);
                    
                    // Only consider if it's roughly circular and reasonable size (more lenient)
                    const aspectRatio = (maxX - minX) / (Math.max(maxY - minY, 1));
                    if (ballRadius > 3 && ballRadius < 150 && aspectRatio > 0.3 && aspectRatio < 3) {
                        ballDetected = true;
                        
                        // Track ball position
                        const currentTime = Date.now();
                        clientSideTrackerState.ballPositions.push({
                            pos: [ballX, ballY],
                            time: currentTime
                        });
                        
                        // Keep only recent positions (last 2 seconds)
                        clientSideTrackerState.ballPositions = clientSideTrackerState.ballPositions.filter(
                            p => currentTime - p.time < 2000
                        );
                    }
                }
            }
            
            // Find rim: cluster bright pixels in upper portion of frame (lower threshold)
            if (rimCandidates.length > 50) {
                // Look for rim in upper 70% of frame
                const upperRimCandidates = rimCandidates.filter(p => p.y < height * 0.7);
                
                if (upperRimCandidates.length > 20) {
                    let sumX = 0, sumY = 0, count = 0;
                    let minX = width, maxX = 0, minY = height, maxY = 0;
                    
                    upperRimCandidates.forEach(p => {
                        sumX += p.x;
                        sumY += p.y;
                        count++;
                        minX = Math.min(minX, p.x);
                        maxX = Math.max(maxX, p.x);
                        minY = Math.min(minY, p.y);
                        maxY = Math.max(maxY, p.y);
                    });
                    
                    if (count > 0) {
                        rimX = Math.round(sumX / count);
                        rimY = Math.round(sumY / count);
                        rimRadius = Math.max((maxX - minX) / 2, (maxY - minY) / 2);
                        
                        if (rimRadius > 15 && rimRadius < 200) {
                            rimDetected = true;
                            // Store rim position (it doesn't move)
                            if (!clientSideTrackerState.rimPosition) {
                                clientSideTrackerState.rimPosition = [rimX, rimY];
                                clientSideTrackerState.rimRadius = rimRadius;
                            } else {
                                // Use stored position if detection is inconsistent
                                rimX = clientSideTrackerState.rimPosition[0];
                                rimY = clientSideTrackerState.rimPosition[1];
                                rimRadius = clientSideTrackerState.rimRadius;
                            }
                        }
                    }
                }
            } else if (clientSideTrackerState.rimPosition) {
                // Use stored rim position if not detected this frame
                rimX = clientSideTrackerState.rimPosition[0];
                rimY = clientSideTrackerState.rimPosition[1];
                rimRadius = clientSideTrackerState.rimRadius;
                rimDetected = true;
            }
            
            // Analyze trajectory for shot result (MUCH more conservative - only trigger on clear shots)
            let shotResult = null;
            
            // Only analyze if we have:
            // 1. Enough ball positions (at least 8 frames = ball was tracked for a while)
            // 2. Rim is detected and stored
            // 3. Ball was clearly moving (not just stationary)
            if (clientSideTrackerState.ballPositions.length >= 8 && clientSideTrackerState.rimPosition) {
                const rimPos = clientSideTrackerState.rimPosition;
                const rimRad = clientSideTrackerState.rimRadius || 30;
                const ballPositions = clientSideTrackerState.ballPositions.map(p => p.pos);
                
                // Check if ball actually moved (not just stationary detection)
                const firstPos = ballPositions[0];
                const lastPos = ballPositions[ballPositions.length - 1];
                const totalMovement = Math.sqrt(
                    Math.pow(lastPos[0] - firstPos[0], 2) + 
                    Math.pow(lastPos[1] - firstPos[1], 2)
                );
                
                // Ball must have moved at least 30 pixels (actual shot motion)
                if (totalMovement < 30) {
                    return {
                        algorithm: 'contourBased',
                        ball_detected: ballDetected,
                        ball_x: ballX,
                        ball_y: ballY,
                        ball_radius: ballRadius,
                        rim_detected: rimDetected,
                        rim_x: rimX,
                        rim_y: rimY,
                        rim_radius: rimRadius,
                        shot_result: null,
                        confidence: (ballDetected ? 0.8 : 0) + (rimDetected ? 0.2 : 0)
                    };
                }
                
                // Check if ball passed through rim area (strict criteria)
                let ballAboveRim = false;
                let ballBelowRim = false;
                let ballNearRimHorizontally = false;
                let minDistToRim = Infinity;
                
                for (let pos of ballPositions) {
                    const distToRim = Math.sqrt(
                        Math.pow(pos[0] - rimPos[0], 2) + 
                        Math.pow(pos[1] - rimPos[1], 2)
                    );
                    minDistToRim = Math.min(minDistToRim, distToRim);
                    
                    // Check vertical position relative to rim
                    if (pos[1] < rimPos[1] - rimRad * 0.3) {
                        ballAboveRim = true;
                    }
                    if (pos[1] > rimPos[1] + rimRad * 0.3) {
                        ballBelowRim = true;
                    }
                    
                    // Check horizontal proximity (ball must be close horizontally)
                    const horizontalDist = Math.abs(pos[0] - rimPos[0]);
                    if (horizontalDist < rimRad * 1.2) {
                        ballNearRimHorizontally = true;
                    }
                }
                
                // Only call it a make if:
                // 1. Ball was above AND below rim (went through)
                // 2. Ball was close horizontally to rim
                // 3. Ball got very close to rim center
                if (ballAboveRim && ballBelowRim && ballNearRimHorizontally && minDistToRim < rimRad * 1.5) {
                    const currentTime = Date.now();
                    if (currentTime - clientSideTrackerState.lastShotTime > 3000) { // 3 second cooldown
                        shotResult = 'make';
                        clientSideTrackerState.lastShotTime = currentTime;
                        clientSideTrackerState.ballPositions = [];
                    }
                }
                // Don't call misses automatically - too many false positives
                // Only call miss if user explicitly marks it or we're very certain
            }
            
            // Debug logging (can be removed later)
            if (ballDetected || rimDetected) {
                console.log('Detection:', {
                    ball: ballDetected,
                    ballPos: ballDetected ? [ballX, ballY] : null,
                    rim: rimDetected,
                    rimPos: rimDetected ? [rimX, rimY] : null,
                    shotResult: shotResult,
                    ballTrajectoryLength: clientSideTrackerState.ballPositions.length
                });
            }
            
            return {
                algorithm: 'colorBased',
                ball_detected: ballDetected,
                ball_x: ballX,
                ball_y: ballY,
                ball_radius: ballRadius,
                rim_detected: rimDetected,
                rim_x: rimX,
                rim_y: rimY,
                rim_radius: rimRadius,
                shot_result: shotResult,
                confidence: ballDetected ? (ballCandidates.length / 100) : 0
            };
        }
        
        // Algorithm 2: Motion-based detection (browlm13 style - trajectory analysis)
        function detectBallAndRimMotionBased(ctx, width, height, prevFrame) {
            const imageData = ctx.getImageData(0, 0, width, height);
            const data = imageData.data;
            
            let ballDetected = false;
            let ballX = 0, ballY = 0, ballRadius = 0;
            
            if (prevFrame && prevFrame.length === data.length) {
                // Detect moving objects (ball should be moving)
                const motionThreshold = 30;
                const movingPixels = [];
                
                for (let i = 0; i < data.length; i += 16) { // Sample every 4th pixel
                    const idx = Math.floor(i / 4) * 4;
                    if (idx + 3 < data.length && idx + 3 < prevFrame.length) {
                        const currBrightness = (data[idx] + data[idx + 1] + data[idx + 2]) / 3;
                        const prevBrightness = (prevFrame[idx] + prevFrame[idx + 1] + prevFrame[idx + 2]) / 3;
                        const motion = Math.abs(currBrightness - prevBrightness);
                        
                        if (motion > motionThreshold) {
                            const x = (idx / 4) % width;
                            const y = Math.floor((idx / 4) / width);
                            movingPixels.push({x, y, motion});
                        }
                    }
                }
                
                // Cluster moving pixels to find ball
                if (movingPixels.length > 30) {
                    let sumX = 0, sumY = 0;
                    movingPixels.forEach(p => {
                        sumX += p.x;
                        sumY += p.y;
                    });
                    ballX = Math.round(sumX / movingPixels.length);
                    ballY = Math.round(sumY / movingPixels.length);
                    ballRadius = 20; // Default radius
                    ballDetected = true;
                }
            }
            
            // Store current frame for next comparison
            if (!window.prevFrameData) {
                window.prevFrameData = new Uint8Array(data.length);
            }
            window.prevFrameData.set(data);
            
            return {
                algorithm: 'motionBased',
                ball_detected: ballDetected,
                ball_x: ballX,
                ball_y: ballY,
                ball_radius: ballRadius,
                rim_detected: false, // Motion-based doesn't detect rim well
                rim_x: 0,
                rim_y: 0,
                rim_radius: 0,
                shot_result: null,
                confidence: ballDetected ? 0.6 : 0
            };
        }
        
        // Algorithm 3: Improved HSV-based detection (much more accurate than RGB)
        // Based on OpenCV HSV ranges used in professional basketball detection systems
        function detectBallAndRimContourBased(ctx, width, height) {
            const imageData = ctx.getImageData(0, 0, width, height);
            const data = imageData.data;
            
            let ballDetected = false;
            let ballX = 0, ballY = 0, ballRadius = 0;
            let rimDetected = false;
            let rimX = 0, rimY = 0, rimRadius = 0;
            
            const ballCandidates = [];
            const rimCandidates = [];
            
            // Focus on court area (avoid sky/trees)
            const courtStartY = Math.floor(height * 0.15);
            const courtEndY = Math.floor(height * 0.9);
            const step = 2; // Denser sampling for better detection
            
            for (let y = courtStartY; y < courtEndY; y += step) {
                for (let x = Math.floor(width * 0.1); x < Math.floor(width * 0.9); x += step) {
                    const idx = (y * width + x) * 4;
                    if (idx + 2 >= data.length) continue;
                    
                    const r = data[idx] / 255.0;
                    const g = data[idx + 1] / 255.0;
                    const b = data[idx + 2] / 255.0;
                    
                    // Convert RGB to HSV (more robust to lighting)
                    const max = Math.max(r, g, b);
                    const min = Math.min(r, g, b);
                    const delta = max - min;
                    
                    let h = 0, s = 0, v = max;
                    
                    if (delta !== 0) {
                        s = delta / (max + 0.001);
                        if (max === r) {
                            h = 60 * (((g - b) / delta) % 6);
                        } else if (max === g) {
                            h = 60 * (((b - r) / delta) + 2);
                        } else {
                            h = 60 * (((r - g) / delta) + 4);
                        }
                        if (h < 0) h += 360;
                    }
                    
                    // Basketball detection: Orange (10-30Â°) or Red (0-10Â° or 350-360Â°)
                    // Based on OpenCV HSV ranges: [0,100,100] to [10,255,255] and [160,100,100] to [180,255,255]
                    const hDegrees = h;
                    const sPercent = s * 100;
                    const vPercent = v * 100;
                    
                    // Orange range: Hue 10-30, Saturation > 40%, Value > 40%
                    const isOrange = (hDegrees >= 10 && hDegrees <= 30 && sPercent > 40 && vPercent > 40);
                    // Red range: Hue 0-10 or 350-360, Saturation > 50%, Value > 50%
                    const isRed = ((hDegrees >= 0 && hDegrees <= 10) || (hDegrees >= 350 && hDegrees <= 360)) && 
                                  sPercent > 50 && vPercent > 50;
                    
                    if (isOrange || isRed) {
                        // Additional check: must be in reasonable size range and court area
                        if (y > height * 0.2 && y < height * 0.85) {
                            ballCandidates.push({x, y, h: hDegrees, s: sPercent, v: vPercent});
                        }
                    }
                    
                    // Rim detection: High brightness (Value > 70%), low saturation (< 30%), white/metallic
                    // Must be in upper portion of frame
                    if (y < height * 0.6 && vPercent > 70 && sPercent < 30) {
                        // Additional check: RGB values should be similar (white/gray)
                        const rgbDiff = Math.max(Math.abs(r - g), Math.abs(g - b), Math.abs(r - b));
                        if (rgbDiff < 0.15) { // Very low color variation
                            rimCandidates.push({x, y, v: vPercent});
                        }
                    }
                }
            }
            
            // Cluster ball candidates using DBSCAN-like approach
            if (ballCandidates.length > 20) {
                // Group nearby candidates
                const clusters = [];
                const used = new Set();
                
                for (let i = 0; i < ballCandidates.length; i++) {
                    if (used.has(i)) continue;
                    
                    const cluster = [i];
                    used.add(i);
                    const center = ballCandidates[i];
                    
                    // Find nearby points
                    for (let j = i + 1; j < ballCandidates.length; j++) {
                        if (used.has(j)) continue;
                        const dist = Math.sqrt(
                            Math.pow(ballCandidates[j].x - center.x, 2) + 
                            Math.pow(ballCandidates[j].y - center.y, 2)
                        );
                        if (dist < 30) { // Within 30 pixels
                            cluster.push(j);
                            used.add(j);
                        }
                    }
                    
                    if (cluster.length > 15) { // Need at least 15 points for a valid ball
                        clusters.push(cluster);
                    }
                }
                
                // Find largest cluster (most likely the ball)
                if (clusters.length > 0) {
                    clusters.sort((a, b) => b.length - a.length);
                    const bestCluster = clusters[0];
                    
                    let sumX = 0, sumY = 0;
                    let minX = width, maxX = 0, minY = height, maxY = 0;
                    
                    bestCluster.forEach(idx => {
                        const p = ballCandidates[idx];
                        sumX += p.x;
                        sumY += p.y;
                        minX = Math.min(minX, p.x);
                        maxX = Math.max(maxX, p.x);
                        minY = Math.min(minY, p.y);
                        maxY = Math.max(maxY, p.y);
                    });
                    
                    ballX = Math.round(sumX / bestCluster.length);
                    ballY = Math.round(sumY / bestCluster.length);
                    const width_ball = maxX - minX;
                    const height_ball = maxY - minY;
                    ballRadius = Math.max(width_ball, height_ball) / 2;
                    
                    // Validate size
                    if (ballRadius >= 8 && ballRadius <= 50) {
                        ballDetected = true;
                    }
                }
            }
            
            // Cluster rim candidates
            if (rimCandidates.length > 30) {
                // Rim is typically larger and more spread out
                let sumX = 0, sumY = 0, count = 0;
                let minX = width, maxX = 0, minY = height, maxY = 0;
                
                rimCandidates.forEach(p => {
                    sumX += p.x;
                    sumY += p.y;
                    count++;
                    minX = Math.min(minX, p.x);
                    maxX = Math.max(maxX, p.x);
                    minY = Math.min(minY, p.y);
                    maxY = Math.max(maxY, p.y);
                });
                
                rimX = Math.round(sumX / count);
                rimY = Math.round(sumY / count);
                const rimWidth = maxX - minX;
                const rimHeight = maxY - minY;
                rimRadius = Math.max(rimWidth, rimHeight) / 2;
                
                // Rim should be larger than ball
                if (rimRadius >= 15 && rimRadius <= 80) {
                    rimDetected = true;
                }
            }
            
            return {
                algorithm: 'hsvBased',
                ball_detected: ballDetected,
                ball_x: ballX,
                ball_y: ballY,
                ball_radius: ballRadius,
                rim_detected: rimDetected,
                rim_x: rimX,
                rim_y: rimY,
                rim_radius: rimRadius,
                shot_result: null,
                confidence: (ballDetected ? 0.85 : 0) + (rimDetected ? 0.15 : 0)
            };
        }
        
        // Algorithm 4: Trajectory-based (point-slope analysis)
        function detectBallAndRimTrajectoryBased(ctx, width, height) {
            // This uses the trajectory data we already have
            const ballPositions = clientSideTrackerState.ballPositions.map(p => p.pos);
            const rimPos = clientSideTrackerState.rimPosition;
            
            let ballDetected = false;
            let ballX = 0, ballY = 0, ballRadius = 0;
            let shotResult = null;
            
            if (ballPositions.length > 0) {
                const lastPos = ballPositions[ballPositions.length - 1];
                ballDetected = true;
                ballX = lastPos[0];
                ballY = lastPos[1];
                ballRadius = 15;
                
                // Point-slope analysis for make/miss
                if (ballPositions.length >= 5 && rimPos) {
                    const rimRad = clientSideTrackerState.rimRadius || 30;
                    
                    // Calculate trajectory line
                    const firstPos = ballPositions[0];
                    const slope = (lastPos[1] - firstPos[1]) / (lastPos[0] - firstPos[0] + 0.001);
                    const intercept = firstPos[1] - slope * firstPos[0];
                    
                    // Find intersection with rim height
                    const rimY = rimPos[1];
                    const intersectionX = (rimY - intercept) / (slope + 0.001);
                    const distToRim = Math.abs(intersectionX - rimPos[0]);
                    
                    if (distToRim < rimRad * 1.5) {
                        const currentTime = Date.now();
                        if (currentTime - clientSideTrackerState.lastShotTime > 2000) {
                            shotResult = 'make';
                            clientSideTrackerState.lastShotTime = currentTime;
                        }
                    } else if (ballPositions.length > 10) {
                        const currentTime = Date.now();
                        if (currentTime - clientSideTrackerState.lastShotTime > 2000) {
                            shotResult = 'miss';
                            clientSideTrackerState.lastShotTime = currentTime;
                        }
                    }
                }
            }
            
            return {
                algorithm: 'trajectoryBased',
                ball_detected: ballDetected,
                ball_x: ballX,
                ball_y: ballY,
                ball_radius: ballRadius,
                rim_detected: rimPos !== null,
                rim_x: rimPos ? rimPos[0] : 0,
                rim_y: rimPos ? rimPos[1] : 0,
                rim_radius: clientSideTrackerState.rimRadius || 0,
                shot_result: shotResult,
                confidence: ballDetected ? 0.8 : 0
            };
        }
        
        // Algorithm 5: HSV-based detection (more accurate color space - Hoopify style)
        function detectBallAndRimHSVBased(ctx, width, height) {
            const imageData = ctx.getImageData(0, 0, width, height);
            const data = imageData.data;
            
            let ballDetected = false;
            let ballX = 0, ballY = 0, ballRadius = 0;
            let rimDetected = false;
            let rimX = 0, rimY = 0, rimRadius = 0;
            
            const ballCandidates = [];
            const rimCandidates = [];
            
            // Convert RGB to HSV and detect
            for (let y = 0; y < height; y += 3) {
                for (let x = 0; x < width; x += 3) {
                    const idx = (y * width + x) * 4;
                    if (idx + 2 >= data.length) continue;
                    
                    const r = data[idx] / 255;
                    const g = data[idx + 1] / 255;
                    const b = data[idx + 2] / 255;
                    
                    const max = Math.max(r, g, b);
                    const min = Math.min(r, g, b);
                    const delta = max - min;
                    
                    let h = 0, s = 0, v = max;
                    
                    if (delta !== 0) {
                        s = delta / max;
                        if (max === r) {
                            h = 60 * (((g - b) / delta) % 6);
                        } else if (max === g) {
                            h = 60 * (((b - r) / delta) + 2);
                        } else {
                            h = 60 * (((r - g) / delta) + 4);
                        }
                        if (h < 0) h += 360;
                    }
                    
                    // Basketball: Orange (10-30 degrees) or Red (0-10 or 350-360)
                    const isOrange = (h >= 10 && h <= 30 && s > 0.5 && v > 0.4);
                    const isRed = ((h >= 0 && h <= 10) || (h >= 350 && h <= 360)) && s > 0.6 && v > 0.5;
                    
                    if (isOrange || isRed) {
                        ballCandidates.push({x, y, h, s, v});
                    }
                    
                    // Rim: High brightness, low saturation (white/metallic)
                    if (v > 0.7 && s < 0.3 && y < height * 0.6) {
                        rimCandidates.push({x, y, v});
                    }
                }
            }
            
            // Cluster ball candidates
            if (ballCandidates.length > 30) {
                let sumX = 0, sumY = 0, count = 0;
                let minX = width, maxX = 0, minY = height, maxY = 0;
                
                ballCandidates.forEach(p => {
                    sumX += p.x;
                    sumY += p.y;
                    count++;
                    minX = Math.min(minX, p.x);
                    maxX = Math.max(maxX, p.x);
                    minY = Math.min(minY, p.y);
                    maxY = Math.max(maxY, p.y);
                });
                
                ballX = Math.round(sumX / count);
                ballY = Math.round(sumY / count);
                ballRadius = Math.max((maxX - minX) / 2, (maxY - minY) / 2);
                
                if (ballRadius > 5 && ballRadius < 120) {
                    ballDetected = true;
                }
            }
            
            // Cluster rim candidates
            if (rimCandidates.length > 40) {
                let sumX = 0, sumY = 0, count = 0;
                rimCandidates.forEach(p => {
                    sumX += p.x;
                    sumY += p.y;
                    count++;
                });
                
                rimX = Math.round(sumX / count);
                rimY = Math.round(sumY / count);
                rimRadius = 25; // Default rim radius
                rimDetected = true;
            }
            
            return {
                algorithm: 'hsvBased',
                ball_detected: ballDetected,
                ball_x: ballX,
                ball_y: ballY,
                ball_radius: ballRadius,
                rim_detected: rimDetected,
                rim_x: rimX,
                rim_y: rimY,
                rim_radius: rimRadius,
                shot_result: null,
                confidence: (ballDetected ? 0.75 : 0) + (rimDetected ? 0.25 : 0)
            };
        }
        
        // Algorithm 6: Edge-based detection (Canny-like approach)
        function detectBallAndRimEdgeBased(ctx, width, height) {
            const imageData = ctx.getImageData(0, 0, width, height);
            const data = imageData.data;
            
            // Simple edge detection
            const edges = [];
            const step = 2;
            
            for (let y = step; y < height - step; y += step) {
                for (let x = step; x < width - step; x += step) {
                    const idx = (y * width + x) * 4;
                    if (idx + 2 >= data.length) continue;
                    
                    const center = (data[idx] + data[idx + 1] + data[idx + 2]) / 3;
                    const right = (data[idx + 4] + data[idx + 5] + data[idx + 6]) / 3;
                    const bottom = (data[((y + step) * width + x) * 4] + 
                                   data[((y + step) * width + x) * 4 + 1] + 
                                   data[((y + step) * width + x) * 4 + 2]) / 3;
                    
                    const edgeStrength = Math.abs(center - right) + Math.abs(center - bottom);
                    
                    if (edgeStrength > 40) {
                        edges.push({x, y, strength: edgeStrength});
                    }
                }
            }
            
            // Find circular edges (ball/rim)
            let ballDetected = false;
            let ballX = 0, ballY = 0, ballRadius = 0;
            
            // Look for circular patterns in edges
            for (let i = 0; i < Math.min(edges.length, 100); i++) {
                const center = edges[i];
                let circleScore = 0;
                const testRadius = 15;
                
                for (let angle = 0; angle < 360; angle += 30) {
                    const checkX = Math.round(center.x + testRadius * Math.cos(angle * Math.PI / 180));
                    const checkY = Math.round(center.y + testRadius * Math.sin(angle * Math.PI / 180));
                    
                    if (checkX >= 0 && checkX < width && checkY >= 0 && checkY < height) {
                        const checkIdx = (checkY * width + checkX) * 4;
                        if (checkIdx + 2 < data.length) {
                            const r = data[checkIdx];
                            const g = data[checkIdx + 1];
                            const b = data[checkIdx + 2];
                            // Check if it's orange/red (ball)
                            if ((r > 150 && r > g * 1.2 && b < g * 0.8) || (r > 200 && g < 120)) {
                                circleScore++;
                            }
                        }
                    }
                }
                
                if (circleScore >= 6) {
                    ballDetected = true;
                    ballX = center.x;
                    ballY = center.y;
                    ballRadius = testRadius;
                    break;
                }
            }
            
            return {
                algorithm: 'edgeBased',
                ball_detected: ballDetected,
                ball_x: ballX,
                ball_y: ballY,
                ball_radius: ballRadius,
                rim_detected: false,
                rim_x: 0,
                rim_y: 0,
                rim_radius: 0,
                shot_result: null,
                confidence: ballDetected ? 0.65 : 0
            };
        }
        
        // Algorithm 7: Region-of-Interest based (focus on court area - AI Field Goal Tracker style)
        function detectBallAndRimROIBased(ctx, width, height) {
            // Focus detection on the court area (lower 2/3 of frame, center region)
            const roiX = width * 0.2;
            const roiY = height * 0.2;
            const roiWidth = width * 0.6;
            const roiHeight = height * 0.6;
            
            const imageData = ctx.getImageData(roiX, roiY, roiWidth, roiHeight);
            const data = imageData.data;
            
            let ballDetected = false;
            let ballX = 0, ballY = 0, ballRadius = 0;
            let rimDetected = false;
            let rimX = 0, rimY = 0, rimRadius = 0;
            
            const ballCandidates = [];
            const rimCandidates = [];
            
            // Detect in ROI only
            for (let y = 0; y < roiHeight; y += 4) {
                for (let x = 0; x < roiWidth; x += 4) {
                    const idx = (y * roiWidth + x) * 4;
                    if (idx + 2 >= data.length) continue;
                    
                    const r = data[idx];
                    const g = data[idx + 1];
                    const b = data[idx + 2];
                    
                    // Ball: orange/red
                    const isBall = (r > 130 && r > g * 1.15 && b < g * 0.85) || 
                                  (r > 170 && g < 110 && b < 110);
                    
                    // Rim: bright white
                    const brightness = (r + g + b) / 3;
                    const isRim = brightness > 190 && Math.abs(r - g) < 20 && Math.abs(g - b) < 20;
                    
                    if (isBall) {
                        ballCandidates.push({x: x + roiX, y: y + roiY});
                    }
                    if (isRim && y < roiHeight * 0.5) { // Rim in upper part of ROI
                        rimCandidates.push({x: x + roiX, y: y + roiY});
                    }
                }
            }
            
            // Cluster ball
            if (ballCandidates.length > 25) {
                let sumX = 0, sumY = 0;
                ballCandidates.forEach(p => {
                    sumX += p.x;
                    sumY += p.y;
                });
                ballX = Math.round(sumX / ballCandidates.length);
                ballY = Math.round(sumY / ballCandidates.length);
                ballRadius = 18;
                ballDetected = true;
            }
            
            // Cluster rim
            if (rimCandidates.length > 30) {
                let sumX = 0, sumY = 0;
                rimCandidates.forEach(p => {
                    sumX += p.x;
                    sumY += p.y;
                });
                rimX = Math.round(sumX / rimCandidates.length);
                rimY = Math.round(sumY / rimCandidates.length);
                rimRadius = 28;
                rimDetected = true;
            }
            
            return {
                algorithm: 'roiBased',
                ball_detected: ballDetected,
                ball_x: ballX,
                ball_y: ballY,
                ball_radius: ballRadius,
                rim_detected: rimDetected,
                rim_x: rimX,
                rim_y: rimY,
                rim_radius: rimRadius,
                shot_result: null,
                confidence: (ballDetected ? 0.8 : 0) + (rimDetected ? 0.2 : 0)
            };
        }
        
        // Client-side fallback detection (used when backend unavailable)
        function detectBallAndRimClientSide(ctx, width, height) {
            // Fallback to HSV-based detection
            const contourResult = detectBallAndRimContourBased(ctx, width, height);
            
            // Track ball position for trajectory analysis
            if (contourResult.ball_detected) {
                const currentTime = Date.now();
                clientSideTrackerState.ballPositions.push({
                    pos: [contourResult.ball_x, contourResult.ball_y],
                    time: currentTime
                });
                
                // Keep only recent positions (last 2 seconds)
                clientSideTrackerState.ballPositions = clientSideTrackerState.ballPositions.filter(
                    p => currentTime - p.time < 2000
                );
            }
            
            // Store rim position
            if (contourResult.rim_detected && !clientSideTrackerState.rimPosition) {
                clientSideTrackerState.rimPosition = [contourResult.rim_x, contourResult.rim_y];
                clientSideTrackerState.rimRadius = contourResult.rim_radius;
            } else if (clientSideTrackerState.rimPosition && !contourResult.rim_detected) {
                // Use stored rim position if not detected this frame
                contourResult.rim_x = clientSideTrackerState.rimPosition[0];
                contourResult.rim_y = clientSideTrackerState.rimPosition[1];
                contourResult.rim_radius = clientSideTrackerState.rimRadius;
                contourResult.rim_detected = true;
            }
            
            // Analyze trajectory for shot result (VERY conservative - only makes, no automatic misses)
            if (clientSideTrackerState.ballPositions.length >= 10 && clientSideTrackerState.rimPosition) {
                const rimPos = clientSideTrackerState.rimPosition;
                const rimRad = clientSideTrackerState.rimRadius || 30;
                const ballPositions = clientSideTrackerState.ballPositions.map(p => p.pos);
                
                // Check if ball actually moved significantly (real shot motion)
                const firstPos = ballPositions[0];
                const lastPos = ballPositions[ballPositions.length - 1];
                const totalMovement = Math.sqrt(
                    Math.pow(lastPos[0] - firstPos[0], 2) + 
                    Math.pow(lastPos[1] - firstPos[1], 2)
                );
                
                // Ball must have moved at least 40 pixels (actual shot motion, not false detection)
                if (totalMovement < 40) {
                    // Not enough movement - don't analyze
                    return contourResult;
                }
                
                let ballAboveRim = false;
                let ballBelowRim = false;
                let ballNearRimHorizontally = false;
                let minDistToRim = Infinity;
                
                for (let pos of ballPositions) {
                    const distToRim = Math.sqrt(
                        Math.pow(pos[0] - rimPos[0], 2) + 
                        Math.pow(pos[1] - rimPos[1], 2)
                    );
                    minDistToRim = Math.min(minDistToRim, distToRim);
                    
                    // Check vertical position relative to rim
                    if (pos[1] < rimPos[1] - rimRad * 0.4) {
                        ballAboveRim = true;
                    }
                    if (pos[1] > rimPos[1] + rimRad * 0.4) {
                        ballBelowRim = true;
                    }
                    
                    // Check horizontal proximity
                    const horizontalDist = Math.abs(pos[0] - rimPos[0]);
                    if (horizontalDist < rimRad * 1.3) {
                        ballNearRimHorizontally = true;
                    }
                }
                
                // Only call it a make if ALL conditions are met:
                // 1. Ball was clearly above AND below rim (went through)
                // 2. Ball was close horizontally to rim
                // 3. Ball got very close to rim center (within 1.3x radius)
                if (ballAboveRim && ballBelowRim && ballNearRimHorizontally && minDistToRim < rimRad * 1.3) {
                    const currentTime = Date.now();
                    if (currentTime - clientSideTrackerState.lastShotTime > 4000) { // 4 second cooldown
                        contourResult.shot_result = 'make';
                        clientSideTrackerState.lastShotTime = currentTime;
                        clientSideTrackerState.ballPositions = [];
                    }
                }
                // REMOVED automatic miss detection - too many false positives
                // Only detect makes, not misses automatically
            }
            
            // Log detection
            if (contourResult.ball_detected || contourResult.rim_detected) {
                console.log('Client-side Algorithm:', {
                    ball: contourResult.ball_detected,
                    ballPos: contourResult.ball_detected ? [contourResult.ball_x, contourResult.ball_y] : null,
                    rim: contourResult.rim_detected,
                    rimPos: contourResult.rim_detected ? [contourResult.rim_x, contourResult.rim_y] : null,
                    shotResult: contourResult.shot_result
                });
            }
            
            return contourResult;
        }
        
        // Store latest detection result for indicator
        let latestDetectionResult = null;
        
        function updateAlgorithmIndicator() {
            const indicator = document.getElementById('algorithmIndicator');
            const stats = document.getElementById('algorithmStats');
            
            if (!indicator || !stats) return;
            
            // Always show the indicator when shot tracker is active
            indicator.style.display = 'block';
            
            // Use latest detection result (from backend or client-side)
            const result = latestDetectionResult;
            if (result) {
                const ballDet = result.ball_detected ? 'âœ“' : 'âœ—';
                const rimDet = result.rim_detected ? 'âœ“' : 'âœ—';
                const conf = (result.confidence * 100).toFixed(0);
                const ballColor = result.ball_detected ? '#4ade80' : '#ef4444';
                const rimColor = result.rim_detected ? '#4ade80' : '#ef4444';
                // Get tracker name from result, default to AI-Basketball-Shot-Detection-Tracker
                const algoName = result.tracker || (result.algorithm === 'yolo8' ? 'AI-Basketball-Shot-Detection-Tracker (YOLOv8)' : 'Client-side');
                
                // Update the model name display
                const modelNameDiv = indicator.querySelector('div[style*="font-weight: 700"]');
                if (modelNameDiv) {
                    modelNameDiv.textContent = `ðŸ€ Model: ${algoName}`;
                }
                
                stats.innerHTML = `
                    <div style="margin-top: 4px;">
                        <div style="color: ${ballColor}; margin-bottom: 2px;">Ball: ${ballDet} ${result.ball_detected ? `(${result.ball_x}, ${result.ball_y})` : ''}</div>
                        <div style="color: ${rimColor}; margin-bottom: 2px;">Rim: ${rimDet} ${result.rim_detected ? `(${result.rim_x}, ${result.rim_y})` : ''}</div>
                        <div style="color: #94a3b8; font-size: 9px; margin-top: 4px;">Confidence: ${conf}%</div>
                        ${result.shot_result ? `<div style="color: #fbbf24; margin-top: 4px; font-weight: 600;">Shot: ${result.shot_result.toUpperCase()}</div>` : ''}
                    </div>
                `;
            } else {
                // Show model info even when no detections yet
                stats.innerHTML = '<div style="color: #94a3b8; font-size: 9px;">Waiting for detection...</div>';
            }
        }
        
        let lastShotTime = 0;
        const SHOT_COOLDOWN = 2000; // 2 seconds between shots
        
        function handleShotResult(result) {
            const now = Date.now();
            if (now - lastShotTime < SHOT_COOLDOWN) {
                return; // Prevent duplicate detections
            }
            
            lastShotTime = now;
            
            shotTrackerStats.total++;
            if (result === 'make') {
                shotTrackerStats.makes++;
            } else {
                shotTrackerStats.misses++;
            }
            
            shotHistory.push({
                result: result,
                timestamp: now
            });
            
            // Keep only last 50 shots in history
            if (shotHistory.length > 50) {
                shotHistory.shift();
            }
            
            updateShotTrackerDisplay();
            updateShotHistory();
            saveShotTrackerStats();
            
            // Show notification
            showShotNotification(result);
        }
        
        function showShotNotification(result) {
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                padding: 20px 30px;
                background: ${result === 'make' ? '#11998e' : '#f5576c'};
                color: white;
                border-radius: 12px;
                font-size: 24px;
                font-weight: 700;
                z-index: 10000;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                animation: slideIn 0.3s ease;
            `;
            notification.textContent = result === 'make' ? 'âœ… MAKE!' : 'âŒ MISS';
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.style.animation = 'slideOut 0.3s ease';
                setTimeout(() => notification.remove(), 300);
            }, 1500);
        }
        
        // Add CSS animations
        if (!document.getElementById('shotTrackerStyles')) {
            const style = document.createElement('style');
            style.id = 'shotTrackerStyles';
            style.textContent = `
                @keyframes slideIn {
                    from { transform: translateX(400px); opacity: 0; }
                    to { transform: translateX(0); opacity: 1; }
                }
                @keyframes slideOut {
                    from { transform: translateX(0); opacity: 1; }
                    to { transform: translateX(400px); opacity: 0; }
                }
            `;
            document.head.appendChild(style);
        }
        
        // Mode toggle functions
        function switchShotTrackerMode(mode) {
            shotTrackerMode = mode;
            
            const liveBtn = document.getElementById('shotTrackerLiveModeBtn');
            const uploadBtn = document.getElementById('shotTrackerUploadModeBtn');
            const liveControls = document.getElementById('shotTrackerLiveControls');
            const videoControls = document.getElementById('shotTrackerVideoControls');
            const uploadControls = document.getElementById('shotTrackerUploadControls');
            const video = document.getElementById('shotTrackerVideo');
            const outputCanvas = document.getElementById('shotTrackerOutput');
            
            if (mode === 'live') {
                liveBtn.classList.add('active');
                uploadBtn.classList.remove('active');
                liveControls.style.display = 'flex';
                videoControls.style.display = 'none';
                uploadControls.style.display = 'none';
                video.controls = false;
                video.autoplay = true;
                
                // Stop any video analysis
                if (videoAnalysisActive) {
                    stopVideoAnalysis();
                }
                
                // Clear video source if it was from upload
                if (video.src && video.src.startsWith('blob:')) {
                    URL.revokeObjectURL(video.src);
                    video.src = '';
                }
                
                // Clear overlay
                const ctx = outputCanvas.getContext('2d');
                ctx.clearRect(0, 0, outputCanvas.width, outputCanvas.height);
            } else {
                liveBtn.classList.remove('active');
                uploadBtn.classList.add('active');
                liveControls.style.display = 'none';
                videoControls.style.display = 'flex';
                uploadControls.style.display = 'block';
                video.controls = true;
                video.autoplay = false;
                
                // Stop live tracking if active
                if (shotTrackerActive) {
                    stopShotTracker();
                }
                
                // Clear overlay
                const ctx = outputCanvas.getContext('2d');
                ctx.clearRect(0, 0, outputCanvas.width, outputCanvas.height);
            }
        }
        
        // Handle video file upload
        function handleVideoUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            if (!file.type.startsWith('video/')) {
                alert('Please select a valid video file.');
                return;
            }
            
            uploadedVideoFile = file;
            const fileName = file.name;
            document.getElementById('shotTrackerUploadedFileName').textContent = `Selected: ${fileName}`;
            
            const video = document.getElementById('shotTrackerVideo');
            const url = URL.createObjectURL(file);
            video.src = url;
            video.load();
            
            // Reset stats when new video is loaded
            shotTrackerStats = { total: 0, makes: 0, misses: 0 };
            shotHistory = [];
            updateShotTrackerDisplay();
            updateShotHistory();
            
            // Reset client-side tracker state
            clientSideTrackerState = {
                ballPositions: [],
                rimPosition: null,
                rimRadius: null,
                lastShotTime: 0,
                useBackend: false
            };
            
            // Try to reset backend if available (completely silent, no errors)
            if (API_BASE_URL) {
                fetch(`${API_BASE_URL}/api/reset_shot_tracker`, { 
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                }).catch(() => {
                    // Silently ignore - backend not available, client-side will work
                });
            }
        }
        
        // Analyze uploaded video frame by frame
        async function analyzeUploadedVideo() {
            const video = document.getElementById('shotTrackerVideo');
            if (!uploadedVideoFile || !video.src) {
                alert('Please upload a video file first.');
                return;
            }
            
            videoAnalysisActive = true;
            videoAnalysisPaused = false;
            
            const analyzeBtn = document.getElementById('analyzeUploadedVideo');
            const pauseBtn = document.getElementById('pauseVideoAnalysis');
            const statusDiv = document.getElementById('videoAnalysisStatus');
            const statusText = document.getElementById('analysisStatusText');
            
            analyzeBtn.style.display = 'none';
            pauseBtn.style.display = 'inline-block';
            statusDiv.style.display = 'block';
            statusText.textContent = 'Analyzing video...';
            
            // Show analysis indicator
            const indicator = document.getElementById('analysisIndicator');
            if (indicator) indicator.style.display = 'block';
            
            // Show algorithm indicator
            const algoIndicator = document.getElementById('algorithmIndicator');
            if (algoIndicator) algoIndicator.style.display = 'block';
            
            // Reset stats for this analysis
            shotTrackerStats = { total: 0, makes: 0, misses: 0 };
            shotHistory = [];
            updateShotTrackerDisplay();
            updateShotHistory();
            
            // Reset client-side tracker state
            clientSideTrackerState = {
                ballPositions: [],
                rimPosition: null,
                rimRadius: null,
                lastShotTime: 0,
                useBackend: false
            };
            
            // Try to reset backend if available (completely silent, no errors)
            if (API_BASE_URL) {
                fetch(`${API_BASE_URL}/api/reset_shot_tracker`, { 
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                }).then(() => {
                    clientSideTrackerState.useBackend = true;
                }).catch(() => {
                    // Silently ignore - backend not available, client-side will work
                    clientSideTrackerState.useBackend = false;
                });
            }
            
            // Wait for video metadata to load
            if (video.readyState < video.HAVE_METADATA) {
                video.addEventListener('loadedmetadata', () => {
                    video.currentTime = 0;
                    lastProcessedTime = 0;
                    video.play().then(() => {
                        processUploadedVideoFrames();
                    }).catch(err => {
                        console.error('Error playing video:', err);
                        alert('Error playing video. Please try again.');
                    });
                }, { once: true });
            } else {
                video.currentTime = 0;
                lastProcessedTime = 0;
                video.play().then(() => {
                    processUploadedVideoFrames();
                }).catch(err => {
                    console.error('Error playing video:', err);
                    alert('Error playing video. Please try again.');
                });
            }
        }
        
        let lastProcessedTime = 0;
        const FRAME_PROCESS_INTERVAL = 100; // Process every 100ms (10 fps for analysis)
        
        async function processUploadedVideoFrames() {
            if (!videoAnalysisActive) return;
            
            if (videoAnalysisPaused) {
                // Check again after a short delay
                setTimeout(processUploadedVideoFrames, 100);
                return;
            }
            
            const video = document.getElementById('shotTrackerVideo');
            const canvas = document.getElementById('shotTrackerCanvas');
            const outputCanvas = document.getElementById('shotTrackerOutput');
            
            // Check if video is ready and playing
            if (!video || video.readyState < video.HAVE_CURRENT_DATA || video.paused || video.ended) {
                // If video ended, stop analysis
                if (video && video.ended && videoAnalysisActive) {
                    const statusText = document.getElementById('analysisStatusText');
                    statusText.textContent = 'Analysis complete!';
                    setTimeout(() => {
                        stopVideoAnalysis();
                    }, 2000);
                    return;
                }
                // Continue checking
                setTimeout(processUploadedVideoFrames, 100);
                return;
            }
            
            // Only process frames at intervals to avoid overwhelming the backend
            const currentTime = Date.now();
            if (currentTime - lastProcessedTime < FRAME_PROCESS_INTERVAL) {
                requestAnimationFrame(processUploadedVideoFrames);
                return;
            }
            lastProcessedTime = currentTime;
            
            try {
                const ctx = canvas.getContext('2d');
                const outputCtx = outputCanvas.getContext('2d');
                
                // Set canvas dimensions to match video
                if (canvas.width !== video.videoWidth || canvas.height !== video.videoHeight) {
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                }
                if (outputCanvas.width !== video.videoWidth || outputCanvas.height !== video.videoHeight) {
                    outputCanvas.width = video.videoWidth;
                    outputCanvas.height = video.videoHeight;
                }
                
                // Draw current video frame to canvas
                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                
                // Try backend first (YOLOv8), fallback to client-side detection
                let result = null;
                
                // Try backend first if available (uses AI-Basketball-Shot-Detection-Tracker YOLOv8)
                if (API_BASE_URL) {
                    try {
                        const response = await fetch(`${API_BASE_URL}/api/detect_shot`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ frame: canvas.toDataURL('image/jpeg', 0.7) })
                        });
                        
                        if (response.ok) {
                            const backendResult = await response.json();
                            if (backendResult.success) {
                                // Use backend result (AI-Basketball-Shot-Detection-Tracker YOLOv8 detection)
                                console.log('âœ“ Using YOLOv8 backend detection:', backendResult.tracker || 'AI-Basketball-Shot-Detection-Tracker (YOLOv8)');
                                result = {
                                    algorithm: 'yolo8',
                                    tracker: backendResult.tracker || 'AI-Basketball-Shot-Detection-Tracker (YOLOv8)',
                                    ball_detected: backendResult.ball_detected,
                                    ball_x: backendResult.ball_x,
                                    ball_y: backendResult.ball_y,
                                    ball_radius: backendResult.ball_radius,
                                    ball_box: backendResult.ball_box,  // Bounding box from YOLOv8
                                    rim_detected: backendResult.rim_detected,
                                    rim_x: backendResult.rim_x,
                                    rim_y: backendResult.rim_y,
                                    rim_radius: backendResult.rim_radius,
                                    rim_box: backendResult.rim_box,  // Bounding box from YOLOv8
                                    shot_result: backendResult.shot_result,
                                    makes: backendResult.makes || 0,
                                    attempts: backendResult.attempts || 0,
                                    confidence: (backendResult.ball_detected ? 0.9 : 0) + (backendResult.rim_detected ? 0.1 : 0),
                                    processed_frame: backendResult.processed_frame  // Frame with yellow lines, corner rectangles, shot counter
                                };
                                
                                // Update stats from backend (YOLOv8 tracker counts)
                                if (backendResult.makes !== undefined && backendResult.attempts !== undefined) {
                                    shotTrackerStats.makes = backendResult.makes;
                                    shotTrackerStats.total = backendResult.attempts;
                                    shotTrackerStats.misses = backendResult.attempts - backendResult.makes;
                                    updateShotTrackerDisplay();
                                }
                                
                                clientSideTrackerState.useBackend = true;
                            }
                        }
                    } catch (error) {
                        // Backend not available - log error and disable backend
                        console.error('Backend detection error:', error);
                        clientSideTrackerState.useBackend = false;
                    }
                }
                
                // Only use client-side if backend is completely unavailable
                // Do NOT fallback if backend exists but just didn't detect anything this frame
                if (!result && !API_BASE_URL) {
                    console.warn('âš ï¸ Using client-side detection (backend not configured)');
                    result = detectBallAndRimClientSide(ctx, canvas.width, canvas.height);
                    if (result) {
                        result.tracker = 'Client-side (fallback)';
                    }
                } else if (!result && API_BASE_URL) {
                    // Backend is available but didn't detect anything - that's OK, don't fallback
                    console.log('Backend active but no detection this frame (normal)');
                }
                
                // Store result for algorithm indicator
                if (result) {
                    latestDetectionResult = result;
                    updateAlgorithmIndicator();
                }
                
                if (result) {
                    // Use processed frame from ShotDetectorWeb if available (has yellow lines, corner rectangles, shot counter)
                    if (result.processed_frame) {
                        // Display the processed frame with all ShotDetectorWeb visualizations
                        const img = new Image();
                        img.onload = function() {
                            outputCtx.clearRect(0, 0, outputCanvas.width, outputCanvas.height);
                            outputCtx.drawImage(img, 0, 0, outputCanvas.width, outputCanvas.height);
                        };
                        img.src = 'data:image/jpeg;base64,' + result.processed_frame;
                    } else {
                        // Fallback: Draw detection results manually if processed_frame not available
                    outputCtx.clearRect(0, 0, outputCanvas.width, outputCanvas.height);
                    
                        // Draw ball bounding box if available (YOLOv8)
                        if (result.ball_box && result.ball_box.length === 4) {
                            const [x1, y1, x2, y2] = result.ball_box;
                            outputCtx.strokeStyle = '#00ff00';
                            outputCtx.lineWidth = 3;
                            outputCtx.strokeRect(x1, y1, x2 - x1, y2 - y1);
                            
                            // Draw label
                            outputCtx.fillStyle = '#00ff00';
                            outputCtx.font = '14px Arial';
                            outputCtx.fillText('Basketball', x1, y1 - 5);
                        } else if (result.ball_detected && result.ball_x > 0 && result.ball_y > 0) {
                            // Fallback to circle if no bounding box
                        outputCtx.strokeStyle = '#00ff00';
                        outputCtx.lineWidth = 3;
                        outputCtx.beginPath();
                        outputCtx.arc(result.ball_x, result.ball_y, Math.max(result.ball_radius, 10), 0, 2 * Math.PI);
                        outputCtx.stroke();
                        
                        // Draw ball center
                        outputCtx.fillStyle = '#00ff00';
                        outputCtx.beginPath();
                        outputCtx.arc(result.ball_x, result.ball_y, 5, 0, 2 * Math.PI);
                        outputCtx.fill();
                    }
                    
                        // Draw rim bounding box if available (YOLOv8)
                        if (result.rim_box && result.rim_box.length === 4) {
                            const [x1, y1, x2, y2] = result.rim_box;
                            outputCtx.strokeStyle = '#ff0000';
                            outputCtx.lineWidth = 3;
                            outputCtx.strokeRect(x1, y1, x2 - x1, y2 - y1);
                            
                            // Draw label
                            outputCtx.fillStyle = '#ff0000';
                            outputCtx.font = '14px Arial';
                            outputCtx.fillText('Basketball Hoop', x1, y1 - 5);
                        } else if ((result.rim_detected || result.rim_x > 0) && result.rim_y > 0) {
                            // Fallback to circle if no bounding box
                        outputCtx.strokeStyle = '#ff0000';
                        outputCtx.lineWidth = 3;
                        outputCtx.beginPath();
                        outputCtx.arc(result.rim_x, result.rim_y, Math.max(result.rim_radius, 20), 0, 2 * Math.PI);
                        outputCtx.stroke();
                        }
                    }
                    
                    // Handle shot result
                    if (result.shot_result) {
                        handleShotResult(result.shot_result);
                    }
                }
            } catch (error) {
                console.error('Error processing frame:', error);
            }
            
            // Update status with video progress
            if (videoAnalysisActive && !videoAnalysisPaused && video.duration) {
                const statusText = document.getElementById('analysisStatusText');
                const progress = ((video.currentTime / video.duration) * 100).toFixed(0);
                statusText.textContent = `Analyzing video... ${progress}%`;
            }
            
            // Continue processing
            if (videoAnalysisActive && !video.paused && !video.ended) {
                requestAnimationFrame(processUploadedVideoFrames);
            }
        }
        
        function pauseVideoAnalysis() {
            const video = document.getElementById('shotTrackerVideo');
            const pauseBtn = document.getElementById('pauseVideoAnalysis');
            const statusText = document.getElementById('analysisStatusText');
            
            if (videoAnalysisPaused) {
                videoAnalysisPaused = false;
                video.play();
                pauseBtn.textContent = 'Pause';
                statusText.textContent = 'Analyzing video...';
                processUploadedVideoFrames();
            } else {
                videoAnalysisPaused = true;
                video.pause();
                pauseBtn.textContent = 'Resume';
                statusText.textContent = 'Paused';
            }
        }
        
        function stopVideoAnalysis() {
            videoAnalysisActive = false;
            videoAnalysisPaused = false;
            
            const video = document.getElementById('shotTrackerVideo');
            const analyzeBtn = document.getElementById('analyzeUploadedVideo');
            const pauseBtn = document.getElementById('pauseVideoAnalysis');
            const statusDiv = document.getElementById('videoAnalysisStatus');
            const statusText = document.getElementById('analysisStatusText');
            
            video.pause();
            analyzeBtn.style.display = 'inline-block';
            pauseBtn.style.display = 'none';
            statusDiv.style.display = 'none';
            statusText.textContent = '';
            
            // Hide analysis indicator
            const indicator = document.getElementById('analysisIndicator');
            if (indicator) indicator.style.display = 'none';
            
            // Hide algorithm indicator
            const algoIndicator = document.getElementById('algorithmIndicator');
            if (algoIndicator) algoIndicator.style.display = 'none';
        }
        
        // Event listeners
        document.addEventListener('DOMContentLoaded', function() {
            const startBtn = document.getElementById('startShotTracker');
            const stopBtn = document.getElementById('stopShotTracker');
            const resetBtn = document.getElementById('resetShotTracker');
            const backBtn = document.getElementById('backToShotSyncFromTracker');
            const liveModeBtn = document.getElementById('shotTrackerLiveModeBtn');
            const uploadModeBtn = document.getElementById('shotTrackerUploadModeBtn');
            const videoUploadInput = document.getElementById('shotTrackerVideoUpload');
            const analyzeBtn = document.getElementById('analyzeUploadedVideo');
            const pauseBtn = document.getElementById('pauseVideoAnalysis');
            
            if (startBtn) startBtn.addEventListener('click', startShotTracker);
            if (stopBtn) stopBtn.addEventListener('click', stopShotTracker);
            if (resetBtn) resetBtn.addEventListener('click', resetShotTracker);
            if (backBtn) backBtn.addEventListener('click', () => {
                stopShotTracker();
                stopVideoAnalysis();
                showShotSync();
            });
            
            if (liveModeBtn) liveModeBtn.addEventListener('click', () => switchShotTrackerMode('live'));
            if (uploadModeBtn) uploadModeBtn.addEventListener('click', () => switchShotTrackerMode('upload'));
            
            // Handle video file upload - setup will be done in setupShotTrackerEventListeners
            // This ensures it works even when section is shown later
            
            if (analyzeBtn) analyzeBtn.addEventListener('click', analyzeUploadedVideo);
            if (pauseBtn) pauseBtn.addEventListener('click', pauseVideoAnalysis);
            
            // Handle video ended event
            const video = document.getElementById('shotTrackerVideo');
            if (video) {
                video.addEventListener('ended', () => {
                    if (videoAnalysisActive) {
                        stopVideoAnalysis();
                    }
                });
                
                video.addEventListener('play', () => {
                    if (videoAnalysisActive && !videoAnalysisPaused) {
                        lastProcessedTime = 0;
                        processUploadedVideoFrames();
                    }
                });
                
                // Also process on timeupdate for more reliable frame capture
                video.addEventListener('timeupdate', () => {
                    if (videoAnalysisActive && !videoAnalysisPaused && !video.ended) {
                        // This ensures we process frames even if requestAnimationFrame misses some
                        const now = Date.now();
                        if (now - lastProcessedTime >= FRAME_PROCESS_INTERVAL) {
                            // Trigger frame processing
                            requestAnimationFrame(processUploadedVideoFrames);
                        }
                    }
                });
            }
        });
        
        window.showShotTracker = showShotTracker;
        
        // ====================== PROGRESS PICS FUNCTIONALITY ======================
        
        // Storage key for progress pics
        const PROGRESS_PICS_STORAGE_KEY = 'shotSync_progressPics';
        
        // Escape HTML to prevent XSS
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // Load progress pics from localStorage
        function loadProgressPics() {
            const gallery = document.getElementById('progressPicsGallery');
            if (!gallery) return;
            
            const progressPics = getProgressPics();
            
            if (progressPics.length === 0) {
                gallery.innerHTML = '<p style="grid-column: 1 / -1; text-align: center; color: var(--text-gray); padding: 40px;">No progress pics yet. Upload your first photo to get started!</p>';
                return;
            }
            
            // Sort by date (newest first)
            progressPics.sort((a, b) => new Date(b.date) - new Date(a.date));
            
            gallery.innerHTML = progressPics.map((pic, index) => {
                const date = new Date(pic.date);
                const formattedDate = date.toLocaleDateString('en-US', { 
                    year: 'numeric', 
                    month: 'long', 
                    day: 'numeric' 
                });
                const formattedTime = date.toLocaleTimeString('en-US', { 
                    hour: '2-digit', 
                    minute: '2-digit' 
                });
                
                const captionDisplay = pic.caption && pic.caption.trim() ? 
                    `<div style="font-family: 'Bebas Neue', sans-serif; color: var(--text-dark); font-size: 14px; margin-top: 8px; padding-top: 8px; border-top: 1px solid #e2e8f0; font-weight: 500;">${escapeHtml(pic.caption.trim())}</div>` : '';
                
                return `
                    <div class="progress-pic-card" style="background: var(--bg-surface-light); border-radius: 12px; overflow: hidden; box-shadow: 0 2px 8px rgba(0,0,0,0.1); position: relative;">
                        <img src="${pic.dataUrl}" alt="Progress pic from ${formattedDate}" style="width: 100%; height: 250px; object-fit: cover; display: block;">
                        <div style="padding: 15px;">
                            <div style="font-weight: 600; color: var(--text-dark); margin-bottom: 5px;">${formattedDate}</div>
                            <div style="font-size: 12px; color: var(--text-gray);">${formattedTime}</div>
                            ${captionDisplay}
                        </div>
                        <button onclick="deleteProgressPic(${index})" style="position: absolute; top: 10px; right: 10px; background: rgba(255, 0, 0, 0.8); color: white; border: none; border-radius: 50%; width: 32px; height: 32px; cursor: pointer; font-size: 18px; display: flex; align-items: center; justify-content: center; transition: all 0.2s;" onmouseover="this.style.background='rgba(255, 0, 0, 1)'" onmouseout="this.style.background='rgba(255, 0, 0, 0.8)'" title="Delete photo">Ã—</button>
                    </div>
                `;
            }).join('');
        }
        
        // Get all progress pics from localStorage
        function getProgressPics() {
            try {
                const stored = localStorage.getItem(PROGRESS_PICS_STORAGE_KEY);
                return stored ? JSON.parse(stored) : [];
            } catch (e) {
                console.error('Error loading progress pics:', e);
                return [];
            }
        }
        
        // Save progress pics to localStorage
        function saveProgressPics(pics) {
            try {
                // Limit to last 100 pics to avoid localStorage size issues
                const limitedPics = pics.slice(-100);
                localStorage.setItem(PROGRESS_PICS_STORAGE_KEY, JSON.stringify(limitedPics));
            } catch (e) {
                console.error('Error saving progress pics:', e);
                if (e.name === 'QuotaExceededError') {
                    alert('Storage limit reached. Please delete some old photos to add new ones.');
                }
            }
        }
        
        // Add a new progress pic
        function addProgressPic(dataUrl, caption = '') {
            const progressPics = getProgressPics();
            progressPics.push({
                dataUrl: dataUrl,
                date: new Date().toISOString(),
                caption: caption || null
            });
            saveProgressPics(progressPics);
            loadProgressPics();
        }
        
        // Delete a progress pic
        function deleteProgressPic(index) {
            if (!confirm('Are you sure you want to delete this progress pic?')) {
                return;
            }
            
            const progressPics = getProgressPics();
            // Sort to match display order (newest first)
            progressPics.sort((a, b) => new Date(b.date) - new Date(a.date));
            progressPics.splice(index, 1);
            saveProgressPics(progressPics);
            loadProgressPics();
        }
        
        // Make deleteProgressPic available globally
        window.deleteProgressPic = deleteProgressPic;
        
        // Initialize progress pics upload handlers
        document.addEventListener('DOMContentLoaded', function() {
            const uploadInput = document.getElementById('progressPicUpload');
            const selectBtn = document.getElementById('selectProgressPicBtn');
            const previewDiv = document.getElementById('progressPicPreview');
            const previewImg = document.getElementById('previewImage');
            const saveBtn = document.getElementById('saveProgressPicBtn');
            const cancelBtn = document.getElementById('cancelProgressPicBtn');
            
            if (selectBtn && uploadInput) {
                selectBtn.addEventListener('click', () => {
                    uploadInput.click();
                });
            }
            
            if (uploadInput) {
                uploadInput.addEventListener('change', function(e) {
                    const file = e.target.files[0];
                    if (!file) return;
                    
                    // Validate file type
                    if (!file.type.startsWith('image/')) {
                        alert('Please select an image file.');
                        return;
                    }
                    
                    // Validate file size (max 5MB)
                    if (file.size > 5 * 1024 * 1024) {
                        alert('Image size must be less than 5MB. Please compress the image and try again.');
                        return;
                    }
                    
                    // Read file as data URL
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        if (previewImg) {
                            previewImg.src = e.target.result;
                        }
                        if (previewDiv) {
                            previewDiv.style.display = 'block';
                        }
                    };
                    reader.readAsDataURL(file);
                });
            }
            
            if (saveBtn) {
                saveBtn.addEventListener('click', function() {
                    const dataUrl = previewImg?.src;
                    if (dataUrl && dataUrl.startsWith('data:image/')) {
                        const captionInput = document.getElementById('progressPicCaption');
                        const caption = captionInput ? captionInput.value.trim() : '';
                        addProgressPic(dataUrl, caption);
                        // Reset form
                        if (uploadInput) uploadInput.value = '';
                        if (captionInput) captionInput.value = '';
                        if (previewDiv) previewDiv.style.display = 'none';
                        alert('Progress pic saved successfully! ðŸ“¸');
                    }
                });
            }
            
            if (cancelBtn) {
                cancelBtn.addEventListener('click', function() {
                    if (uploadInput) uploadInput.value = '';
                    const captionInput = document.getElementById('progressPicCaption');
                    if (captionInput) captionInput.value = '';
                    if (previewDiv) previewDiv.style.display = 'none';
                });
            }
        });
        window.goToHome = goToHome;
        window.handleGoogleSignInClick = handleGoogleSignInClick;
        window.handlePlayerPageSignInClick = handlePlayerPageSignInClick;
        
        // Nutrition page variables
        let nutritionChart = null;
        let currentChartType = 'calories';
        let currentTimePeriod = 7; // Default to 7 days
        let selectedDate = null; // Currently selected date from chart click
        
        // Load nutrition data
        async function loadNutrition() {
            const user = window.firebaseAuth?.currentUser;
            if (!user) {
                alert('Please sign in to use the nutrition tracker');
                return;
            }
            
            const userId = user.uid;
            
            // Load goals
            const goals = await window.getNutritionGoals(userId);
            document.getElementById('calorieGoal').value = goals.calorieGoal || 2000;
            document.getElementById('idealWeight').value = goals.idealWeight || 150;
            document.getElementById('proteinGoal').value = goals.proteinGoal || 150;
            
            // Load favorites
            await loadFavorites(userId);
            
            // Load daily log
            await loadDailyLog(userId);
            
            // Load and render chart
            await renderNutritionChart(userId);
        }
        
        // Save nutrition goals (local function for button click)
        async function saveNutritionGoalsLocal() {
            const user = window.firebaseAuth?.currentUser;
            if (!user) {
                alert('Please sign in to save goals');
                return;
            }
            
            const calorieGoal = parseFloat(document.getElementById('calorieGoal').value);
            const idealWeight = parseFloat(document.getElementById('idealWeight').value);
            const proteinGoal = parseFloat(document.getElementById('proteinGoal').value);
            
            if (!calorieGoal || !idealWeight || !proteinGoal) {
                alert('Please enter calorie goal, ideal weight, and protein goal');
                return;
            }
            
            const success = await window.saveNutritionGoals(user.uid, calorieGoal, idealWeight, proteinGoal);
            if (success) {
                alert('Goals saved successfully!');
                await renderNutritionChart(user.uid);
            } else {
                alert('Error saving goals');
            }
        }
        
        window.saveNutritionGoalsLocal = saveNutritionGoalsLocal;
        
        // Switch nutrition chart
        async function switchNutritionChart(type) {
            currentChartType = type;
            
            // Update tab styles
            document.querySelectorAll('.chart-tab').forEach(tab => tab.classList.remove('active'));
            if (type === 'calories') {
                document.getElementById('calorieChartTab').classList.add('active');
                document.getElementById('weightEntryForm').style.display = 'none';
            } else {
                document.getElementById('weightChartTab').classList.add('active');
                document.getElementById('weightEntryForm').style.display = 'block';
            }
            
            const user = window.firebaseAuth?.currentUser;
            if (user) {
                await renderNutritionChart(user.uid);
            }
        }
        
        // Add weight entry
        async function addWeightEntry() {
            const user = window.firebaseAuth?.currentUser;
            if (!user) {
                alert('Please sign in to add weight entry');
                return;
            }
            
            const weight = parseFloat(document.getElementById('weightInput').value);
            if (!weight || weight <= 0) {
                alert('Please enter a valid weight');
                return;
            }
            
            const success = await window.saveWeightEntry(user.uid, weight);
            if (success) {
                document.getElementById('weightInput').value = '';
                await renderNutritionChart(user.uid);
            } else {
                alert('Error adding weight entry');
            }
        }
        
        window.addWeightEntry = addWeightEntry;
        
        // Switch nutrition tab (tracker vs diet plans)
        function switchNutritionTab(tab) {
            const trackerTab = document.getElementById('nutritionTrackerTab');
            const dietPlansTab = document.getElementById('customDietPlansTab');
            
            if (tab === 'tracker') {
                document.getElementById('nutritionTrackerSection').style.display = 'block';
                document.getElementById('customDietPlansSection').style.display = 'none';
                
                // Update tab styles
                trackerTab.classList.add('active');
                trackerTab.style.borderBottom = '3px solid var(--primary-color)';
                trackerTab.style.color = 'var(--primary-color)';
                trackerTab.style.fontWeight = '600';
                
                dietPlansTab.classList.remove('active');
                dietPlansTab.style.borderBottom = '3px solid transparent';
                dietPlansTab.style.color = '#666';
                dietPlansTab.style.fontWeight = 'normal';
            } else if (tab === 'dietPlans') {
                document.getElementById('nutritionTrackerSection').style.display = 'none';
                document.getElementById('customDietPlansSection').style.display = 'block';
                
                // Update tab styles
                trackerTab.classList.remove('active');
                trackerTab.style.borderBottom = '3px solid transparent';
                trackerTab.style.color = '#666';
                trackerTab.style.fontWeight = 'normal';
                
                dietPlansTab.classList.add('active');
                dietPlansTab.style.borderBottom = '3px solid var(--primary-color)';
                dietPlansTab.style.color = 'var(--primary-color)';
                dietPlansTab.style.fontWeight = '600';
                
                // Load diet plans when switching to this tab
                const user = window.firebaseAuth?.currentUser;
                if (user) {
                    loadCustomDietPlans(user.uid);
                }
            }
        }
        
        window.switchNutritionTab = switchNutritionTab;
        
        // Custom Diet Plan Functions
        let editingDietPlanId = null;
        
        async function loadCustomDietPlans(userId) {
            try {
                const dietPlans = await window.getCustomDietPlans(userId);
                const container = document.getElementById('customDietPlansList');
                
                if (!container) {
                    console.error('customDietPlansList container not found');
                    return;
                }
                
                container.innerHTML = '';
                
                if (!dietPlans || dietPlans.length === 0) {
                    container.innerHTML = '<p style="text-align: center; color: #666; padding: 40px;">No custom diet plans yet. Create one to get started!</p>';
                    return;
                }
                
                console.log('Loading diet plans:', dietPlans);
                dietPlans.forEach((plan, idx) => {
                    console.log(`Plan ${idx}:`, {
                        id: plan.id,
                        name: plan.name,
                        mealsCount: plan.meals ? plan.meals.length : 0,
                        firstMeal: plan.meals && plan.meals[0] ? {
                            name: plan.meals[0].name,
                            food: plan.meals[0].food,
                            calories: plan.meals[0].calories
                        } : null
                    });
                });
                
                dietPlans.forEach(plan => {
                // Sort meals chronologically
                const sortedMeals = sortMealsChronologically(plan.meals || []);
                
                // Calculate totals
                const totals = calculateMealsTotals(plan.meals || []);
                
                const planDiv = document.createElement('div');
                planDiv.style.cssText = 'background: #f8f9fa; padding: 20px; border-radius: 8px; margin-bottom: 15px;';
                
                // Ensure plan name is displayed correctly
                const planName = (plan.name && plan.name.trim()) ? plan.name.trim() : 'Unnamed Diet Plan';
                const planDays = plan.days && Array.isArray(plan.days) && plan.days.length > 0 ? plan.days : [];
                const daysDisplay = planDays.length > 0 ? planDays.join(', ') : 'No days selected';
                console.log(`Displaying plan: "${planName}" with ${sortedMeals.length} meals on days: ${daysDisplay}`);
                
                planDiv.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 15px;">
                        <div>
                            <h3 style="font-family: \'Courier Prime\', monospace; margin: 0 0 10px 0; color: #1a1a1a; font-weight: 700; font-size: 20px;">${planName}</h3>
                            <div style="font-family: \'Courier Prime\', monospace; color: #666; font-size: 14px; margin-bottom: 5px;">
                                <strong>Total Calories:</strong> ${Math.round(totals.calories)} | <strong>Total Protein:</strong> ${Math.round(totals.protein * 10) / 10}g
                            </div>
                            <div style="font-family: \'Courier Prime\', monospace; color: #888; font-size: 13px;">
                                <strong>Days:</strong> ${daysDisplay}
                            </div>
                        </div>
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <label style="display: flex; align-items: center; cursor: pointer; font-family: 'Bebas Neue', sans-serif; font-size: 13px; color: #666;">
                                <input type="checkbox" id="dietPlanToggle-${plan.id}" ${planDays.length > 0 ? 'checked' : ''} onchange="toggleDietPlan('${plan.id}')" style="margin-right: 6px; width: 18px; height: 18px; cursor: pointer;">
                                <span id="dietPlanToggleLabel-${plan.id}">${planDays.length > 0 ? 'ON' : 'OFF'}</span>
                            </label>
                            <button onclick="editDietPlan('${plan.id}')" class="btn btn-secondary" style="padding: 5px 15px; margin-right: 5px;">Edit</button>
                            <button onclick="deleteDietPlan('${plan.id}')" class="btn" style="padding: 5px 15px; background: #ef4444; color: white;">Delete</button>
                        </div>
                    </div>
                    <div>
                        ${sortedMeals.length > 0 ? sortedMeals.map((meal, mealIdx) => {
                            // Explicitly get name and food - don't rely on field order
                            const mealName = (meal.name && typeof meal.name === 'string') ? meal.name.trim() : 'Unnamed Meal';
                            const mealFood = (meal.food && typeof meal.food === 'string' && meal.food.trim() && meal.food !== 'null' && meal.food !== mealName) ? meal.food.trim() : '';
                            
                            console.log(`Displaying meal ${mealIdx} in plan "${planName}":`, {
                                name: mealName,
                                food: mealFood,
                                hasName: !!meal.name,
                                hasFood: !!meal.food,
                                rawMeal: meal
                            });
                            
                            const timeDisplay = meal.time ? `<span style="color: var(--primary-color); font-weight: 600;">${formatTime(meal.time)}</span> - ` : '';
                            const foodDisplay = mealFood ? `<div style="color: #666; font-size: 13px; margin-top: 6px; font-style: italic; padding-left: 4px;">${mealFood}</div>` : '';
                            
                            return `
                                <div style="padding: 12px; background: white; border-radius: 4px; margin-bottom: 8px; font-family: \'Courier Prime\', monospace; border-left: 3px solid var(--primary-color);">
                                    <div style="display: flex; justify-content: space-between; align-items: flex-start;">
                                        <div style="flex: 1;">
                                            <div style="color: var(--text-dark); font-weight: 600;">
                                                ${timeDisplay}${mealName}
                                            </div>
                                            ${foodDisplay}
                                        </div>
                                        <div style="color: #666; font-size: 14px; margin-left: 15px; white-space: nowrap;">
                                            ${Math.round(meal.calories || 0)} cal | ${Math.round((meal.protein || 0) * 10) / 10}g protein
                                        </div>
                                    </div>
                                </div>
                            `;
                        }).join('') : '<p style="text-align: center; color: #666; padding: 20px;">No meals in this plan.</p>'}
                    </div>
                `;
                container.appendChild(planDiv);
            });
            } catch (error) {
                console.error('Error loading custom diet plans:', error);
                const container = document.getElementById('customDietPlansList');
                if (container) {
                    container.innerHTML = '<p style="text-align: center; color: #ef4444; padding: 40px;">Error loading diet plans. Please try again.</p>';
                }
            }
        }
        
        function sortMealsChronologically(meals) {
            return [...meals].sort((a, b) => {
                // If both have times, sort by time
                if (a.time && b.time) {
                    return a.time.localeCompare(b.time);
                }
                // If only one has time, put it first
                if (a.time && !b.time) return -1;
                if (!a.time && b.time) return 1;
                // If neither has time, maintain original order
                return 0;
            });
        }
        
        function calculateMealsTotals(meals) {
            return meals.reduce((totals, meal) => {
                totals.calories += (meal.calories || 0);
                totals.protein += (meal.protein || 0);
                return totals;
            }, { calories: 0, protein: 0 });
        }
        
        function formatTime(timeString) {
            // Convert "HH:MM" to "HH:MM AM/PM" format
            if (!timeString) return '';
            const [hours, minutes] = timeString.split(':');
            const hour = parseInt(hours);
            const ampm = hour >= 12 ? 'PM' : 'AM';
            const displayHour = hour % 12 || 12;
            return `${displayHour}:${minutes} ${ampm}`;
        }
        
        function showCreateDietPlanForm() {
            editingDietPlanId = null;
            document.getElementById('dietPlanFormTitle').textContent = 'Create Custom Diet Plan';
            document.getElementById('dietPlanName').value = '';
            document.getElementById('dietPlanMealsList').innerHTML = '';
            // Clear all day checkboxes
            const days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
            days.forEach(day => {
                const checkbox = document.getElementById(`dietPlanDay-${day}`);
                if (checkbox) checkbox.checked = false;
            });
            document.getElementById('createDietPlanForm').style.display = 'block';
            updateDietPlanTotals();
        }
        
        // Helper functions for time conversion
        function convert12to24(hour, minute, ampm) {
            if (!hour || !minute || !ampm) return null;
            let h24 = parseInt(hour);
            if (ampm === 'PM' && h24 !== 12) {
                h24 += 12;
            } else if (ampm === 'AM' && h24 === 12) {
                h24 = 0;
            }
            return `${String(h24).padStart(2, '0')}:${String(minute).padStart(2, '0')}`;
        }
        
        function convert24to12(time24) {
            if (!time24) return { hour: '', minute: '', ampm: 'AM' };
            const [hours, minutes] = time24.split(':');
            const hour = parseInt(hours);
            const ampm = hour >= 12 ? 'PM' : 'AM';
            const hour12 = hour % 12 || 12;
            return { hour: String(hour12), minute: minutes || '00', ampm: ampm };
        }
        
        // Make helper functions available globally
        window.convert12to24 = convert12to24;
        window.convert24to12 = convert24to12;
        
        function addMealToDietPlan() {
            const container = document.getElementById('dietPlanMealsList');
            const mealId = 'meal-' + Date.now();
            const mealDiv = document.createElement('div');
            mealDiv.style.cssText = 'padding: 15px; background: #f8f9fa; border-radius: 4px; margin-bottom: 15px;';
            mealDiv.innerHTML = `
                <div style="display: grid; grid-template-columns: 2fr 0.8fr 0.8fr 0.6fr 1fr 1fr 1fr auto; gap: 10px; align-items: end; margin-bottom: 10px;">
                    <input type="text" id="${mealId}-name" placeholder="Meal name (e.g., Breakfast)" style="padding: 8px; border: 2px solid #ddd; border-radius: 4px; font-family: \'Courier Prime\', monospace;" onchange="updateDietPlanTotals()">
                    <input type="number" id="${mealId}-hour" placeholder="Hour" min="1" max="12" style="padding: 8px; border: 2px solid #ddd; border-radius: 4px; font-family: \'Courier Prime\', monospace;" onchange="updateDietPlanTotals()">
                    <input type="number" id="${mealId}-minute" placeholder="Min" min="0" max="59" step="1" style="padding: 8px; border: 2px solid #ddd; border-radius: 4px; font-family: \'Courier Prime\', monospace;" onchange="updateDietPlanTotals()">
                    <select id="${mealId}-ampm" style="padding: 8px; border: 2px solid #ddd; border-radius: 4px; font-family: \'Courier Prime\', monospace;" onchange="updateDietPlanTotals()">
                        <option value="AM">AM</option>
                        <option value="PM">PM</option>
                    </select>
                    <input type="number" id="${mealId}-calories" placeholder="Calories" min="0" style="padding: 8px; border: 2px solid #ddd; border-radius: 4px; font-family: \'Courier Prime\', monospace;" onchange="updateDietPlanTotals()" oninput="updateDietPlanTotals()">
                    <input type="number" id="${mealId}-protein" placeholder="Protein (g)" min="0" step="0.1" style="padding: 8px; border: 2px solid #ddd; border-radius: 4px; font-family: \'Courier Prime\', monospace;" onchange="updateDietPlanTotals()" oninput="updateDietPlanTotals()">
                    <input type="number" id="${mealId}-servings" placeholder="Servings" min="0.1" step="0.1" value="1" style="padding: 8px; border: 2px solid #ddd; border-radius: 4px; font-family: \'Courier Prime\', monospace;" onchange="updateDietPlanTotals()" oninput="updateDietPlanTotals()">
                    <button onclick="this.parentElement.parentElement.remove(); updateDietPlanTotals();" class="btn" style="padding: 8px 12px; background: #ef4444; color: white;">Remove</button>
                </div>
                <input type="text" id="${mealId}-food" placeholder="Food items (e.g., 2 eggs, 1 cup rice, chicken breast)" style="width: 100%; padding: 8px; border: 2px solid #ddd; border-radius: 4px; font-family: \'Courier Prime\', monospace; font-size: 13px;">
            `;
            container.appendChild(mealDiv);
        }
        
        function updateDietPlanTotals() {
            const mealDivs = document.querySelectorAll('#dietPlanMealsList > div');
            let totalCalories = 0;
            let totalProtein = 0;
            
            mealDivs.forEach(div => {
                // Extract mealId from name input
                const nameInput = div.querySelector('input[id$="-name"]');
                const mealId = nameInput ? nameInput.id.replace('-name', '') : '';
                if (!mealId) return;
                
                const caloriesInput = document.getElementById(`${mealId}-calories`);
                const proteinInput = document.getElementById(`${mealId}-protein`);
                const servingsInput = document.getElementById(`${mealId}-servings`);
                
                const calories = caloriesInput ? parseFloat(caloriesInput.value) || 0 : 0;
                const protein = proteinInput ? parseFloat(proteinInput.value) || 0 : 0;
                const servings = servingsInput ? parseFloat(servingsInput.value) || 1 : 1;
                
                totalCalories += calories * servings;
                totalProtein += protein * servings;
            });
            
            document.getElementById('dietPlanTotalCalories').textContent = Math.round(totalCalories);
            document.getElementById('dietPlanTotalProtein').textContent = Math.round(totalProtein * 10) / 10;
        }
        
        async function saveDietPlan() {
            const user = window.firebaseAuth?.currentUser;
            if (!user) {
                alert('Please sign in to save diet plan');
                return;
            }
            
            const name = document.getElementById('dietPlanName').value.trim();
            if (!name) {
                alert('Please enter a diet plan name');
                return;
            }
            
            const meals = [];
            const mealDivs = document.querySelectorAll('#dietPlanMealsList > div');
            mealDivs.forEach((div, index) => {
                // The structure is:
                // div (meal container)
                //   - div (grid row) with: name, hour, minute, ampm, calories, protein, servings, remove button
                //   - input (food field) outside the grid
                
                // Find the grid row div first
                const gridRow = div.querySelector('div[style*="grid-template-columns"]');
                if (!gridRow) {
                    console.error(`Meal ${index} - No grid row found`);
                    return;
                }
                
                // Get the name input from the grid row - it's the ONLY text input in the grid row
                // The food input is outside the grid row, so we can safely get the first text input
                const allTextInputs = gridRow.querySelectorAll('input[type="text"]');
                let nameInput = null;
                
                // Find the input that ends with "-name" (should be the only one)
                for (let input of allTextInputs) {
                    if (input.id && input.id.endsWith('-name')) {
                        nameInput = input;
                        break;
                    }
                }
                
                // Fallback: if no input with "-name" found, get the first text input (should be name)
                if (!nameInput && allTextInputs.length > 0) {
                    nameInput = allTextInputs[0];
                    console.warn(`Meal ${index} - Using first text input as name (ID doesn't end with "-name"):`, nameInput.id);
                }
                
                if (!nameInput || !nameInput.id) {
                    console.error(`Meal ${index} - Name input not found in grid row`);
                    console.error('Grid row inputs:', Array.from(gridRow.querySelectorAll('input')).map(i => ({id: i.id, type: i.type, placeholder: i.placeholder})));
                    return;
                }
                
                // Verify it's not the food field (food field ID ends with "-food")
                if (nameInput.id.endsWith('-food')) {
                    console.error(`Meal ${index} - ERROR: Found food input instead of name input! ID:`, nameInput.id);
                    return;
                }
                
                const mealId = nameInput.id.replace('-name', '');
                
                if (!mealId) {
                    console.error(`Meal ${index} - Invalid mealId from name input:`, nameInput.id);
                    return;
                }
                
                console.log(`Meal ${index} - Found name input:`, {
                    id: nameInput.id,
                    value: nameInput.value,
                    placeholder: nameInput.placeholder,
                    mealId: mealId
                });
                
                const hourInput = document.getElementById(`${mealId}-hour`);
                const minuteInput = document.getElementById(`${mealId}-minute`);
                const ampmSelect = document.getElementById(`${mealId}-ampm`);
                const caloriesInput = document.getElementById(`${mealId}-calories`);
                const proteinInput = document.getElementById(`${mealId}-protein`);
                const servingsInput = document.getElementById(`${mealId}-servings`);
                const foodInput = document.getElementById(`${mealId}-food`);
                
                if (!caloriesInput || !proteinInput) {
                    console.error(`Meal ${index} is missing required fields. mealId: ${mealId}`);
                    console.error('Found inputs:', {
                        hour: !!hourInput,
                        minute: !!minuteInput,
                        calories: !!caloriesInput,
                        protein: !!proteinInput,
                        servings: !!servingsInput,
                        food: !!foodInput
                    });
                    return;
                }
                
                let mealName = nameInput.value.trim();
                const hour = hourInput ? hourInput.value.trim() : '';
                const minute = minuteInput ? minuteInput.value.trim() : '';
                const ampm = ampmSelect ? ampmSelect.value : 'AM';
                const calories = parseFloat(caloriesInput.value);
                const protein = parseFloat(proteinInput.value);
                const servings = servingsInput ? parseFloat(servingsInput.value) || 1 : 1;
                const food = foodInput ? foodInput.value.trim() : '';
                
                // CRITICAL: Double-check that we didn't accidentally read the food field
                // If mealName matches the food value and food is not empty, something is wrong
                if (food && mealName === food && nameInput.id.endsWith('-name')) {
                    console.error(`CRITICAL ERROR: Meal ${index} - Meal name appears to be the food value!`);
                    console.error('Name input ID:', nameInput.id);
                    console.error('Name input value:', mealName);
                    console.error('Food input value:', food);
                    // Don't use the food as name - set mealName to empty or a default
                    mealName = '';
                }
                
                // Convert 12-hour to 24-hour format
                const time24 = (hour && minute && ampm) ? convert12to24(hour, minute, ampm) : null;
                
                // Debug logging
                console.log(`Meal ${index}:`, {
                    mealId: mealId,
                    nameInputId: nameInput.id,
                    nameInputValue: nameInput.value,
                    mealName: mealName,
                    foodInputId: foodInput ? foodInput.id : 'not found',
                    foodValue: food,
                    calories: calories,
                    protein: protein,
                    nameEndsWithName: nameInput.id.endsWith('-name'),
                    nameEndsWithFood: nameInput.id.endsWith('-food')
                });
                
                // Validate that mealName is not the same as food (to catch mix-ups)
                if (mealName === food && mealName) {
                    console.warn(`WARNING: Meal ${index} name and food are the same! This might indicate a bug.`);
                    console.warn('This could mean the wrong input field was read. Check the IDs above.');
                }
                
                if (mealName && !isNaN(calories) && !isNaN(protein)) {
                    const mealData = {
                        name: mealName,
                        time: time24,
                        food: food || null,
                        calories: calories * servings,
                        protein: protein * servings
                    };
                    console.log('Saving meal:', mealData);
                    meals.push(mealData);
                } else {
                    console.warn(`Skipping meal ${index} - missing required fields:`, { mealName, calories, protein });
                }
            });
            
            console.log('Total meals to save:', meals.length);
            console.log('Diet plan name:', name);
            
            if (meals.length === 0) {
                alert('Please add at least one meal');
                return;
            }
            
            // Validate the data before saving
            console.log('Validating diet plan data before save:');
            console.log('Plan name:', name);
            console.log('Number of meals:', meals.length);
            meals.forEach((meal, idx) => {
                console.log(`  Meal ${idx}:`, {
                    name: meal.name,
                    food: meal.food,
                    hasName: !!meal.name,
                    hasFood: !!meal.food,
                    nameLength: meal.name ? meal.name.length : 0,
                    foodLength: meal.food ? meal.food.length : 0
                });
            });
            
            // Get selected days
            const selectedDays = [];
            const days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
            days.forEach(day => {
                const checkbox = document.getElementById(`dietPlanDay-${day}`);
                if (checkbox && checkbox.checked) {
                    selectedDays.push(day);
                }
            });
            
            const dietPlanData = { name: name.trim(), meals, days: selectedDays };
            console.log('Full diet plan data to save:', JSON.stringify(dietPlanData, null, 2));
            
            try {
                let success = false;
                if (editingDietPlanId) {
                    console.log('Updating existing diet plan:', editingDietPlanId);
                    success = await window.updateCustomDietPlan(editingDietPlanId, dietPlanData);
                } else {
                    console.log('Creating new diet plan');
                    success = await window.saveCustomDietPlan(user.uid, dietPlanData);
                }
                
                if (success) {
                    console.log('Diet plan saved successfully!');
                    document.getElementById('createDietPlanForm').style.display = 'none';
                    // Clear the form
                    document.getElementById('dietPlanName').value = '';
                    document.getElementById('dietPlanMealsList').innerHTML = '';
                    await loadCustomDietPlans(user.uid);
                } else {
                    alert('Error saving diet plan. Please check the console for details.');
                }
            } catch (error) {
                console.error('Error saving diet plan:', error);
                alert('Error saving diet plan: ' + (error.message || 'Unknown error'));
            }
        }
        
        async function editDietPlan(dietPlanId) {
            const user = window.firebaseAuth?.currentUser;
            if (!user) return;
            
            const dietPlans = await window.getCustomDietPlans(user.uid);
            const dietPlan = dietPlans.find(p => p.id === dietPlanId);
            if (!dietPlan) return;
            
            editingDietPlanId = dietPlanId;
            document.getElementById('dietPlanFormTitle').textContent = 'Edit Custom Diet Plan';
            document.getElementById('dietPlanName').value = dietPlan.name || '';
            document.getElementById('dietPlanMealsList').innerHTML = '';
            
            // Set day checkboxes
            const days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
            const planDays = dietPlan.days && Array.isArray(dietPlan.days) ? dietPlan.days : [];
            days.forEach(day => {
                const checkbox = document.getElementById(`dietPlanDay-${day}`);
                if (checkbox) {
                    checkbox.checked = planDays.includes(day);
                }
            });
            
            dietPlan.meals.forEach(meal => {
                const mealId = 'meal-' + Date.now() + '-' + Math.random();
                const mealDiv = document.createElement('div');
                mealDiv.style.cssText = 'padding: 15px; background: #f8f9fa; border-radius: 4px; margin-bottom: 15px;';
                
                // Calculate per-serving values (default to 1 serving if not stored)
                const servings = meal.servings || 1;
                const caloriesPerServing = meal.calories / servings;
                const proteinPerServing = meal.protein / servings;
                
                // Convert 24-hour time to 12-hour format for display
                const time12 = convert24to12(meal.time || '');
                
                mealDiv.innerHTML = `
                    <div style="display: grid; grid-template-columns: 2fr 0.8fr 0.8fr 0.6fr 1fr 1fr 1fr auto; gap: 10px; align-items: end; margin-bottom: 10px;">
                        <input type="text" id="${mealId}-name" value="${meal.name || ''}" style="padding: 8px; border: 2px solid #ddd; border-radius: 4px; font-family: \'Courier Prime\', monospace;" onchange="updateDietPlanTotals()">
                        <input type="number" id="${mealId}-hour" value="${time12.hour}" placeholder="Hour" min="1" max="12" style="padding: 8px; border: 2px solid #ddd; border-radius: 4px; font-family: \'Courier Prime\', monospace;" onchange="updateDietPlanTotals()">
                        <input type="number" id="${mealId}-minute" value="${time12.minute}" placeholder="Min" min="0" max="59" step="1" style="padding: 8px; border: 2px solid #ddd; border-radius: 4px; font-family: \'Courier Prime\', monospace;" onchange="updateDietPlanTotals()">
                        <select id="${mealId}-ampm" style="padding: 8px; border: 2px solid #ddd; border-radius: 4px; font-family: \'Courier Prime\', monospace;" onchange="updateDietPlanTotals()">
                            <option value="AM" ${time12.ampm === 'AM' ? 'selected' : ''}>AM</option>
                            <option value="PM" ${time12.ampm === 'PM' ? 'selected' : ''}>PM</option>
                        </select>
                        <input type="number" id="${mealId}-calories" value="${caloriesPerServing}" placeholder="Calories" min="0" style="padding: 8px; border: 2px solid #ddd; border-radius: 4px; font-family: \'Courier Prime\', monospace;" onchange="updateDietPlanTotals()" oninput="updateDietPlanTotals()">
                        <input type="number" id="${mealId}-protein" value="${proteinPerServing}" placeholder="Protein (g)" min="0" step="0.1" style="padding: 8px; border: 2px solid #ddd; border-radius: 4px; font-family: \'Courier Prime\', monospace;" onchange="updateDietPlanTotals()" oninput="updateDietPlanTotals()">
                        <input type="number" id="${mealId}-servings" value="${servings}" placeholder="Servings" min="0.1" step="0.1" style="padding: 8px; border: 2px solid #ddd; border-radius: 4px; font-family: \'Courier Prime\', monospace;" onchange="updateDietPlanTotals()" oninput="updateDietPlanTotals()">
                        <button onclick="this.parentElement.parentElement.remove(); updateDietPlanTotals();" class="btn" style="padding: 8px 12px; background: #ef4444; color: white;">Remove</button>
                    </div>
                    <input type="text" id="${mealId}-food" value="${meal.food || ''}" placeholder="Food items (e.g., 2 eggs, 1 cup rice, chicken breast)" style="width: 100%; padding: 8px; border: 2px solid #ddd; border-radius: 4px; font-family: \'Courier Prime\', monospace; font-size: 13px;">
                `;
                document.getElementById('dietPlanMealsList').appendChild(mealDiv);
            });
            
            document.getElementById('createDietPlanForm').style.display = 'block';
            updateDietPlanTotals();
        }
        
        async function deleteDietPlan(dietPlanId) {
            if (!confirm('Are you sure you want to delete this diet plan?')) return;
            
            const success = await window.deleteCustomDietPlan(dietPlanId);
            if (success) {
                const user = window.firebaseAuth?.currentUser;
                if (user) await loadCustomDietPlans(user.uid);
            } else {
                alert('Error deleting diet plan');
            }
        }
        
        window.showCreateDietPlanForm = showCreateDietPlanForm;
        window.addMealToDietPlan = addMealToDietPlan;
        window.updateDietPlanTotals = updateDietPlanTotals;
        window.saveDietPlan = saveDietPlan;
        window.editDietPlan = editDietPlan;
        window.deleteDietPlan = deleteDietPlan;
        
        // Toggle diet plan on/off
        async function toggleDietPlan(planId) {
            const user = window.firebaseAuth?.currentUser;
            if (!user) return;
            
            const dietPlans = await window.getCustomDietPlans(user.uid);
            const plan = dietPlans.find(p => p.id === planId);
            if (!plan) return;
            
            const checkbox = document.getElementById(`dietPlanToggle-${planId}`);
            const label = document.getElementById(`dietPlanToggleLabel-${planId}`);
            
            let newDays = [];
            if (checkbox.checked) {
                // Turning ON: if no days were set, default to all days
                if (!plan.days || plan.days.length === 0) {
                    newDays = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
                } else {
                    newDays = plan.days; // Keep existing days
                }
                label.textContent = 'ON';
            } else {
                // Turning OFF: clear days (store previous days in a hidden field for potential restore)
                newDays = [];
                label.textContent = 'OFF';
            }
            
            // Update only the days field
            const success = await window.updateCustomDietPlan(planId, {
                name: plan.name,
                meals: plan.meals,
                days: newDays
            });
            
            if (success) {
                await loadCustomDietPlans(user.uid);
                // Reload schedule if we're on that tab
                const user2 = window.firebaseAuth?.currentUser;
                if (user2) await loadWeeklySchedule(user2.uid);
            }
        }
        
        window.toggleDietPlan = toggleDietPlan;
        
        // Switch time period
        async function switchTimePeriod(days, buttonElement) {
            currentTimePeriod = days;
            
            // Update tab styles
            document.querySelectorAll('.period-tab').forEach(tab => tab.classList.remove('active'));
            if (buttonElement) {
                buttonElement.classList.add('active');
            } else {
                // Fallback: find button by data-days attribute
                const button = document.querySelector(`.period-tab[data-days="${days}"]`);
                if (button) button.classList.add('active');
            }
            
            const user = window.firebaseAuth?.currentUser;
            if (user) {
                await renderNutritionChart(user.uid);
            }
        }
        
        // Render nutrition chart
        async function renderNutritionChart(userId) {
            const ctx = document.getElementById('nutritionChart').getContext('2d');
            
            if (nutritionChart) {
                nutritionChart.destroy();
            }
            
            // Calculate date range based on current time period
            const endDate = new Date();
            endDate.setHours(23, 59, 59, 999); // End of today
            const startDate = new Date();
            startDate.setDate(startDate.getDate() - currentTimePeriod);
            startDate.setHours(0, 0, 0, 0); // Start of day
            
            if (currentChartType === 'calories') {
                // Load calorie data
                const entries = await window.getAllNutritionEntries(userId);
                const goals = await window.getNutritionGoals(userId);
                const calorieGoal = goals.calorieGoal || 2000;
                
                // Group by date and sum calories, filtering by time period
                // Calculate total calories: servings Ã— calories per serving
                const dailyCalories = {};
                entries.forEach(entry => {
                    const entryDate = entry.createdAt?.toDate ? entry.createdAt.toDate() : new Date();
                    // Filter by time period
                    if (entryDate >= startDate && entryDate <= endDate) {
                        const date = entryDate.toDateString();
                        if (!dailyCalories[date]) {
                            dailyCalories[date] = 0;
                        }
                        // Calculate total: multiply servings Ã— calories per serving
                        const caloriesPerServing = entry.caloriesPerServing !== undefined 
                            ? entry.caloriesPerServing 
                            : (entry.servings > 0 ? entry.calories / entry.servings : entry.calories);
                        const totalCalories = caloriesPerServing * (entry.servings || 1);
                        dailyCalories[date] += totalCalories;
                    }
                });
                
                // Sort dates chronologically (oldest to newest)
                const dates = Object.keys(dailyCalories).sort((a, b) => {
                    return new Date(a) - new Date(b);
                });
                const calories = dates.map(date => dailyCalories[date]);
                
                // Store date mapping for onClick handler
                const dateLabels = dates.map(d => new Date(d).toLocaleDateString('en-US', { month: 'short', day: 'numeric' }));
                
                nutritionChart = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: dateLabels,
                        datasets: [{
                            label: 'Daily Calories',
                            data: calories,
                            borderColor: '#3b82f6',
                            backgroundColor: 'rgba(59, 130, 246, 0.7)',
                            borderWidth: 0,
                            borderRadius: 4,
                            borderSkipped: false,
                            categoryPercentage: 0.6,
                            barPercentage: 0.8
                        }, {
                            label: 'Calorie Goal',
                            data: dates.map(() => calorieGoal),
                            borderColor: '#ef4444',
                            backgroundColor: 'transparent',
                            borderDash: [8, 4],
                            borderWidth: 2.5,
                            type: 'line',
                            spanGaps: true,
                            pointRadius: 0,
                            pointHoverRadius: 0,
                            pointBorderWidth: 0,
                            fill: false,
                            tension: 0,
                            order: 0
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: true,
                        layout: {
                            padding: {
                                top: 10,
                                bottom: 10,
                                left: 10,
                                right: 10
                            }
                        },
                        plugins: {
                            legend: {
                                display: true,
                                position: 'top',
                                labels: {
                                    usePointStyle: true,
                                    padding: 15,
                                    font: {
                                        size: 12,
                                        family: "'Inter', sans-serif"
                                    }
                                }
                            },
                            title: {
                                display: true,
                                text: 'Daily Calorie Intake',
                                font: {
                                    family: "'Inter', sans-serif",
                                    size: 18,
                                    weight: '600'
                                },
                                padding: {
                                    bottom: 20
                                },
                                color: '#1f2937'
                            },
                            tooltip: {
                                backgroundColor: 'rgba(0, 0, 0, 0.8)',
                                padding: 12,
                                cornerRadius: 8,
                                titleFont: {
                                    size: 13,
                                    weight: '600'
                                },
                                bodyFont: {
                                    size: 12
                                },
                                displayColors: true
                            }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                max: Math.max(calorieGoal * 1.3, Math.max(...calories, calorieGoal) * 1.2),
                                title: {
                                    display: true,
                                    text: 'Calories',
                                    font: {
                                        size: 12,
                                        weight: '600',
                                        family: "'Inter', sans-serif"
                                    },
                                    color: '#4b5563',
                                    padding: {
                                        top: 10,
                                        bottom: 0
                                    }
                                },
                                grid: {
                                    color: 'rgba(0, 0, 0, 0.05)',
                                    drawBorder: false
                                },
                                ticks: {
                                    font: {
                                        size: 11,
                                        family: "'Inter', sans-serif"
                                    },
                                    color: '#6b7280',
                                    padding: 8
                                }
                            },
                            x: {
                                offset: false,
                                grid: {
                                    display: false,
                                    drawBorder: false
                                },
                                ticks: {
                                    font: {
                                        size: 11,
                                        family: "'Inter', sans-serif"
                                    },
                                    color: '#6b7280',
                                    padding: 10
                                }
                            }
                        },
                        interaction: {
                            intersect: false,
                            mode: 'index'
                        },
                        onClick: (event, elements) => {
                            if (elements.length > 0) {
                                const element = elements[0];
                                const datasetIndex = element.datasetIndex;
                                const index = element.index;
                                
                                // Only handle clicks on the bar dataset (not the goal line)
                                if (datasetIndex === 0 && dates[index]) {
                                    const clickedDateString = dates[index];
                                    selectedDate = clickedDateString;
                                    const user = window.firebaseAuth?.currentUser;
                                    if (user) {
                                        loadDailyLog(user.uid, clickedDateString);
                                        // Scroll to food log section
                                        const foodLogSection = document.querySelector('#dailyFoodLog').closest('div');
                                        if (foodLogSection) {
                                            foodLogSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
                                            // Highlight briefly
                                            foodLogSection.style.transition = 'box-shadow 0.3s ease';
                                            foodLogSection.style.boxShadow = '0 4px 16px rgba(239, 68, 68, 0.3)';
                                            setTimeout(() => {
                                                foodLogSection.style.boxShadow = '0 2px 8px rgba(0,0,0,0.1)';
                                            }, 2000);
                                        }
                                    }
                                }
                            }
                        }
                    }
                });
            } else {
                // Load weight data
                const entries = await window.getWeightEntries(userId);
                const goals = await window.getNutritionGoals(userId);
                const idealWeight = goals.idealWeight || 150;
                
                // Filter entries by time period and sort by date (oldest to newest)
                const filteredEntries = entries.filter(entry => {
                    const entryDate = entry.createdAt?.toDate ? entry.createdAt.toDate() : new Date();
                    return entryDate >= startDate && entryDate <= endDate;
                });
                
                const sortedEntries = filteredEntries.sort((a, b) => {
                    const dateA = a.createdAt?.toDate ? a.createdAt.toDate() : new Date();
                    const dateB = b.createdAt?.toDate ? b.createdAt.toDate() : new Date();
                    return dateA - dateB;
                });
                
                const dates = sortedEntries.map(e => {
                    const date = e.createdAt?.toDate ? e.createdAt.toDate() : new Date();
                    return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                });
                const weights = sortedEntries.map(e => e.weight);
                
                nutritionChart = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: dates,
                        datasets: [{
                            label: 'Weight (lbs)',
                            data: weights,
                            borderColor: '#10b981',
                            backgroundColor: 'rgba(16, 185, 129, 0.7)',
                            borderWidth: 0,
                            borderRadius: 4,
                            borderSkipped: false,
                            categoryPercentage: 0.6,
                            barPercentage: 0.8
                        }, {
                            label: 'Ideal Weight',
                            data: dates.map(() => idealWeight),
                            borderColor: '#ef4444',
                            backgroundColor: 'transparent',
                            borderDash: [8, 4],
                            borderWidth: 2.5,
                            type: 'line',
                            spanGaps: true,
                            pointRadius: 0,
                            pointHoverRadius: 0,
                            pointBorderWidth: 0,
                            fill: false,
                            tension: 0,
                            order: 0
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: true,
                        layout: {
                            padding: {
                                top: 10,
                                bottom: 10,
                                left: 10,
                                right: 10
                            }
                        },
                        plugins: {
                            legend: {
                                display: true,
                                position: 'top',
                                labels: {
                                    usePointStyle: true,
                                    padding: 15,
                                    font: {
                                        size: 12,
                                        family: "'Inter', sans-serif"
                                    }
                                }
                            },
                            title: {
                                display: true,
                                text: 'Weight Tracking',
                                font: {
                                    family: "'Inter', sans-serif",
                                    size: 18,
                                    weight: '600'
                                },
                                padding: {
                                    bottom: 20
                                },
                                color: '#1f2937'
                            },
                            tooltip: {
                                backgroundColor: 'rgba(0, 0, 0, 0.8)',
                                padding: 12,
                                cornerRadius: 8,
                                titleFont: {
                                    size: 13,
                                    weight: '600'
                                },
                                bodyFont: {
                                    size: 12
                                },
                                displayColors: true
                            }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                max: Math.max(idealWeight * 1.3, Math.max(...weights, idealWeight) * 1.2),
                                title: {
                                    display: true,
                                    text: 'Weight (lbs)',
                                    font: {
                                        size: 12,
                                        weight: '600',
                                        family: "'Inter', sans-serif"
                                    },
                                    color: '#4b5563',
                                    padding: {
                                        top: 10,
                                        bottom: 0
                                    }
                                },
                                grid: {
                                    color: 'rgba(0, 0, 0, 0.05)',
                                    drawBorder: false
                                },
                                ticks: {
                                    font: {
                                        size: 11,
                                        family: "'Inter', sans-serif"
                                    },
                                    color: '#6b7280',
                                    padding: 8
                                }
                            },
                            x: {
                                offset: false,
                                grid: {
                                    display: false,
                                    drawBorder: false
                                },
                                ticks: {
                                    font: {
                                        size: 11,
                                        family: "'Inter', sans-serif"
                                    },
                                    color: '#6b7280',
                                    padding: 10
                                }
                            }
                        },
                        interaction: {
                            intersect: false,
                            mode: 'index'
                        }
                    }
                });
            }
        }
        
        // Add food entry
        async function addFood() {
            const user = window.firebaseAuth?.currentUser;
            if (!user) {
                alert('Please sign in to add food');
                return;
            }
            
            const name = document.getElementById('foodName').value.trim();
            const servings = parseFloat(document.getElementById('foodServings').value);
            const calories = parseFloat(document.getElementById('foodCalories').value);
            const protein = parseFloat(document.getElementById('foodProtein').value);
            
            if (!name || !servings || !calories || protein === undefined) {
                alert('Please fill in all fields');
                return;
            }
            
            // Store per-serving values in database
            // We'll multiply by servings when calculating daily totals
            const foodData = {
                foodName: name,
                servings: servings,
                caloriesPerServing: calories,  // Calories per serving (not multiplied)
                proteinPerServing: protein,     // Protein per serving (not multiplied)
                // Also store totals for chart calculations
                calories: calories * servings,  // Total calories (for chart)
                protein: protein * servings     // Total protein (for chart)
            };
            
            const success = await window.saveFoodEntry(user.uid, foodData);
            if (success) {
                // Clear form
                document.getElementById('foodName').value = '';
                document.getElementById('foodServings').value = '';
                document.getElementById('foodCalories').value = '';
                document.getElementById('foodProtein').value = '';
                
                // Reload log and chart
                await loadDailyLog(user.uid);
                await renderNutritionChart(user.uid);
            } else {
                alert('Error adding food');
            }
        }
        
        // Add favorite food
        async function addFavorite() {
            const user = window.firebaseAuth?.currentUser;
            if (!user) {
                alert('Please sign in to add favorites');
                return;
            }
            
            const name = document.getElementById('favoriteFoodName').value.trim();
            const calories = parseFloat(document.getElementById('favoriteCalories').value);
            const protein = parseFloat(document.getElementById('favoriteProtein').value);
            
            if (!name || !calories || protein === undefined) {
                alert('Please fill in all fields');
                return;
            }
            
            const favoriteData = {
                name: name,
                caloriesPerServing: calories,
                proteinPerServing: protein
            };
            
            const success = await window.saveFavoriteFood(user.uid, favoriteData);
            if (success) {
                // Clear form
                document.getElementById('favoriteFoodName').value = '';
                document.getElementById('favoriteCalories').value = '';
                document.getElementById('favoriteProtein').value = '';
                
                // Reload favorites
                await loadFavorites(user.uid);
            } else {
                alert('Error saving favorite');
            }
        }
        
        // Load favorites
        async function loadFavorites(userId) {
            const favorites = await window.getFavoriteFoods(userId);
            const container = document.getElementById('favoritesList');
            container.innerHTML = '';
            
            if (favorites.length === 0) {
                container.innerHTML = '<p style="text-align: center; color: #666; padding: 20px;">No favorites yet. Add some above!</p>';
                return;
            }
            
            favorites.forEach((favorite, index) => {
                // Use index to create unique ID to avoid issues with special characters in food names
                const favoriteId = `fav-${index}`;
                const favoriteEntry = document.createElement('div');
                favoriteEntry.className = 'food-log-entry';
                favoriteEntry.style.background = '#f8f9fa';
                favoriteEntry.innerHTML = `
                    <div><strong>${favorite.name}</strong></div>
                    <div>
                        Servings: <input type="number" id="${favoriteId}" value="1" step="0.25" min="0" style="width: 80px; padding: 5px; border: 2px solid #ddd; border-radius: 4px; font-family: 'Bebas Neue', sans-serif;">
                    </div>
                    <div>Calories per serving: ${favorite.caloriesPerServing}</div>
                    <div>Protein per serving: ${favorite.proteinPerServing}g</div>
                    <div>
                        <button onclick="addFavoriteFoodById('${favoriteId}', '${favorite.name.replace(/'/g, "\\'")}', ${favorite.caloriesPerServing}, ${favorite.proteinPerServing})" class="btn" style="padding: 5px 15px; margin-right: 5px; background: #6b7280; color: white;">Add</button>
                        <button onclick="deleteFavoriteFoodById('${favorite.name.replace(/'/g, "\\'")}')" class="btn" style="padding: 5px 15px; background: #ef4444; color: white;">Delete</button>
                    </div>
                `;
                container.appendChild(favoriteEntry);
            });
        }
        
        // Delete favorite food (local function for button click)
        async function deleteFavoriteFoodById(favoriteName) {
            const user = window.firebaseAuth?.currentUser;
            if (!user) {
                alert('Please sign in to delete favorites');
                return;
            }
            
            if (!confirm(`Are you sure you want to delete "${favoriteName}" from favorites?`)) {
                return;
            }
            
            const success = await window.deleteFavoriteFood(user.uid, favoriteName);
            if (success) {
                await loadFavorites(user.uid);
            } else {
                alert('Error deleting favorite');
            }
        }
        
        window.deleteFavoriteFoodById = deleteFavoriteFoodById;
        
        // Add favorite food with servings (by ID)
        async function addFavoriteFoodById(favoriteId, name, caloriesPerServing, proteinPerServing) {
            const user = window.firebaseAuth?.currentUser;
            if (!user) return;
            
            const servingsInput = document.getElementById(favoriteId);
            const servings = parseFloat(servingsInput.value) || 1;
            
            // Store per-serving values, and also calculate totals for chart
            const totalCalories = caloriesPerServing * servings;
            const totalProtein = proteinPerServing * servings;
            
            const foodData = {
                foodName: name,
                servings: servings,
                caloriesPerServing: caloriesPerServing,  // Store per-serving values
                proteinPerServing: proteinPerServing,    // Store per-serving values
                calories: totalCalories,  // Total calories (for chart calculations)
                protein: totalProtein      // Total protein (for chart calculations)
            };
            
            const success = await window.saveFoodEntry(user.uid, foodData);
            if (success) {
                servingsInput.value = '1';  // Reset to 1 instead of empty
                await loadDailyLog(user.uid);
                await renderNutritionChart(user.uid);
            }
        }
        
        // Legacy function for backwards compatibility
        async function addFavoriteFood(name, caloriesPerServing, proteinPerServing) {
            // Try to find the input by searching for it
            const inputs = document.querySelectorAll('input[type="number"]');
            for (const input of inputs) {
                if (input.id && input.id.startsWith('fav-')) {
                    const entry = input.closest('.food-log-entry');
                    if (entry && entry.querySelector('strong').textContent === name) {
                        await addFavoriteFoodById(input.id, name, caloriesPerServing, proteinPerServing);
                        return;
                    }
                }
            }
        }
        
        // Load daily food log
        async function loadDailyLog(userId, targetDate = null) {
            const container = document.getElementById('dailyFoodLog');
            const titleEl = document.getElementById('foodLogTitle');
            container.innerHTML = '';
            
            // Use targetDate if provided, otherwise use today or selectedDate
            const dateToLoad = targetDate || selectedDate || new Date().toDateString();
            
            // Update title based on date
            if (titleEl) {
                const dateObj = new Date(dateToLoad);
                const today = new Date().toDateString();
                const yesterday = new Date();
                yesterday.setDate(yesterday.getDate() - 1);
                
                if (dateToLoad === today) {
                    titleEl.textContent = "Today's Food Log";
                } else if (dateToLoad === yesterday.toDateString()) {
                    titleEl.textContent = "Yesterday's Food Log";
                } else {
                    titleEl.textContent = dateObj.toLocaleDateString('en-US', { weekday: 'long', month: 'long', day: 'numeric', year: 'numeric' }) + " Food Log";
                }
            }
            
            // Get entries for the specific date
            const entries = await window.getNutritionEntries(userId, dateToLoad);
            
            if (entries.length === 0) {
                const dateObj = new Date(dateToLoad);
                const today = new Date().toDateString();
                if (dateToLoad === today) {
                    container.innerHTML = '<p style="text-align: center; color: #666; padding: 20px;">No food entries for today</p>';
                } else {
                    container.innerHTML = `<p style="text-align: center; color: #666; padding: 20px;">No food entries for ${dateObj.toLocaleDateString('en-US', { month: 'long', day: 'numeric', year: 'numeric' })}</p>`;
                }
            } else {
                entries.forEach(entry => {
                    const entryDiv = document.createElement('div');
                    entryDiv.className = 'food-log-entry';
                    entryDiv.id = `entry-${entry.id}`;
                    
                    // Display per-serving values in the log (not multiplied)
                    // Calculate per-serving from stored data
                    const caloriesPerServing = entry.caloriesPerServing !== undefined 
                        ? entry.caloriesPerServing 
                        : (entry.servings > 0 ? entry.calories / entry.servings : entry.calories);
                    const proteinPerServing = entry.proteinPerServing !== undefined 
                        ? entry.proteinPerServing 
                        : (entry.servings > 0 ? entry.protein / entry.servings : entry.protein);
                    
                    entryDiv.innerHTML = `
                        <div><strong>${entry.foodName}</strong></div>
                        <div>Servings: <span id="servings-${entry.id}">${entry.servings}</span></div>
                        <div>Calories: <span id="calories-${entry.id}">${caloriesPerServing.toFixed(0)}</span></div>
                        <div>Protein: <span id="protein-${entry.id}">${proteinPerServing.toFixed(1)}g</span></div>
                        <div>
                            <button onclick="editFoodEntry('${entry.id}')" class="btn btn-secondary" style="padding: 5px 15px; margin-right: 5px;">Edit</button>
                            <button onclick="deleteFoodEntry('${entry.id}')" class="btn" style="padding: 5px 15px; background: #ef4444; color: white;">Delete</button>
                        </div>
                    `;
                    container.appendChild(entryDiv);
                });
            }
            
            // Calculate and display totals
            // Multiply servings Ã— calories per serving and servings Ã— protein per serving for daily totals
            const totalCalories = entries.reduce((sum, e) => {
                const caloriesPerServing = e.caloriesPerServing !== undefined 
                    ? e.caloriesPerServing 
                    : (e.servings > 0 ? e.calories / e.servings : e.calories);
                return sum + (caloriesPerServing * (e.servings || 1));
            }, 0);
            
            const totalProtein = entries.reduce((sum, e) => {
                const proteinPerServing = e.proteinPerServing !== undefined 
                    ? e.proteinPerServing 
                    : (e.servings > 0 ? e.protein / e.servings : e.protein);
                return sum + (proteinPerServing * (e.servings || 1));
            }, 0);
            
            const goals = await window.getNutritionGoals(userId);
            const calorieGoal = goals.calorieGoal || 2000;
            const proteinGoal = goals.proteinGoal || 150;
            
            const totalsContainer = document.getElementById('dailyTotals');
            totalsContainer.innerHTML = `
                <div style="text-align: center;">
                    <div style="font-size: 24px; font-weight: 700; color: #333; font-family: 'Bebas Neue', sans-serif;">${totalCalories.toFixed(0)}</div>
                    <div style="color: #666; font-size: 14px;">Calories</div>
                    <div style="color: ${totalCalories > calorieGoal ? '#ef4444' : '#10b981'}; font-size: 12px; margin-top: 5px;">
                        ${totalCalories > calorieGoal ? `+${(totalCalories - calorieGoal).toFixed(0)} over goal` : `${(calorieGoal - totalCalories).toFixed(0)} remaining`}
                    </div>
                </div>
                <div style="text-align: center;">
                    <div style="font-size: 24px; font-weight: 700; color: #333; font-family: 'Bebas Neue', sans-serif;">${totalProtein.toFixed(1)}g</div>
                    <div style="color: #666; font-size: 14px;">Protein</div>
                    <div style="color: ${totalProtein > proteinGoal ? '#ef4444' : '#10b981'}; font-size: 12px; margin-top: 5px;">
                        ${totalProtein > proteinGoal ? `+${(totalProtein - proteinGoal).toFixed(1)}g over goal` : `${(proteinGoal - totalProtein).toFixed(1)}g remaining`}
                    </div>
                </div>
            `;
        }
        
        // Edit food entry
        function editFoodEntry(entryId) {
            const entryDiv = document.getElementById(`entry-${entryId}`);
            entryDiv.classList.add('editing');
            
            const servings = parseFloat(document.getElementById(`servings-${entryId}`).textContent);
            // These are already per-serving values in the display
            const caloriesPerServing = parseFloat(document.getElementById(`calories-${entryId}`).textContent);
            const proteinPerServing = parseFloat(document.getElementById(`protein-${entryId}`).textContent.replace('g', ''));
            const foodName = entryDiv.querySelector('strong').textContent;
            
            entryDiv.innerHTML = `
                <div><strong>${foodName}</strong></div>
                <div>
                    Servings: <input type="number" id="edit-servings-${entryId}" value="${servings}" step="0.25" min="0" style="width: 80px; padding: 5px; border: 2px solid #ddd; border-radius: 4px;">
                </div>
                <div>
                    Calories per serving: <input type="number" id="edit-calories-${entryId}" value="${caloriesPerServing.toFixed(0)}" min="0" style="width: 80px; padding: 5px; border: 2px solid #ddd; border-radius: 4px;">
                </div>
                <div>
                    Protein per serving (g): <input type="number" id="edit-protein-${entryId}" value="${proteinPerServing.toFixed(1)}" min="0" step="0.1" style="width: 80px; padding: 5px; border: 2px solid #ddd; border-radius: 4px;">
                </div>
                <div>
                    <button onclick="saveFoodEdit('${entryId}')" class="btn btn-primary" style="padding: 5px 15px; margin-right: 5px;">Save</button>
                    <button onclick="cancelFoodEdit('${entryId}')" class="btn btn-secondary" style="padding: 5px 15px;">Cancel</button>
                </div>
            `;
        }
        
        // Save food edit
        async function saveFoodEdit(entryId) {
            const user = window.firebaseAuth?.currentUser;
            if (!user) return;
            
            const servings = parseFloat(document.getElementById(`edit-servings-${entryId}`).value);
            const caloriesPerServing = parseFloat(document.getElementById(`edit-calories-${entryId}`).value);
            const proteinPerServing = parseFloat(document.getElementById(`edit-protein-${entryId}`).value);
            
            if (!servings || !caloriesPerServing || proteinPerServing === undefined) {
                alert('Please fill in all fields');
                return;
            }
            
            // Store per-serving values, and also calculate totals for chart
            const totalCalories = caloriesPerServing * servings;
            const totalProtein = proteinPerServing * servings;
            
            const foodData = {
                servings: servings,
                caloriesPerServing: caloriesPerServing,  // Store per-serving values
                proteinPerServing: proteinPerServing,    // Store per-serving values
                calories: totalCalories,  // Total calories (for chart calculations)
                protein: totalProtein      // Total protein (for chart calculations)
            };
            
            const success = await window.updateFoodEntry(entryId, foodData);
            if (success) {
                await loadDailyLog(user.uid);
                await renderNutritionChart(user.uid);
            } else {
                alert('Error updating food entry');
            }
        }
        
        // Cancel food edit
        async function cancelFoodEdit(entryId) {
            const user = window.firebaseAuth?.currentUser;
            if (!user) return;
            await loadDailyLog(user.uid);
        }
        
        // Delete food entry
        async function deleteFoodEntry(entryId) {
            if (!confirm('Are you sure you want to delete this food entry?')) {
                return;
            }
            
            const user = window.firebaseAuth?.currentUser;
            if (!user) return;
            
            const success = await window.deleteFoodEntryFromDB(entryId);
            if (success) {
                await loadDailyLog(user.uid);
                await renderNutritionChart(user.uid);
            } else {
                alert('Error deleting food entry');
            }
        }
        
        // Make functions globally available
        window.addFood = addFood;
        window.addFavorite = addFavorite;
        window.addFavoriteFood = addFavoriteFood;
        window.addFavoriteFoodById = addFavoriteFoodById;
        window.switchNutritionChart = switchNutritionChart;
        window.switchTimePeriod = switchTimePeriod;
        window.editFoodEntry = editFoodEntry;
        window.saveFoodEdit = saveFoodEdit;
        window.cancelFoodEdit = cancelFoodEdit;
        window.deleteFoodEntry = deleteFoodEntry;
        
        // Workouts functions
        let currentWorkoutTab = 'schedule';
        let editingGymWorkoutId = null;
        let editingSportsWorkoutId = null;
        let selectedDayForSchedule = null;
        
        async function loadWorkouts() {
            const user = window.firebaseAuth?.currentUser;
            if (!user) {
                alert('Please sign in to use the workout tracker');
                return;
            }
            
            const userId = user.uid;
            switchWorkoutTab(currentWorkoutTab);
        }
        
        async function switchWorkoutTab(tab) {
            currentWorkoutTab = tab;
            
            // Hide all sections
            document.getElementById('weeklyScheduleSection').style.display = 'none';
            document.getElementById('customGymSection').style.display = 'none';
            document.getElementById('customSportsSection').style.display = 'none';
            
            // Reset all tab styles
            const scheduleTab = document.getElementById('weeklyScheduleTab');
            const gymTab = document.getElementById('customGymTab');
            const sportsTab = document.getElementById('customSportsTab');
            
            scheduleTab.style.borderBottom = '3px solid transparent';
            scheduleTab.style.color = '#666';
            scheduleTab.style.fontWeight = '400';
            
            gymTab.style.borderBottom = '3px solid transparent';
            gymTab.style.color = '#666';
            gymTab.style.fontWeight = '400';
            
            sportsTab.style.borderBottom = '3px solid transparent';
            sportsTab.style.color = '#666';
            sportsTab.style.fontWeight = '400';
            
            const user = window.firebaseAuth?.currentUser;
            if (!user) return;
            
            if (tab === 'schedule') {
                document.getElementById('weeklyScheduleSection').style.display = 'block';
                scheduleTab.style.borderBottom = '3px solid var(--primary-color)';
                scheduleTab.style.color = 'var(--primary-color)';
                scheduleTab.style.fontWeight = '600';
                checkGoogleCalendarStatus();
                await loadWeeklySchedule(user.uid);
            } else if (tab === 'gym') {
                document.getElementById('customGymSection').style.display = 'block';
                gymTab.style.borderBottom = '3px solid var(--primary-color)';
                gymTab.style.color = 'var(--primary-color)';
                gymTab.style.fontWeight = '600';
                await loadCustomGymWorkouts(user.uid);
            } else if (tab === 'sports') {
                document.getElementById('customSportsSection').style.display = 'block';
                sportsTab.style.borderBottom = '3px solid var(--primary-color)';
                sportsTab.style.color = 'var(--primary-color)';
                sportsTab.style.fontWeight = '600';
                await loadCustomSportsWorkouts(user.uid);
            }
        }
        
        // Google Calendar Integration
        let googleCalendarToken = null;
        // Google Calendar API credentials
        const GOOGLE_CALENDAR_CLIENT_ID = '686596339738-hcdm9e8tdtnt3a9v5fpl799733usub53.apps.googleusercontent.com';
        const GOOGLE_CALENDAR_API_KEY = 'AIzaSyAJDWJe1s1V19fwlyW1anwY3v57OHlKa5k';
        const GOOGLE_CALENDAR_SCOPES = 'https://www.googleapis.com/auth/calendar';
        
        // Check if Google Calendar is connected
        function checkGoogleCalendarStatus() {
            const token = localStorage.getItem('googleCalendarToken');
            const statusText = document.getElementById('calendarStatusText');
            
            if (token) {
                googleCalendarToken = token;
                if (statusText) statusText.textContent = 'âœ“ Connected to Google Calendar';
            } else {
                if (statusText) statusText.textContent = 'Click "Sync to Google Calendar" to connect and sync your schedule';
            }
        }
        
        // Wait for Google API to load
        function waitForGapi() {
            return new Promise((resolve, reject) => {
                if (typeof gapi !== 'undefined' && gapi.load) {
                    resolve();
                } else {
                    let attempts = 0;
                    const checkGapi = setInterval(() => {
                        attempts++;
                        if (typeof gapi !== 'undefined' && gapi.load) {
                            clearInterval(checkGapi);
                            resolve();
                        } else if (attempts > 50) {
                            clearInterval(checkGapi);
                            reject(new Error('Google API failed to load. Please refresh the page.'));
                        }
                    }, 100);
                }
            });
        }
        
        // Connect to Google Calendar
        async function connectGoogleCalendar() {
            try {
                // Check if credentials are configured
                if (GOOGLE_CALENDAR_CLIENT_ID === 'YOUR_GOOGLE_CLIENT_ID' || GOOGLE_CALENDAR_API_KEY === 'YOUR_GOOGLE_API_KEY') {
                    alert('Google Calendar integration is not configured. Please set up your Google OAuth Client ID and API Key in the code.\n\nTo set up:\n1. Go to https://console.cloud.google.com/\n2. Create a project or select existing one\n3. Enable Google Calendar API\n4. Create OAuth 2.0 credentials\n5. Update GOOGLE_CALENDAR_CLIENT_ID and GOOGLE_CALENDAR_API_KEY in the code');
                    return;
                }
                
                // Wait for Google API to be available
                await waitForGapi();
                
                // Load the client library
                await new Promise((resolve, reject) => {
                    gapi.load('client:auth2', {
                        callback: resolve,
                        onerror: reject,
                        timeout: 10000,
                        ontimeout: () => reject(new Error('Google API load timeout'))
                    });
                });
                
                // Initialize the client
                await gapi.client.init({
                    apiKey: GOOGLE_CALENDAR_API_KEY,
                    clientId: GOOGLE_CALENDAR_CLIENT_ID,
                    discoveryDocs: ['https://www.googleapis.com/discovery/v1/apis/calendar/v3/rest'],
                    scope: GOOGLE_CALENDAR_SCOPES
                });
                
                // Sign in the user
                const authInstance = gapi.auth2.getAuthInstance();
                
                // Check if user is already signed in
                let user = authInstance.currentUser.get();
                if (!user || !user.isSignedIn()) {
                    user = await authInstance.signIn({
                        prompt: 'consent'
                    });
                }
                
                const token = user.getAuthResponse().access_token;
                
                localStorage.setItem('googleCalendarToken', token);
                googleCalendarToken = token;
                
                // Set the token for API calls
                gapi.client.setToken({ access_token: token });
                
                checkGoogleCalendarStatus();
                alert('Successfully connected to Google Calendar! You can now sync your schedule.');
            } catch (error) {
                console.error('Error connecting to Google Calendar:', error);
                let errorMsg = 'Failed to connect to Google Calendar.\n\n';
                
                // Handle specific error cases
                if (error.error === 'idpiframe_initialization_failed' || error.message?.includes('idpiframe')) {
                    errorMsg += 'This usually means:\n';
                    errorMsg += '1. Your OAuth client was just created - wait 5-10 minutes and try again\n';
                    errorMsg += '2. Check that "http://localhost:8080" is in your Authorized JavaScript origins\n';
                    errorMsg += '3. Make sure your OAuth consent screen is configured\n\n';
                    errorMsg += 'Go to: https://console.cloud.google.com/apis/credentials';
                } else if (error.message) {
                    errorMsg += error.message;
                } else if (error.error) {
                    errorMsg += error.error;
                } else {
                    errorMsg += 'Please check the console for details.';
                }
                
                alert(errorMsg);
            }
        }
        
        // Sync schedule to Google Calendar (automatically connects if needed)
        async function syncToGoogleCalendar() {
            const user = window.firebaseAuth?.currentUser;
            if (!user) {
                alert('Please sign in first');
                return;
            }
            
            // If not connected, connect first
            if (!googleCalendarToken) {
                const token = localStorage.getItem('googleCalendarToken');
                if (!token) {
                    // Need to connect first
                    try {
                        await connectGoogleCalendar();
                        // After connecting, continue with sync
                        if (!localStorage.getItem('googleCalendarToken')) {
                            return; // User cancelled or connection failed
                        }
                    } catch (error) {
                        console.error('Error connecting:', error);
                        return;
                    }
                } else {
                    googleCalendarToken = token;
                }
            }
            
            // Ensure gapi client is initialized
            if (!gapi.client || !gapi.client.calendar) {
                try {
                    await waitForGapi();
                    
                    await new Promise((resolve, reject) => {
                        gapi.load('client:auth2', {
                            callback: resolve,
                            onerror: reject,
                            timeout: 10000,
                            ontimeout: () => reject(new Error('Google API load timeout'))
                        });
                    });
                    
                    await gapi.client.init({
                        apiKey: GOOGLE_CALENDAR_API_KEY,
                        clientId: GOOGLE_CALENDAR_CLIENT_ID,
                        discoveryDocs: ['https://www.googleapis.com/discovery/v1/apis/calendar/v3/rest'],
                        scope: GOOGLE_CALENDAR_SCOPES
                    });
                    
                    gapi.client.setToken({ access_token: googleCalendarToken });
                } catch (error) {
                    console.error('Error initializing Google API:', error);
                    alert('Error initializing Google Calendar API. Please reconnect.');
                    return;
                }
            } else {
                // Set token if client is already initialized
                gapi.client.setToken({ access_token: googleCalendarToken });
            }
            
            try {
                // Load all data
                const dietPlans = await window.getCustomDietPlans(user.uid);
                const gymWorkouts = await window.getCustomGymWorkouts(user.uid);
                const sportsWorkouts = await window.getCustomSportsWorkouts(user.uid);
                
                // Get current date to calculate event dates
                const today = new Date();
                const currentDay = today.getDay(); // 0 = Sunday, 1 = Monday, etc.
                
                // Day name to day number mapping
                const dayToNumber = {
                    'Sunday': 0,
                    'Monday': 1,
                    'Tuesday': 2,
                    'Wednesday': 3,
                    'Thursday': 4,
                    'Friday': 5,
                    'Saturday': 6
                };
                
                // Day abbreviation for RRULE
                const dayToAbbr = {
                    'Sunday': 'SU',
                    'Monday': 'MO',
                    'Tuesday': 'TU',
                    'Wednesday': 'WE',
                    'Thursday': 'TH',
                    'Friday': 'FR',
                    'Saturday': 'SA'
                };
                
                let eventsCreated = 0;
                
                // Sync diet plans
                for (const plan of dietPlans) {
                    if (plan.days && plan.days.length > 0) {
                        for (const dayName of plan.days) {
                            const dayNumber = dayToNumber[dayName];
                            if (dayNumber !== undefined) {
                                // Calculate next occurrence of this day
                                const daysUntil = (dayNumber - currentDay + 7) % 7 || 7;
                                const eventDate = new Date(today);
                                eventDate.setDate(today.getDate() + daysUntil);
                                
                                // Create event for each meal
                                if (plan.meals && plan.meals.length > 0) {
                                    for (const meal of plan.meals) {
                                        const eventTime = meal.time ? meal.time.split(':') : ['12', '00'];
                                        const eventDateTime = new Date(eventDate);
                                        eventDateTime.setHours(parseInt(eventTime[0]), parseInt(eventTime[1]), 0);
                                        
                                        const event = {
                                            summary: `ðŸ½ï¸ ${plan.name}: ${meal.name}`,
                                            description: `Calories: ${Math.round(meal.calories)} | Protein: ${Math.round(meal.protein * 10) / 10}g${meal.food ? `\nFood: ${meal.food}` : ''}`,
                                            start: {
                                                dateTime: eventDateTime.toISOString(),
                                                timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone
                                            },
                                            end: {
                                                dateTime: new Date(eventDateTime.getTime() + 30 * 60000).toISOString(), // 30 min duration
                                                timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone
                                            },
                                            recurrence: ['RRULE:FREQ=WEEKLY;BYDAY=' + dayToAbbr[dayName]]
                                        };
                                        
                                        await gapi.client.calendar.events.insert({
                                            calendarId: 'primary',
                                            resource: event
                                        });
                                        eventsCreated++;
                                    }
                                }
                            }
                        }
                    }
                }
                
                // Sync gym workouts
                for (const workout of gymWorkouts) {
                    if (workout.days && workout.days.length > 0) {
                        for (const dayName of workout.days) {
                            const dayNumber = dayToNumber[dayName];
                            if (dayNumber !== undefined) {
                                const daysUntil = (dayNumber - currentDay + 7) % 7 || 7;
                                const eventDate = new Date(today);
                                eventDate.setDate(today.getDate() + daysUntil);
                                eventDate.setHours(18, 0, 0); // Default to 6 PM
                                
                                const event = {
                                    summary: `ðŸ’ª ${workout.name}`,
                                    description: `Exercises: ${workout.exercises.map(e => e.name).join(', ')}`,
                                    start: {
                                        dateTime: eventDate.toISOString(),
                                        timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone
                                    },
                                    end: {
                                        dateTime: new Date(eventDate.getTime() + 60 * 60000).toISOString(), // 1 hour duration
                                        timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone
                                    },
                                    recurrence: ['RRULE:FREQ=WEEKLY;BYDAY=' + dayToAbbr[dayName]]
                                };
                                
                                await gapi.client.calendar.events.insert({
                                    calendarId: 'primary',
                                    resource: event
                                });
                                eventsCreated++;
                            }
                        }
                    }
                }
                
                // Sync sports workouts
                for (const workout of sportsWorkouts) {
                    if (workout.days && workout.days.length > 0) {
                        for (const dayName of workout.days) {
                            const dayNumber = dayToNumber[dayName];
                            if (dayNumber !== undefined) {
                                const daysUntil = (dayNumber - currentDay + 7) % 7 || 7;
                                const eventDate = new Date(today);
                                eventDate.setDate(today.getDate() + daysUntil);
                                eventDate.setHours(17, 0, 0); // Default to 5 PM
                                
                                const event = {
                                    summary: `âš½ ${workout.name}`,
                                    description: workout.details || '',
                                    start: {
                                        dateTime: eventDate.toISOString(),
                                        timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone
                                    },
                                    end: {
                                        dateTime: new Date(eventDate.getTime() + 60 * 60000).toISOString(), // 1 hour duration
                                        timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone
                                    },
                                    recurrence: ['RRULE:FREQ=WEEKLY;BYDAY=' + dayToAbbr[dayName]]
                                };
                                
                                await gapi.client.calendar.events.insert({
                                    calendarId: 'primary',
                                    resource: event
                                });
                                eventsCreated++;
                            }
                        }
                    }
                }
                
                alert(`Successfully synced ${eventsCreated} events to Google Calendar!`);
            } catch (error) {
                console.error('Error syncing to Google Calendar:', error);
                alert('Error syncing to Google Calendar: ' + (error.message || 'Unknown error'));
            }
        }
        
        // Weekly Schedule Functions
        let scheduleEditMode = false;
        
        async function loadWeeklySchedule(userId) {
            const schedule = await window.getWeeklySchedule(userId);
            const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
            const container = document.getElementById('weeklyScheduleContainer');
            container.innerHTML = '';
            
            // Load diet plans and workouts with their selected days
            const dietPlans = await window.getCustomDietPlans(userId);
            const gymWorkouts = await window.getCustomGymWorkouts(userId);
            const sportsWorkouts = await window.getCustomSportsWorkouts(userId);
            
            // Build a comprehensive schedule that includes diet plans and workouts based on their days
            const fullSchedule = {};
            days.forEach(day => {
                fullSchedule[day.toLowerCase()] = [...(schedule[day.toLowerCase()] || [])];
            });
            
            // Add diet plans to schedule based on their selected days
            dietPlans.forEach(plan => {
                if (plan.days && Array.isArray(plan.days) && plan.days.length > 0) {
                    plan.days.forEach(planDay => {
                        const dayKey = planDay.toLowerCase();
                        if (fullSchedule[dayKey]) {
                            // Check if diet plan is already in schedule (from manual addition)
                            const exists = fullSchedule[dayKey].some(item => 
                                item.type === 'diet' && item.id === plan.id
                            );
                            if (!exists) {
                                fullSchedule[dayKey].push({
                                    type: 'diet',
                                    id: plan.id,
                                    name: plan.name
                                });
                            }
                        }
                    });
                }
            });
            
            // Add gym workouts to schedule based on their selected days
            gymWorkouts.forEach(workout => {
                if (workout.days && Array.isArray(workout.days) && workout.days.length > 0) {
                    workout.days.forEach(workoutDay => {
                        const dayKey = workoutDay.toLowerCase();
                        if (fullSchedule[dayKey]) {
                            // Check if workout is already in schedule (from manual addition)
                            const exists = fullSchedule[dayKey].some(item => 
                                item.type === 'gym' && item.id === workout.id
                            );
                            if (!exists) {
                                fullSchedule[dayKey].push({
                                    type: 'gym',
                                    id: workout.id,
                                    name: workout.name
                                });
                            }
                        }
                    });
                }
            });
            
            // Add sports workouts to schedule based on their selected days
            sportsWorkouts.forEach(workout => {
                if (workout.days && Array.isArray(workout.days) && workout.days.length > 0) {
                    workout.days.forEach(workoutDay => {
                        const dayKey = workoutDay.toLowerCase();
                        if (fullSchedule[dayKey]) {
                            // Check if workout is already in schedule (from manual addition)
                            const exists = fullSchedule[dayKey].some(item => 
                                item.type === 'sports' && item.id === workout.id
                            );
                            if (!exists) {
                                fullSchedule[dayKey].push({
                                    type: 'sports',
                                    id: workout.id,
                                    name: workout.name
                                });
                            }
                        }
                    });
                }
            });
            
            days.forEach(day => {
                const dayKey = day.toLowerCase();
                const items = fullSchedule[dayKey] || [];
                const dayColumn = document.createElement('div');
                dayColumn.style.cssText = 'display: flex; flex-direction: column; border: 1px solid #e2e8f0; border-radius: 8px; padding: 15px; background: #f8f9fa; min-height: 200px;';
                
                // Day header - make it more prominent
                const dayHeader = document.createElement('div');
                dayHeader.style.cssText = 'font-weight: 700; font-size: 18px; margin-bottom: 15px; text-align: center; padding-bottom: 12px; border-bottom: 2px solid #e2e8f0; color: #1a1a1a; font-family: \'Courier Prime\', monospace;';
                dayHeader.textContent = day;
                dayColumn.appendChild(dayHeader);
                
                // Items container (workouts and diet plans)
                const itemsContainer = document.createElement('div');
                itemsContainer.style.cssText = 'flex: 1; margin-bottom: 10px;';
                
                if (items.length === 0) {
                    itemsContainer.innerHTML = '<div style="color: #999; font-style: italic; text-align: center; font-size: 12px; padding: 10px;">No items</div>';
                } else {
                    items.forEach((item, index) => {
                        const itemDiv = document.createElement('div');
                        // Different colors for different types
                        let bgColor = '#f0f9ff'; // Default for workouts
                        let prefix = '';
                        if (item.type === 'diet') {
                            bgColor = '#fef3c7'; // Yellow for diet plans
                            prefix = 'ðŸ½ï¸ ';
                        } else if (item.type === 'gym') {
                            bgColor = '#dbeafe'; // Blue for gym workouts
                            prefix = 'ðŸ’ª ';
                        } else if (item.type === 'sports') {
                            bgColor = '#d1fae5'; // Green for sports workouts
                            prefix = 'âš½ ';
                        }
                        
                        itemDiv.style.cssText = `background: ${bgColor}; padding: 10px; border-radius: 4px; margin-bottom: 8px; font-size: 14px; border: 1px solid rgba(0,0,0,0.1);`;
                        
                        // Show delete button only in edit mode
                        const deleteButtonHTML = scheduleEditMode 
                            ? `<button onclick="removeWorkoutFromDay('${dayKey}', ${index})" style="background: #ef4444; color: white; border: none; border-radius: 3px; padding: 2px 8px; cursor: pointer; font-size: 14px; margin-left: 8px; font-weight: bold;">-</button>`
                            : '';
                        
                        itemDiv.innerHTML = `
                            <div style="display: flex; align-items: center; justify-content: space-between;">
                                <div style="font-weight: 600; color: #1a1a1a;">${prefix}${item.name}</div>
                                ${deleteButtonHTML}
                            </div>
                        `;
                        itemsContainer.appendChild(itemDiv);
                    });
                }
                dayColumn.appendChild(itemsContainer);
                
                // Add button (only show when not in edit mode)
                if (!scheduleEditMode) {
                    const addButton = document.createElement('button');
                    addButton.className = 'btn btn-secondary';
                    addButton.style.cssText = 'padding: 8px 12px; width: 100%; margin-top: auto;';
                    addButton.textContent = 'Add';
                    addButton.onclick = () => showAddWorkoutToDay(dayKey, day);
                    dayColumn.appendChild(addButton);
                }
                
                container.appendChild(dayColumn);
            });
        }
        
        async function toggleScheduleEditMode() {
            scheduleEditMode = !scheduleEditMode;
            const editBtn = document.getElementById('editScheduleBtn');
            
            if (scheduleEditMode) {
                editBtn.textContent = 'Cancel';
                editBtn.style.background = '#ef4444';
                editBtn.style.color = 'white';
            } else {
                editBtn.textContent = 'Edit';
                editBtn.style.background = '';
                editBtn.style.color = '';
            }
            
            // Reload schedule to show/hide delete buttons
            const user = window.firebaseAuth?.currentUser;
            if (user) {
                await loadWeeklySchedule(user.uid);
            }
        }
        
        async function showAddWorkoutToDay(dayKey, dayName) {
            selectedDayForSchedule = dayKey;
            document.getElementById('selectedDayName').textContent = dayName;
            document.getElementById('addWorkoutToDayForm').style.display = 'block';
            
            const user = window.firebaseAuth?.currentUser;
            if (!user) return;
            
            // Load all custom workouts
            const gymWorkouts = await window.getCustomGymWorkouts(user.uid);
            const sportsWorkouts = await window.getCustomSportsWorkouts(user.uid);
            
            const select = document.getElementById('workoutSelect');
            select.innerHTML = '<option value="">-- Select a workout --</option>';
            
            gymWorkouts.forEach(workout => {
                const option = document.createElement('option');
                option.value = `gym-${workout.id}`;
                option.textContent = workout.name + ' (Gym)';
                select.appendChild(option);
            });
            
            sportsWorkouts.forEach(workout => {
                const option = document.createElement('option');
                option.value = `sports-${workout.id}`;
                option.textContent = workout.name + ' (Sports)';
                select.appendChild(option);
            });
        }
        
        async function addWorkoutToDay() {
            const user = window.firebaseAuth?.currentUser;
            if (!user) return;
            
            const workoutSelect = document.getElementById('workoutSelect').value;
            if (!workoutSelect || !selectedDayForSchedule) return;
            
            const [type, id] = workoutSelect.split('-');
            const schedule = await window.getWeeklySchedule(user.uid);
            const dayKey = selectedDayForSchedule;
            
            let workoutName = '';
            if (type === 'gym') {
                const gymWorkouts = await window.getCustomGymWorkouts(user.uid);
                const workout = gymWorkouts.find(w => w.id === id);
                if (workout) workoutName = workout.name;
            } else if (type === 'sports') {
                const sportsWorkouts = await window.getCustomSportsWorkouts(user.uid);
                const workout = sportsWorkouts.find(w => w.id === id);
                if (workout) workoutName = workout.name;
            }
            
            if (!schedule[dayKey]) schedule[dayKey] = [];
            schedule[dayKey].push({ type, id, name: workoutName });
            
            const success = await window.saveWeeklySchedule(user.uid, schedule);
            if (success) {
                document.getElementById('addWorkoutToDayForm').style.display = 'none';
                await loadWeeklySchedule(user.uid);
            }
        }
        
        function cancelAddWorkoutToDay() {
            document.getElementById('addWorkoutToDayForm').style.display = 'none';
            selectedDayForSchedule = null;
        }
        
        async function removeWorkoutFromDay(dayKey, index) {
            const user = window.firebaseAuth?.currentUser;
            if (!user) return;
            
            const schedule = await window.getWeeklySchedule(user.uid);
            if (schedule[dayKey]) {
                schedule[dayKey].splice(index, 1);
                await window.saveWeeklySchedule(user.uid, schedule);
                await loadWeeklySchedule(user.uid);
            }
        }
        
        // Custom Gym Workout Functions
        async function loadCustomGymWorkouts(userId) {
            const workouts = await window.getCustomGymWorkouts(userId);
            const container = document.getElementById('customGymWorkoutsList');
            container.innerHTML = '';
            
            if (workouts.length === 0) {
                container.innerHTML = '<p style="text-align: center; color: #666; padding: 40px;">No custom gym workouts yet. Create one to get started!</p>';
                return;
            }
            
            workouts.forEach(workout => {
                const workoutDays = workout.days && Array.isArray(workout.days) && workout.days.length > 0 ? workout.days : [];
                const daysDisplay = workoutDays.length > 0 ? workoutDays.join(', ') : 'No days selected';
                const workoutDiv = document.createElement('div');
                workoutDiv.style.cssText = 'background: #f8f9fa; padding: 20px; border-radius: 8px; margin-bottom: 15px;';
                workoutDiv.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 15px;">
                        <div>
                            <h4 style="font-family: \'Courier Prime\', monospace; margin: 0 0 5px 0;">${workout.name}</h4>
                            <div style="font-family: \'Courier Prime\', monospace; color: #888; font-size: 13px;">
                                <strong>Days:</strong> ${daysDisplay}
                            </div>
                        </div>
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <label style="display: flex; align-items: center; cursor: pointer; font-family: 'Bebas Neue', sans-serif; font-size: 13px; color: #666;">
                                <input type="checkbox" id="gymWorkoutToggle-${workout.id}" ${workoutDays.length > 0 ? 'checked' : ''} onchange="toggleGymWorkout('${workout.id}')" style="margin-right: 6px; width: 18px; height: 18px; cursor: pointer;">
                                <span id="gymWorkoutToggleLabel-${workout.id}">${workoutDays.length > 0 ? 'ON' : 'OFF'}</span>
                            </label>
                            <button onclick="editGymWorkout('${workout.id}')" class="btn btn-secondary" style="padding: 5px 15px; margin-right: 5px;">Edit</button>
                            <button onclick="deleteGymWorkout('${workout.id}')" class="btn" style="padding: 5px 15px; background: #ef4444; color: white;">Delete</button>
                        </div>
                    </div>
                    <div>
                        ${workout.exercises.map(ex => {
                            let details = [];
                            if (ex.sets && ex.reps && ex.weight) {
                                details.push(`${ex.sets} sets Ã— ${ex.reps} reps @ ${ex.weight} lbs`);
                            } else if (ex.sets && ex.reps) {
                                details.push(`${ex.sets} sets Ã— ${ex.reps} reps`);
                            } else if (ex.sets) {
                                details.push(`${ex.sets} sets`);
                            }
                            if (ex.notes) {
                                details.push(ex.notes);
                            }
                            const detailsText = details.length > 0 ? ' - ' + details.join(', ') : '';
                            return `
                                <div style="padding: 8px; background: white; border-radius: 4px; margin-bottom: 8px; font-family: \'Courier Prime\', monospace;">
                                    <strong>${ex.name}</strong>${detailsText}
                                </div>
                            `;
                        }).join('')}
                    </div>
                `;
                container.appendChild(workoutDiv);
            });
        }
        
        function showCreateGymWorkoutForm() {
            editingGymWorkoutId = null;
            document.getElementById('gymWorkoutFormTitle').textContent = 'Create Custom Gym Workout';
            document.getElementById('gymWorkoutName').value = '';
            document.getElementById('gymWorkoutExercisesList').innerHTML = '';
            // Clear all day checkboxes
            const days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
            days.forEach(day => {
                const checkbox = document.getElementById(`gymWorkoutDay-${day}`);
                if (checkbox) checkbox.checked = false;
            });
            document.getElementById('createGymWorkoutForm').style.display = 'block';
        }
        
        function addExerciseToGymWorkout() {
            const container = document.getElementById('gymWorkoutExercisesList');
            const exerciseId = 'exercise-' + Date.now();
            const exerciseDiv = document.createElement('div');
            exerciseDiv.style.cssText = 'padding: 15px; background: #f8f9fa; border-radius: 4px; margin-bottom: 15px;';
            exerciseDiv.innerHTML = `
                <div style="display: grid; grid-template-columns: 2fr 1fr 1fr 1fr auto; gap: 10px; align-items: end; margin-bottom: 10px;">
                    <input type="text" id="${exerciseId}-name" placeholder="Exercise name" style="padding: 8px; border: 2px solid #ddd; border-radius: 4px; font-family: \'Courier Prime\', monospace;">
                    <input type="number" id="${exerciseId}-sets" placeholder="Sets (optional)" min="0" style="padding: 8px; border: 2px solid #ddd; border-radius: 4px; font-family: \'Courier Prime\', monospace;">
                    <input type="number" id="${exerciseId}-reps" placeholder="Reps (optional)" min="0" style="padding: 8px; border: 2px solid #ddd; border-radius: 4px; font-family: \'Courier Prime\', monospace;">
                    <input type="number" id="${exerciseId}-weight" placeholder="Weight (optional)" min="0" step="0.5" style="padding: 8px; border: 2px solid #ddd; border-radius: 4px; font-family: \'Courier Prime\', monospace;">
                    <button onclick="this.parentElement.parentElement.remove()" class="btn" style="padding: 8px 12px; background: #ef4444; color: white;">Remove</button>
                </div>
                <input type="text" id="${exerciseId}-notes" placeholder="Custom notes (e.g., 10 minutes at 6 mph)" style="width: 100%; padding: 8px; border: 2px solid #ddd; border-radius: 4px; font-family: \'Courier Prime\', monospace;">
            `;
            container.appendChild(exerciseDiv);
        }
        
        async function saveGymWorkout() {
            const user = window.firebaseAuth?.currentUser;
            if (!user) return;
            
            const name = document.getElementById('gymWorkoutName').value.trim();
            if (!name) {
                alert('Please enter a workout name');
                return;
            }
            
            const exercises = [];
            const exerciseDivs = document.querySelectorAll('#gymWorkoutExercisesList > div');
            exerciseDivs.forEach(div => {
                const inputs = div.querySelectorAll('input');
                const name = inputs[0].value.trim();
                const setsValue = inputs[1].value.trim();
                const repsValue = inputs[2].value.trim();
                const weightValue = inputs[3].value.trim();
                const notes = inputs[4].value.trim();
                
                if (name) {
                    const exerciseData = { name };
                    
                    // Only add sets/reps/weight if they have values
                    if (setsValue) {
                        const sets = parseInt(setsValue);
                        if (!isNaN(sets)) exerciseData.sets = sets;
                    }
                    if (repsValue) {
                        const reps = parseInt(repsValue);
                        if (!isNaN(reps)) exerciseData.reps = reps;
                    }
                    if (weightValue) {
                        const weight = parseFloat(weightValue);
                        if (!isNaN(weight)) exerciseData.weight = weight;
                    }
                    if (notes) {
                        exerciseData.notes = notes;
                    }
                    
                    exercises.push(exerciseData);
                }
            });
            
            if (exercises.length === 0) {
                alert('Please add at least one exercise');
                return;
            }
            
            // Get selected days
            const selectedDays = [];
            const days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
            days.forEach(day => {
                const checkbox = document.getElementById(`gymWorkoutDay-${day}`);
                if (checkbox && checkbox.checked) {
                    selectedDays.push(day);
                }
            });
            
            const workoutData = { name, exercises, days: selectedDays };
            
            try {
                let success = false;
                if (editingGymWorkoutId) {
                    success = await window.updateCustomGymWorkout(editingGymWorkoutId, workoutData);
                } else {
                    success = await window.saveCustomGymWorkout(user.uid, workoutData);
                }
                
                if (success) {
                    document.getElementById('createGymWorkoutForm').style.display = 'none';
                    await loadCustomGymWorkouts(user.uid);
                } else {
                    alert('Error saving workout. Please check the console for details.');
                }
            } catch (error) {
                console.error('Error saving workout:', error);
                alert('Error saving workout: ' + (error.message || 'Unknown error'));
            }
        }
        
        async function editGymWorkout(workoutId) {
            const user = window.firebaseAuth?.currentUser;
            if (!user) return;
            
            const workouts = await window.getCustomGymWorkouts(user.uid);
            const workout = workouts.find(w => w.id === workoutId);
            if (!workout) return;
            
            editingGymWorkoutId = workoutId;
            document.getElementById('gymWorkoutFormTitle').textContent = 'Edit Custom Gym Workout';
            document.getElementById('gymWorkoutName').value = workout.name || '';
            document.getElementById('gymWorkoutExercisesList').innerHTML = '';
            
            // Set day checkboxes
            const days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
            const workoutDays = workout.days && Array.isArray(workout.days) ? workout.days : [];
            days.forEach(day => {
                const checkbox = document.getElementById(`gymWorkoutDay-${day}`);
                if (checkbox) {
                    checkbox.checked = workoutDays.includes(day);
                }
            });
            
            workout.exercises.forEach(ex => {
                const exerciseId = 'exercise-' + Date.now() + '-' + Math.random();
                const exerciseDiv = document.createElement('div');
                exerciseDiv.style.cssText = 'padding: 15px; background: #f8f9fa; border-radius: 4px; margin-bottom: 15px;';
                exerciseDiv.innerHTML = `
                    <div style="display: grid; grid-template-columns: 2fr 1fr 1fr 1fr auto; gap: 10px; align-items: end; margin-bottom: 10px;">
                        <input type="text" id="${exerciseId}-name" value="${ex.name || ''}" style="padding: 8px; border: 2px solid #ddd; border-radius: 4px; font-family: \'Courier Prime\', monospace;">
                        <input type="number" id="${exerciseId}-sets" value="${ex.sets || ''}" placeholder="Sets (optional)" min="0" style="padding: 8px; border: 2px solid #ddd; border-radius: 4px; font-family: \'Courier Prime\', monospace;">
                        <input type="number" id="${exerciseId}-reps" value="${ex.reps || ''}" placeholder="Reps (optional)" min="0" style="padding: 8px; border: 2px solid #ddd; border-radius: 4px; font-family: \'Courier Prime\', monospace;">
                        <input type="number" id="${exerciseId}-weight" value="${ex.weight || ''}" placeholder="Weight (optional)" min="0" step="0.5" style="padding: 8px; border: 2px solid #ddd; border-radius: 4px; font-family: \'Courier Prime\', monospace;">
                        <button onclick="this.parentElement.parentElement.remove()" class="btn" style="padding: 8px 12px; background: #ef4444; color: white;">Remove</button>
                    </div>
                    <input type="text" id="${exerciseId}-notes" value="${ex.notes || ''}" placeholder="Custom notes (e.g., 10 minutes at 6 mph)" style="width: 100%; padding: 8px; border: 2px solid #ddd; border-radius: 4px; font-family: \'Courier Prime\', monospace;">
                `;
                document.getElementById('gymWorkoutExercisesList').appendChild(exerciseDiv);
            });
            
            document.getElementById('createGymWorkoutForm').style.display = 'block';
        }
        
        async function deleteGymWorkout(workoutId) {
            if (!confirm('Are you sure you want to delete this workout?')) return;
            
            const success = await window.deleteCustomGymWorkout(workoutId);
            if (success) {
                const user = window.firebaseAuth?.currentUser;
                if (user) await loadCustomGymWorkouts(user.uid);
            } else {
                alert('Error deleting workout');
            }
        }
        
        function cancelGymWorkoutForm() {
            document.getElementById('createGymWorkoutForm').style.display = 'none';
            editingGymWorkoutId = null;
        }
        
        // Custom Sports Workout Functions
        async function loadCustomSportsWorkouts(userId) {
            const workouts = await window.getCustomSportsWorkouts(userId);
            const container = document.getElementById('customSportsWorkoutsList');
            container.innerHTML = '';
            
            if (workouts.length === 0) {
                container.innerHTML = '<p style="text-align: center; color: #666; padding: 40px;">No custom sports workouts yet. Create one to get started!</p>';
                return;
            }
            
            workouts.forEach(workout => {
                const workoutDays = workout.days && Array.isArray(workout.days) && workout.days.length > 0 ? workout.days : [];
                const daysDisplay = workoutDays.length > 0 ? workoutDays.join(', ') : 'No days selected';
                const workoutDiv = document.createElement('div');
                workoutDiv.style.cssText = 'background: #f8f9fa; padding: 20px; border-radius: 8px; margin-bottom: 15px;';
                workoutDiv.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 15px;">
                        <div>
                            <h4 style="font-family: \'Courier Prime\', monospace; margin: 0 0 5px 0;">${workout.name}</h4>
                            <div style="font-family: \'Courier Prime\', monospace; color: #888; font-size: 13px; margin-bottom: 10px;">
                                <strong>Days:</strong> ${daysDisplay}
                            </div>
                        </div>
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <label style="display: flex; align-items: center; cursor: pointer; font-family: 'Bebas Neue', sans-serif; font-size: 13px; color: #666;">
                                <input type="checkbox" id="sportsWorkoutToggle-${workout.id}" ${workoutDays.length > 0 ? 'checked' : ''} onchange="toggleSportsWorkout('${workout.id}')" style="margin-right: 6px; width: 18px; height: 18px; cursor: pointer;">
                                <span id="sportsWorkoutToggleLabel-${workout.id}">${workoutDays.length > 0 ? 'ON' : 'OFF'}</span>
                            </label>
                            <button onclick="editSportsWorkout('${workout.id}')" class="btn btn-secondary" style="padding: 5px 15px; margin-right: 5px;">Edit</button>
                            <button onclick="deleteSportsWorkout('${workout.id}')" class="btn" style="padding: 5px 15px; background: #ef4444; color: white;">Delete</button>
                        </div>
                    </div>
                    <div style="font-family: \'Courier Prime\', monospace; color: #666; white-space: pre-wrap;">${workout.details}</div>
                `;
                container.appendChild(workoutDiv);
            });
        }
        
        function showCreateSportsWorkoutForm() {
            editingSportsWorkoutId = null;
            document.getElementById('sportsWorkoutFormTitle').textContent = 'Create Custom Sports Workout';
            document.getElementById('sportsWorkoutName').value = '';
            document.getElementById('sportsWorkoutDetails').value = '';
            // Clear all day checkboxes
            const days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
            days.forEach(day => {
                const checkbox = document.getElementById(`sportsWorkoutDay-${day}`);
                if (checkbox) checkbox.checked = false;
            });
            document.getElementById('createSportsWorkoutForm').style.display = 'block';
        }
        
        async function saveSportsWorkout() {
            const user = window.firebaseAuth?.currentUser;
            if (!user) return;
            
            const name = document.getElementById('sportsWorkoutName').value.trim();
            const details = document.getElementById('sportsWorkoutDetails').value.trim();
            
            if (!name || !details) {
                alert('Please fill in all fields');
                return;
            }
            
            // Get selected days
            const selectedDays = [];
            const days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
            days.forEach(day => {
                const checkbox = document.getElementById(`sportsWorkoutDay-${day}`);
                if (checkbox && checkbox.checked) {
                    selectedDays.push(day);
                }
            });
            
            const workoutData = { name, details, days: selectedDays };
            
            let success = false;
            if (editingSportsWorkoutId) {
                success = await window.updateCustomSportsWorkout(editingSportsWorkoutId, workoutData);
            } else {
                success = await window.saveCustomSportsWorkout(user.uid, workoutData);
            }
            
            if (success) {
                document.getElementById('createSportsWorkoutForm').style.display = 'none';
                await loadCustomSportsWorkouts(user.uid);
            } else {
                alert('Error saving workout');
            }
        }
        
        async function editSportsWorkout(workoutId) {
            const user = window.firebaseAuth?.currentUser;
            if (!user) return;
            
            const workouts = await window.getCustomSportsWorkouts(user.uid);
            const workout = workouts.find(w => w.id === workoutId);
            if (!workout) return;
            
            editingSportsWorkoutId = workoutId;
            document.getElementById('sportsWorkoutFormTitle').textContent = 'Edit Custom Sports Workout';
            document.getElementById('sportsWorkoutName').value = workout.name || '';
            document.getElementById('sportsWorkoutDetails').value = workout.details || '';
            
            // Set day checkboxes
            const days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
            const workoutDays = workout.days && Array.isArray(workout.days) ? workout.days : [];
            days.forEach(day => {
                const checkbox = document.getElementById(`sportsWorkoutDay-${day}`);
                if (checkbox) {
                    checkbox.checked = workoutDays.includes(day);
                }
            });
            
            document.getElementById('createSportsWorkoutForm').style.display = 'block';
        }
        
        async function deleteSportsWorkout(workoutId) {
            if (!confirm('Are you sure you want to delete this workout?')) return;
            
            const success = await window.deleteCustomSportsWorkout(workoutId);
            if (success) {
                const user = window.firebaseAuth?.currentUser;
                if (user) await loadCustomSportsWorkouts(user.uid);
            } else {
                alert('Error deleting workout');
            }
        }
        
        function cancelSportsWorkoutForm() {
            document.getElementById('createSportsWorkoutForm').style.display = 'none';
            editingSportsWorkoutId = null;
        }
        
        // Make workout functions globally available
        window.switchWorkoutTab = switchWorkoutTab;
        window.showAddWorkoutToDay = showAddWorkoutToDay;
        window.addWorkoutToDay = addWorkoutToDay;
        window.cancelAddWorkoutToDay = cancelAddWorkoutToDay;
        window.removeWorkoutFromDay = removeWorkoutFromDay;
        window.toggleScheduleEditMode = toggleScheduleEditMode;
        window.showCreateGymWorkoutForm = showCreateGymWorkoutForm;
        window.addExerciseToGymWorkout = addExerciseToGymWorkout;
        window.saveGymWorkout = saveGymWorkout;
        window.editGymWorkout = editGymWorkout;
        window.deleteGymWorkout = deleteGymWorkout;
        
        // Toggle gym workout on/off
        async function toggleGymWorkout(workoutId) {
            const user = window.firebaseAuth?.currentUser;
            if (!user) return;
            
            const workouts = await window.getCustomGymWorkouts(user.uid);
            const workout = workouts.find(w => w.id === workoutId);
            if (!workout) return;
            
            const checkbox = document.getElementById(`gymWorkoutToggle-${workoutId}`);
            const label = document.getElementById(`gymWorkoutToggleLabel-${workoutId}`);
            
            let newDays = [];
            if (checkbox.checked) {
                // Turning ON: if no days were set, default to all days
                if (!workout.days || workout.days.length === 0) {
                    newDays = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
                } else {
                    newDays = workout.days; // Keep existing days
                }
                label.textContent = 'ON';
            } else {
                // Turning OFF: clear days
                newDays = [];
                label.textContent = 'OFF';
            }
            
            // Update only the days field
            const success = await window.updateCustomGymWorkout(workoutId, {
                name: workout.name,
                exercises: workout.exercises,
                days: newDays
            });
            
            if (success) {
                await loadCustomGymWorkouts(user.uid);
                // Reload schedule if we're on that tab
                const user2 = window.firebaseAuth?.currentUser;
                if (user2) await loadWeeklySchedule(user2.uid);
            }
        }
        
        window.toggleGymWorkout = toggleGymWorkout;
        window.cancelGymWorkoutForm = cancelGymWorkoutForm;
        window.showCreateSportsWorkoutForm = showCreateSportsWorkoutForm;
        window.saveSportsWorkout = saveSportsWorkout;
        window.editSportsWorkout = editSportsWorkout;
        window.deleteSportsWorkout = deleteSportsWorkout;
        
        // Toggle sports workout on/off
        async function toggleSportsWorkout(workoutId) {
            const user = window.firebaseAuth?.currentUser;
            if (!user) return;
            
            const workouts = await window.getCustomSportsWorkouts(user.uid);
            const workout = workouts.find(w => w.id === workoutId);
            if (!workout) return;
            
            const checkbox = document.getElementById(`sportsWorkoutToggle-${workoutId}`);
            const label = document.getElementById(`sportsWorkoutToggleLabel-${workoutId}`);
            
            let newDays = [];
            if (checkbox.checked) {
                // Turning ON: if no days were set, default to all days
                if (!workout.days || workout.days.length === 0) {
                    newDays = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
                } else {
                    newDays = workout.days; // Keep existing days
                }
                label.textContent = 'ON';
            } else {
                // Turning OFF: clear days
                newDays = [];
                label.textContent = 'OFF';
            }
            
            // Update only the days field
            const success = await window.updateCustomSportsWorkout(workoutId, {
                name: workout.name,
                details: workout.details,
                days: newDays
            });
            
            if (success) {
                await loadCustomSportsWorkouts(user.uid);
                // Reload schedule if we're on that tab
                const user2 = window.firebaseAuth?.currentUser;
                if (user2) await loadWeeklySchedule(user2.uid);
            }
        }
        
        window.toggleSportsWorkout = toggleSportsWorkout;
        window.cancelSportsWorkoutForm = cancelSportsWorkoutForm;
        window.loadWorkouts = loadWorkouts;
        window.connectGoogleCalendar = connectGoogleCalendar;
        window.syncToGoogleCalendar = syncToGoogleCalendar;
        window.checkGoogleCalendarStatus = checkGoogleCalendarStatus;
    </script>

    <!-- Analysis Type Selection Logic -->
    <script>
        // Show analysis selection after video is ready
        function showAnalysisOptions() {
            const selection = document.getElementById('analysisTypeSelection');
            if (selection) {
                selection.style.display = 'block';
            }
            // Hide the control buttons
            const controlsDiv = document.getElementById('recordingControls');
            if (controlsDiv) controlsDiv.style.display = 'none';
            // Hide file name display
            const fileName = document.getElementById('uploadedFileName');
            if (fileName) fileName.style.display = 'none';
            // Hide the old "Analyze Video" button
            const processBtn = document.getElementById('processUserVideo');
            if (processBtn) {
                processBtn.style.display = 'none';
            }
            // Hide body warning overlay (pink)
            const bodyWarning = document.getElementById('userBodyWarning');
            if (bodyWarning) bodyWarning.style.display = 'none';
            // Hide user status
            const userStatus = document.getElementById('userStatus');
            if (userStatus) userStatus.style.display = 'none';
            // Show "Video Ready" overlay (blue)
            const readyOverlay = document.getElementById('videoReadyOverlay');
            if (readyOverlay) readyOverlay.style.display = 'flex';
        }

        // Go back to recording/upload state
        function goBackToRecord() {
            // Hide analysis selection
            const selection = document.getElementById('analysisTypeSelection');
            if (selection) selection.style.display = 'none';
            // Show the control buttons
            const controlsDiv = document.getElementById('recordingControls');
            if (controlsDiv) controlsDiv.style.display = 'flex';
            // Show file name display
            const fileName = document.getElementById('uploadedFileName');
            if (fileName) {
                fileName.style.display = 'block';
                fileName.textContent = '';
            }
            // Hide overlays
            const readyOverlay = document.getElementById('videoReadyOverlay');
            if (readyOverlay) readyOverlay.style.display = 'none';
            const runningOverlay = document.getElementById('analysisRunningOverlay');
            if (runningOverlay) runningOverlay.style.display = 'none';
            // Reset video
            const video = document.getElementById('userVideo');
            if (video) {
                video.src = '';
                video.load();
            }
            // Clear file input
            const fileInput = document.getElementById('userVideoUpload');
            if (fileInput) fileInput.value = '';
            // Deselect analysis buttons
            document.querySelectorAll('.analysis-type-btn').forEach(b => b.classList.remove('selected'));
            // Clear recorded pose data
            window.recordedUserPoseData = null;
            if (typeof userPoseData !== 'undefined') {
                userPoseData = [];
            }
        }

        // Override the userVideoUpload change handler to show analysis options
        document.addEventListener('DOMContentLoaded', function() {
            const userVideoUpload = document.getElementById('userVideoUpload');
            if (userVideoUpload) {
                userVideoUpload.addEventListener('change', function(e) {
                    if (e.target.files[0]) {
                        // Show analysis options and blue overlay
                        setTimeout(showAnalysisOptions, 100);
                    }
                });
            }

            // Handle analysis type button clicks
            document.querySelectorAll('.analysis-type-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    // Skip if this is the back button
                    if (this.id === 'backToRecordBtn') return;

                    // Visual feedback - select this button
                    document.querySelectorAll('.analysis-type-btn').forEach(b => b.classList.remove('selected'));
                    this.classList.add('selected');

                    // Store the selected type
                    const analysisType = this.dataset.type;
                    window.selectedAnalysisType = analysisType;

                    // Hide "Video Ready" overlay, show "Running Analysis" overlay
                    const readyOverlay = document.getElementById('videoReadyOverlay');
                    if (readyOverlay) readyOverlay.style.display = 'none';
                    const runningOverlay = document.getElementById('analysisRunningOverlay');
                    if (runningOverlay) runningOverlay.style.display = 'flex';

                    // Run the analysis based on type
                    if (analysisType === 'similarity') {
                        // Player Match - show hardcoded UI for now
                        console.log('Showing Player Match results...');
                        setTimeout(() => {
                            if (runningOverlay) runningOverlay.style.display = 'none';
                            document.getElementById('step2').style.display = 'none';
                            document.getElementById('step3').style.display = 'block';
                            document.getElementById('playerMatchResults').classList.add('active');
                            document.getElementById('idealFormResults').style.display = 'none';
                        }, 1000); // Simulate brief loading
                    } else {
                        // Ideal Form - run actual analysis
                        document.getElementById('playerMatchResults').classList.remove('active');
                        document.getElementById('idealFormResults').style.display = 'block';

                        if (window.recordedUserPoseData && window.recordedUserPoseData.length > 0) {
                            console.log('Running analysis on recorded shot data...');
                            if (typeof compareShots === 'function') {
                                compareShots();
                            }
                        } else {
                            console.log('Processing uploaded video...');
                            if (typeof processUploadedUserVideo === 'function') {
                                processUploadedUserVideo();
                            }
                        }
                    }
                });
            });

            // Handle "Back" button
            const backBtn = document.getElementById('backToRecordBtn');
            if (backBtn) {
                backBtn.addEventListener('click', goBackToRecord);
            }

            // Handle "Try Other Analysis" button
            const tryOtherBtn = document.getElementById('tryOtherAnalysis');
            if (tryOtherBtn) {
                tryOtherBtn.addEventListener('click', function() {
                    // Go back to step2 with video still loaded
                    document.getElementById('step3').style.display = 'none';
                    document.getElementById('step3').classList.remove('active');
                    document.getElementById('step2').style.display = 'block';
                    document.getElementById('step2').classList.add('active');

                    // Show analysis options
                    showAnalysisOptions();

                    // Pre-select the OTHER analysis type
                    const otherType = window.selectedAnalysisType === 'ideal' ? 'similarity' : 'ideal';
                    document.querySelectorAll('.analysis-type-btn').forEach(b => {
                        b.classList.remove('selected');
                        if (b.dataset.type === otherType) {
                            b.classList.add('selected');
                        }
                    });
                });
            }
        });

        // Make showAnalysisOptions available globally
        window.showAnalysisOptions = showAnalysisOptions;

        // ========== Player Match UI Event Handlers ==========

        // Quick Fixes toggles
        document.querySelectorAll('.pm-fix-toggle').forEach(toggle => {
            toggle.addEventListener('click', () => {
                const item = toggle.closest('.pm-fix-item');
                item.classList.toggle('active');
            });
        });

        // Player row selection
        const pmRows = document.querySelectorAll('.pm-row');
        let pmSelectedIndex = 0;

        function updatePMSelection(index) {
            if (index < 0) index = 0;
            if (index >= pmRows.length) index = pmRows.length - 1;
            pmSelectedIndex = index;

            pmRows.forEach((row, i) => {
                if (i === pmSelectedIndex) {
                    row.classList.add('pm-row-selected');
                } else {
                    row.classList.remove('pm-row-selected');
                }
            });

            // Update right column with selected player name
            const selectedRow = pmRows[pmSelectedIndex];
            const playerName = selectedRow.querySelector('.pm-name').textContent;
            document.querySelectorAll('.pm-player-name').forEach(el => {
                el.textContent = playerName;
            });

            selectedRow.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }

        // Keyboard navigation
        document.addEventListener('keydown', (e) => {
            const pmResults = document.getElementById('playerMatchResults');
            if (!pmResults || !pmResults.classList.contains('active')) return;

            if (e.key === 'ArrowDown') {
                e.preventDefault();
                updatePMSelection(pmSelectedIndex + 1);
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                updatePMSelection(pmSelectedIndex - 1);
            }
        });

        // Click to select player
        pmRows.forEach((row, i) => {
            row.addEventListener('click', () => updatePMSelection(i));
        });

        // PM Try Other Analysis button
        const pmTryOther = document.getElementById('pmTryOther');
        if (pmTryOther) {
            pmTryOther.addEventListener('click', function() {
                document.getElementById('step3').style.display = 'none';
                document.getElementById('playerMatchResults').classList.remove('active');
                document.getElementById('step2').style.display = 'block';
                showAnalysisOptions();
                // Pre-select ideal form
                document.querySelectorAll('.analysis-type-btn').forEach(b => {
                    b.classList.remove('selected');
                    if (b.dataset.type === 'ideal') b.classList.add('selected');
                });
            });
        }

        // PM New Comparison button
        const pmNewComparison = document.getElementById('pmNewComparison');
        if (pmNewComparison) {
            pmNewComparison.addEventListener('click', function() {
                document.getElementById('step3').style.display = 'none';
                document.getElementById('playerMatchResults').classList.remove('active');
                document.getElementById('step2').style.display = 'block';
                goBackToRecord();
            });
        }
    </script>
</body>
</html>

