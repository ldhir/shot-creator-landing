<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ShotSync - Basketball Shot Analysis</title>
    <link rel="stylesheet" href="/tool/style.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&family=Work+Sans:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        /* 3D Skeleton Viewer Styles */
        .skeleton-viewer-container {
            position: relative;
            width: 100%;
            height: 100%;
            min-height: 350px;
            display: flex;
            flex-direction: column;
            border-radius: 12px;
            overflow: hidden;
            background: #1a1a1a;
        }

        #skeletonCanvas3d {
            width: 100%;
            flex: 1;
            min-height: 280px;
            background: #1a1a1a;
            display: block;
        }

        .skeleton-controls {
            height: 50px;
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 0 16px;
            background: rgba(0,0,0,0.95);
            border-top: 1px solid #333;
            flex-shrink: 0;
        }

        .frame-slider {
            flex: 1;
            height: 6px;
            background: #333;
            border-radius: 3px;
            accent-color: var(--primary-color);
            cursor: pointer;
            -webkit-appearance: none;
        }

        .frame-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: var(--primary-color);
            border-radius: 50%;
            cursor: pointer;
        }

        .skeleton-btn {
            background: var(--primary-color);
            border: none;
            border-radius: 6px;
            padding: 6px 14px;
            color: white;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
        }

        .skeleton-btn:hover {
            background: var(--primary-hover);
        }

        #frameCounter {
            color: #888;
            font-size: 12px;
            min-width: 70px;
            text-align: right;
            font-family: 'Work Sans', sans-serif;
        }

        .camera-controls {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-left: 12px;
            padding-left: 12px;
            border-left: 1px solid #444;
        }

        .camera-controls label {
            color: #888;
            font-size: 12px;
            cursor: default;
        }

        .camera-slider {
            width: 60px;
            height: 4px;
            background: #333;
            border-radius: 2px;
            accent-color: var(--primary-color);
            cursor: pointer;
            -webkit-appearance: none;
        }

        /* Shot Count Selector Styles */
        .shot-count-btn {
            padding: 10px 20px;
            border: 2px solid var(--border-color);
            border-radius: 8px;
            background: var(--bg-card);
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s;
            color: var(--text-dark);
        }

        .shot-count-btn:hover {
            border-color: var(--primary-color);
            background: rgba(255, 107, 122, 0.1);
        }

        .shot-count-btn.active {
            border-color: var(--primary-color);
            background: rgba(255, 107, 122, 0.15);
            color: var(--primary-color);
        }

        .camera-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 10px;
            height: 10px;
            background: var(--primary-color);
            border-radius: 50%;
            cursor: pointer;
        }

        /* Processing overlay for skeleton extraction */
        .skeleton-processing {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 15;
            border-radius: 12px;
        }

        .skeleton-processing .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid #333;
            border-top-color: var(--primary-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        .skeleton-processing p {
            color: #ccc;
            margin-top: 16px;
            font-size: 14px;
        }

        #processingSaying {
            transition: opacity 0.2s ease;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Athletic Theme Overrides - Consistent with Landing Page */

        /* Player Button Hover Effects */
        .player-btn:hover {
            transform: translateY(-4px) !important;
            border-color: var(--primary-color) !important;
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.4) !important;
            background: var(--bg-card) !important;
        }

        .player-btn:active {
            transform: translateY(-2px) !important;
        }

        .custom-btn:hover {
            background: var(--bg-card) !important;
            border-color: var(--primary-hover) !important;
            border-style: solid !important;
        }

        .player-btn {
            outline: none !important;
        }

        .player-btn:focus {
            outline: 3px solid rgba(255, 107, 122, 0.3) !important;
            outline-offset: 2px !important;
        }

        /* Upload Mode Toggle Styles */
        .mode-toggle-btn {
            flex: 1;
            min-width: 140px;
            height: 44px;
            padding: 12px 24px;
            background: var(--bg-card);
            border: 2px solid var(--border-color);
            border-radius: 0;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 14px;
            font-weight: 700;
            font-family: 'Work Sans', sans-serif;
            letter-spacing: 1px;
            text-transform: uppercase;
            color: var(--text-dark);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            white-space: nowrap;
        }

        .mode-toggle-btn.active {
            background: var(--gradient-main);
            color: white;
            border-color: var(--primary-color);
        }

        .mode-toggle-btn:hover:not(.active) {
            border-color: var(--primary-color);
            background: var(--bg-elevated);
            color: var(--text-dark);
        }

        #uploadedFileName {
            font-style: normal;
            padding: 8px 12px;
            background: var(--bg-card);
            border-radius: 0;
            color: var(--text-gray);
            font-size: 13px;
        }

        /* Navbar Tab Styles */
        .nav-tab {
            background: none;
            border: none;
            padding: 10px 20px;
            font-family: 'Work Sans', sans-serif;
            font-size: 13px;
            font-weight: 600;
            letter-spacing: 2px;
            text-transform: uppercase;
            color: var(--text-gray);
            cursor: pointer;
            border-bottom: 3px solid transparent;
            transition: all 0.3s;
        }

        .nav-tab:hover {
            color: var(--primary-color);
        }

        .nav-tab.active {
            color: var(--primary-color);
            border-bottom-color: var(--primary-color);
        }

        /* Analysis Type Button Styles */
        .analysis-type-btn {
            background: var(--bg-card);
            border: 2px solid var(--border-color);
            border-radius: 8px;
            padding: 24px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 10px;
            width: 220px;
            height: 140px;
            color: var(--text-dark);
        }

        .analysis-type-btn:hover {
            border-color: var(--primary-color);
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.3);
        }

        .analysis-type-btn.selected {
            border-color: var(--primary-color);
            background: rgba(255, 107, 122, 0.15);
        }

        .analysis-icon { font-size: 32px; }

        .analysis-title {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 18px;
            letter-spacing: 1px;
            text-transform: uppercase;
        }

        .analysis-desc {
            font-size: 12px;
            color: var(--text-gray);
            text-align: center;
        }

        /* Body Warning Overlay */
        .body-warning-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
            border-radius: 12px;
        }

        .body-warning-overlay .warning-content {
            text-align: center;
            color: white;
            padding: 30px;
        }

        .body-warning-overlay .warning-icon {
            font-size: 48px;
            margin-bottom: 15px;
        }

        .body-warning-overlay h3 {
            color: #FF6B7A;
            font-family: 'Bebas Neue', sans-serif;
            font-size: 24px;
            letter-spacing: 2px;
            margin-bottom: 10px;
        }

        .body-warning-overlay p {
            color: #ccc;
            font-size: 14px;
        }

        /* Video Ready Overlay (neutral - waiting for analysis selection) */
        .video-ready-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
            border-radius: 12px;
        }

        .video-ready-overlay .ready-content {
            text-align: center;
            color: white;
            padding: 30px;
        }

        .video-ready-overlay .ready-icon {
            font-size: 48px;
            margin-bottom: 15px;
        }

        .video-ready-overlay h3 {
            color: #60a5fa;
            font-family: 'Bebas Neue', sans-serif;
            font-size: 24px;
            letter-spacing: 2px;
            margin-bottom: 10px;
        }

        .video-ready-overlay p {
            color: #ccc;
            font-size: 14px;
        }

        /* Running Analysis Overlay (green - actually processing) */
        .analysis-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
            border-radius: 12px;
        }

        .analysis-overlay .analysis-content {
            text-align: center;
            color: white;
            padding: 30px;
        }

        .analysis-overlay .analysis-spinner {
            width: 50px;
            height: 50px;
            border: 4px solid rgba(255, 255, 255, 0.2);
            border-top-color: #4ade80;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .analysis-overlay h3 {
            color: #4ade80;
            font-family: 'Bebas Neue', sans-serif;
            font-size: 24px;
            letter-spacing: 2px;
            margin-bottom: 10px;
        }

        .analysis-overlay p {
            color: #ccc;
            font-size: 14px;
        }

        /* Stat Card Styles */
        .stat-card {
            background: var(--bg-card);
            padding: 24px;
            border-radius: 0;
            box-shadow: none;
            text-align: center;
            border: 1px solid var(--border-color);
            transition: all 0.3s ease;
        }

        .stat-card:hover {
            border-color: rgba(255, 107, 122, 0.3);
        }

        .stat-label {
            font-size: 12px;
            color: var(--text-gray);
            margin-bottom: 12px;
            font-family: 'Work Sans', sans-serif;
            font-weight: 700;
            letter-spacing: 1px;
            text-transform: uppercase;
        }

        .stat-value {
            font-size: 36px;
            font-weight: 400;
            color: var(--primary-color);
            font-family: 'Bebas Neue', sans-serif;
            letter-spacing: 2px;
        }

        /* Badge Card Styles */
        .badge-card {
            background: var(--bg-card);
            padding: 32px;
            border-radius: 0;
            box-shadow: none;
            text-align: center;
            transition: all 0.3s ease;
            border: 1px solid var(--border-color);
        }

        .badge-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 12px 40px rgba(0,0,0,0.4);
            border-color: var(--primary-color);
        }

        .badge-card.locked {
            opacity: 0.5;
        }

        .badge-icon {
            font-size: 64px;
            margin-bottom: 16px;
        }

        .badge-name {
            font-size: 18px;
            font-weight: 400;
            color: var(--text-dark);
            margin-bottom: 10px;
            font-family: 'Bebas Neue', sans-serif;
            letter-spacing: 2px;
            text-transform: uppercase;
        }

        .badge-level {
            font-weight: 700;
            font-family: 'Work Sans', sans-serif;
            font-size: 13px;
            letter-spacing: 1px;
            text-transform: uppercase;
        }

        .badge-level.bronze {
            color: #cd7f32;
        }

        .badge-level.silver {
            color: #c0c0c0;
        }

        .badge-level.gold {
            color: #ffd700;
        }

        .badge-level.none {
            color: var(--text-muted);
        }

        /* Chart Tab Styles */
        .chart-tab {
            background: none;
            border: none;
            padding: 12px 24px;
            font-family: 'Work Sans', sans-serif;
            font-size: 13px;
            font-weight: 700;
            letter-spacing: 1px;
            text-transform: uppercase;
            color: var(--text-gray);
            cursor: pointer;
            border-bottom: 3px solid transparent;
            transition: all 0.3s;
        }

        .chart-tab:hover {
            color: var(--primary-color);
        }

        .chart-tab.active {
            color: var(--primary-color);
            border-bottom-color: var(--primary-color);
        }

        .period-tab {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            padding: 8px 16px;
            font-family: 'Work Sans', sans-serif;
            font-size: 12px;
            font-weight: 600;
            letter-spacing: 1px;
            text-transform: uppercase;
            color: var(--text-gray);
            cursor: pointer;
            border-radius: 0;
            transition: all 0.2s ease;
        }

        .period-tab:hover {
            background: var(--bg-elevated);
            border-color: var(--primary-color);
            color: var(--text-dark);
        }

        .period-tab.active {
            background: var(--gradient-main);
            border-color: var(--primary-color);
            color: white;
        }

        /* Food Log Entry Styles */
        .food-log-entry {
            padding: 16px;
            background: var(--bg-card);
            border-radius: 0;
            display: grid;
            grid-template-columns: 2fr 1fr 1fr 1fr auto;
            gap: 15px;
            align-items: center;
            border: 1px solid var(--border-color);
        }

        .food-log-entry.editing {
            background: rgba(255, 107, 122, 0.1);
            border-color: var(--primary-color);
        }

        .favorite-badge {
            display: inline-block;
            padding: 8px 16px;
            background: var(--bg-card);
            border: 2px solid var(--primary-color);
            border-radius: 0;
            cursor: pointer;
            transition: all 0.3s;
            font-family: 'Work Sans', sans-serif;
            font-size: 13px;
            font-weight: 600;
            letter-spacing: 1px;
            text-transform: uppercase;
            color: var(--primary-color);
        }

        .favorite-badge:hover {
            background: var(--primary-color);
            color: white;
        }

        .favorite-badge input {
            width: 60px;
            padding: 6px;
            border: 1px solid var(--border-color);
            border-radius: 0;
            text-align: center;
            font-family: 'Work Sans', sans-serif;
            background: var(--bg-primary);
            color: var(--text-dark);
        }

        /* ========== Player Match Results UI ========== */
        .player-match-results { display: none; }
        .player-match-results.active { display: block; }

        .pm-grid {
            display: grid;
            grid-template-columns: 1fr 380px;
            gap: 40px;
            align-items: start;
        }

        .pm-left { min-width: 0; }
        .pm-right { position: sticky; top: 20px; }

        .pm-list { display: flex; flex-direction: column; gap: 12px; }

        .pm-row {
            display: flex;
            align-items: center;
            gap: 20px;
            padding: 16px 20px;
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .pm-row:hover { border-color: var(--primary-color); transform: translateX(4px); }
        .pm-row-selected { border: 2px solid var(--primary-color); background: rgba(255, 107, 122, 0.1); }

        .pm-rank { font-family: 'Bebas Neue', sans-serif; font-size: 24px; color: var(--text-gray); min-width: 40px; text-align: center; }
        .pm-rank-1 { font-size: 32px; color: var(--primary-color); }

        .pm-info { flex: 1; min-width: 150px; }
        .pm-name { font-weight: 600; font-size: 16px; margin-bottom: 2px; }
        .pm-archetype { font-size: 13px; color: var(--text-gray); }

        .pm-similarity { flex: 1; max-width: 180px; }
        .pm-score { font-weight: 600; margin-bottom: 6px; font-size: 14px; }
        .pm-bar { height: 6px; background: var(--border-color); border-radius: 3px; overflow: hidden; }
        .pm-fill { height: 100%; background: var(--primary-color); border-radius: 3px; }

        .pm-stats { display: flex; gap: 16px; font-size: 13px; color: var(--text-gray); }
        .pm-stats span { white-space: nowrap; }

        /* User Archetype Card */
        .pm-archetype-card {
            background: var(--bg-card);
            border: 2px solid var(--primary-color);
            border-radius: 16px;
            padding: 30px;
            text-align: center;
            margin-bottom: 24px;
        }
        .pm-arch-label { font-size: 12px; text-transform: uppercase; letter-spacing: 2px; color: var(--text-gray); margin-bottom: 12px; }
        .pm-arch-name { font-family: 'Bebas Neue', sans-serif; font-size: 42px; letter-spacing: 2px; color: var(--primary-color); margin-bottom: 12px; }
        .pm-arch-desc { color: var(--text-gray); font-size: 14px; line-height: 1.6; }

        /* Traits & Differences */
        .pm-traits, .pm-differences {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 24px;
            margin-bottom: 16px;
        }
        .pm-section-header { display: flex; align-items: center; gap: 10px; margin-bottom: 16px; padding-bottom: 12px; border-bottom: 1px solid var(--border-color); }
        .pm-section-title { font-size: 14px; font-weight: 600; }
        .pm-player-name { color: var(--primary-color); font-size: 14px; }

        .pm-trait-item, .pm-diff-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px 12px;
            background: var(--bg-dark);
            border-radius: 8px;
            margin-bottom: 12px;
        }
        .pm-trait-item:last-child, .pm-diff-item:last-child { margin-bottom: 0; }

        .pm-trait-icon, .pm-diff-icon {
            width: 32px; height: 32px;
            display: flex; align-items: center; justify-content: center;
            border-radius: 6px; font-size: 16px;
        }
        .pm-trait-icon { background: rgba(255, 107, 122, 0.15); }
        .pm-diff-icon { background: rgba(251, 191, 36, 0.15); }

        .pm-trait-text, .pm-diff-text { flex: 1; }
        .pm-trait-name, .pm-diff-name { font-weight: 500; font-size: 14px; margin-bottom: 2px; }
        .pm-trait-detail, .pm-diff-detail { font-size: 12px; color: var(--text-gray); }
        .pm-trait-match { font-size: 13px; font-weight: 600; color: var(--success-color); }
        .pm-diff-gap { font-size: 13px; font-weight: 600; color: var(--warning-color); }

        /* Quick Fixes */
        .pm-fixes-header { font-family: 'Bebas Neue', sans-serif; font-size: 20px; letter-spacing: 1px; margin: 24px 0 16px; display: flex; align-items: center; gap: 10px; }
        .pm-fix-item { background: var(--bg-card); border: 1px solid var(--border-color); border-radius: 12px; overflow: hidden; margin-bottom: 12px; }
        .pm-fix-toggle {
            width: 100%; background: none; border: none; padding: 16px 20px;
            cursor: pointer; display: flex; align-items: center; gap: 16px;
            color: var(--text-light); transition: all 0.2s ease;
        }
        .pm-fix-toggle:hover { background: rgba(255, 107, 122, 0.05); }
        .pm-fix-item.active .pm-fix-toggle { background: rgba(255, 107, 122, 0.1); }

        .pm-fix-icon { width: 40px; height: 40px; display: flex; align-items: center; justify-content: center; background: rgba(255, 107, 122, 0.15); border-radius: 8px; font-size: 20px; }
        .pm-fix-content { flex: 1; text-align: left; }
        .pm-fix-title { font-weight: 600; font-size: 15px; margin-bottom: 4px; }
        .pm-fix-tip { font-size: 13px; color: var(--text-gray); }
        .pm-fix-arrow { font-size: 16px; color: var(--text-gray); transition: transform 0.3s ease; }
        .pm-fix-item.active .pm-fix-arrow { transform: rotate(180deg); color: var(--primary-color); }

        .pm-drill-content { display: none; padding: 0 20px 20px 20px; }
        .pm-fix-item.active .pm-drill-content { display: block; }
        .pm-drill-card { background: var(--bg-dark); border-radius: 10px; padding: 20px; border: 1px solid var(--border-color); }
        .pm-drill-label { font-size: 11px; text-transform: uppercase; letter-spacing: 1px; color: var(--primary-color); margin-bottom: 8px; }
        .pm-drill-name { font-weight: 600; font-size: 16px; margin-bottom: 10px; }
        .pm-drill-desc { font-size: 13px; color: var(--text-gray); line-height: 1.6; margin-bottom: 14px; }
        .pm-drill-meta { display: flex; gap: 16px; font-size: 12px; color: var(--text-gray); }
        .pm-drill-footer { display: flex; justify-content: space-between; align-items: center; margin-top: 0; }
        .pm-yt-link {
            display: flex; align-items: center; justify-content: center;
            width: 32px; height: 32px; background: rgba(255, 0, 0, 0.1);
            border-radius: 6px; transition: all 0.2s; text-decoration: none;
        }
        .pm-yt-link:hover { background: rgba(255, 0, 0, 0.25); transform: scale(1.1); }
        .pm-yt-link svg { width: 18px; height: 18px; fill: #FF0000; }

        @media (max-width: 900px) {
            .pm-grid { grid-template-columns: 1fr; }
            .pm-right { position: static; order: -1; }
        }

        /* ========== Ideal Form Results UI ========== */
        .ideal-form-results { display: none; padding-top: 32px; }
        .ideal-form-results.active { display: block; }


        .if-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 32px;
            padding-bottom: 24px;
            border-bottom: 1px solid var(--border-color);
        }

        .if-title {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 48px;
            letter-spacing: 3px;
            line-height: 1;
            margin-bottom: 12px;
        }
        .if-title span { color: var(--primary-color); }

        .if-player-info {
            display: flex;
            gap: 24px;
            font-size: 14px;
            color: var(--text-gray);
        }
        .if-player-info .if-label {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--text-muted);
            margin-right: 6px;
        }

        .if-consistency-box { text-align: right; }
        .if-consistency-label {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            color: var(--text-muted);
            margin-bottom: 8px;
        }
        .if-consistency-value {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 48px;
            color: #00D4FF;
            line-height: 1;
        }
        .if-consistency-toggle {
            display: flex;
            gap: 4px;
            margin-top: 12px;
            background: var(--bg-card);
            border-radius: 8px;
            padding: 4px;
        }
        .if-toggle-btn {
            background: none;
            border: none;
            padding: 6px 12px;
            font-size: 11px;
            font-family: 'Work Sans', sans-serif;
            font-weight: 500;
            color: var(--text-muted);
            cursor: pointer;
            border-radius: 6px;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .if-toggle-btn:hover { color: var(--text-gray); }
        .if-toggle-btn.active { background: var(--primary-color); color: var(--bg-dark); }

        .if-main {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 32px;
            margin-bottom: 40px;
        }

        .if-metrics-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
        }

        .if-metric-card {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 20px;
            transition: all 0.2s ease;
        }
        .if-metric-card:hover { border-color: var(--primary-color); }

        .if-metric-title {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 13px;
            text-transform: uppercase;
            letter-spacing: 2px;
            color: var(--text-muted);
            margin-bottom: 16px;
        }

        /* Rhythm Bars */
        .if-rhythm-viz { display: flex; flex-direction: column; gap: 12px; }
        .if-rhythm-bar-container { display: flex; align-items: center; gap: 12px; }
        .if-rhythm-label { font-size: 11px; color: var(--text-gray); width: 50px; text-transform: uppercase; letter-spacing: 0.5px; }
        .if-rhythm-track { flex: 1; height: 8px; background: var(--border-color); border-radius: 4px; position: relative; }
        .if-rhythm-marker {
            position: absolute;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 16px;
            height: 16px;
            border-radius: 50%;
            transition: left 0.4s ease;
        }
        .if-rhythm-marker.knee { background: #00D4FF; box-shadow: 0 0 12px rgba(0, 212, 255, 0.6); }
        .if-rhythm-marker.elbow { background: var(--primary-color); box-shadow: 0 0 12px rgba(255, 107, 122, 0.6); }
        .if-rhythm-status {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 8px;
            font-size: 12px;
        }
        .if-rhythm-status.aligned { color: var(--success-color); }
        .if-rhythm-status.offset { color: var(--warning-color); }
        .if-rhythm-dot { width: 6px; height: 6px; border-radius: 50%; background: currentColor; }

        /* Arc Meter */
        .if-arc-container { display: flex; flex-direction: column; align-items: center; }
        .if-arc-svg { width: 100%; max-width: 140px; }
        .if-arc-value {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 28px;
            margin-top: 8px;
        }
        .if-arc-unit { font-size: 14px; color: var(--text-muted); font-weight: 400; }

        /* Foot Stance */
        .if-stance-viz { display: flex; flex-direction: column; align-items: center; gap: 12px; }
        .if-stance-track {
            width: 100%;
            height: 36px;
            background: var(--border-color);
            border-radius: 8px;
            position: relative;
        }
        .if-stance-zone {
            position: absolute;
            top: 0;
            height: 100%;
            background: rgba(61, 214, 140, 0.15);
            border-left: 2px dashed var(--success-color);
            border-right: 2px dashed var(--success-color);
        }
        .if-stance-foot {
            position: absolute;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 10px;
            height: 22px;
            border-radius: 5px;
            background: var(--primary-color);
            box-shadow: 0 0 8px rgba(255, 107, 122, 0.5);
        }
        .if-stance-label { font-size: 12px; color: var(--text-gray); }

        /* Release Height */
        .if-release-viz { display: flex; align-items: flex-end; gap: 16px; height: 100px; }
        .if-release-bar {
            flex: 1;
            height: 100%;
            background: var(--border-color);
            border-radius: 8px;
            position: relative;
            overflow: hidden;
        }
        .if-release-fill {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(180deg, #00D4FF 0%, rgba(0, 212, 255, 0.3) 100%);
            border-radius: 0 0 8px 8px;
            transition: height 0.5s ease;
        }
        .if-release-target {
            position: absolute;
            left: 0;
            right: 0;
            background: rgba(61, 214, 140, 0.2);
            border-top: 2px dashed var(--success-color);
            border-bottom: 2px dashed var(--success-color);
        }
        .if-release-info { display: flex; flex-direction: column; gap: 2px; }
        .if-release-value { font-family: 'Bebas Neue', sans-serif; font-size: 28px; color: #00D4FF; }
        .if-release-target-text { font-size: 11px; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.5px; }

        /* Radar Chart Container */
        .if-radar-container {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 16px;
            padding: 24px;
            height: 100%;
            display: flex;
            flex-direction: column;
        }
        .if-radar-title {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 16px;
            text-transform: uppercase;
            letter-spacing: 2px;
            color: var(--text-gray);
            margin-bottom: 16px;
            text-align: center;
        }
        .if-radar-chart {
            flex: 1;
            min-height: 280px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .if-radar-legend {
            display: flex;
            justify-content: center;
            gap: 24px;
            margin-top: 16px;
        }
        .if-legend-item { display: flex; align-items: center; gap: 8px; font-size: 12px; color: var(--text-gray); }
        .if-legend-dot { width: 10px; height: 10px; border-radius: 50%; }
        .if-legend-dot.player { background: var(--primary-color); }
        .if-legend-dot.ideal { background: var(--success-color); opacity: 0.5; }

        /* Bottom Sections */
        .if-bottom {
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 32px;
        }

        .if-section-title {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 20px;
            letter-spacing: 2px;
            margin-bottom: 16px;
            display: flex;
            align-items: center;
            gap: 12px;
        }
        .if-section-title::before {
            content: '';
            width: 4px;
            height: 18px;
            background: var(--primary-color);
            border-radius: 2px;
        }

        .if-tips-list { list-style: none; display: flex; flex-direction: column; gap: 10px; }
        .if-tip-item {
            display: flex;
            align-items: flex-start;
            gap: 12px;
            padding: 14px;
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 10px;
            font-size: 14px;
            line-height: 1.5;
            color: var(--text-gray);
            transition: all 0.2s ease;
        }
        .if-tip-item:hover { border-color: #00D4FF; }
        .if-tip-bullet {
            width: 6px;
            height: 6px;
            background: #00D4FF;
            border-radius: 50%;
            margin-top: 6px;
            flex-shrink: 0;
        }

        .if-workon-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 16px; }
        .if-workon-card {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 20px;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        .if-workon-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, var(--primary-color) 0%, var(--warning-color) 100%);
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        .if-workon-card:hover { border-color: var(--primary-color); transform: translateY(-4px); }
        .if-workon-card:hover::before { opacity: 1; }

        .if-workon-title {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 16px;
            letter-spacing: 1px;
            margin-bottom: 8px;
        }
        .if-workon-desc { font-size: 13px; color: var(--text-gray); line-height: 1.5; margin-bottom: 14px; }
        .if-workon-drill {
            background: rgba(0, 212, 255, 0.08);
            border: 1px solid rgba(0, 212, 255, 0.2);
            border-radius: 8px;
            padding: 12px;
        }
        .if-workon-drill-label { font-size: 10px; text-transform: uppercase; letter-spacing: 1.5px; color: #00D4FF; margin-bottom: 4px; }
        .if-workon-drill-name { font-weight: 600; font-size: 13px; margin-bottom: 4px; }
        .if-workon-drill-tip { font-size: 11px; color: var(--text-muted); line-height: 1.4; }

        @media (max-width: 900px) {
            .if-main { grid-template-columns: 1fr; }
            .if-metrics-grid { grid-template-columns: 1fr; }
            .if-bottom { grid-template-columns: 1fr; }
            .if-workon-grid { grid-template-columns: 1fr; }
            .if-header { flex-direction: column; gap: 20px; }
            .if-consistency-box { text-align: left; }
            .if-title { font-size: 36px; }
        }
    </style>
    <!-- MediaPipe -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js" crossorigin="anonymous"></script>
    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation"></script>
    <!-- Google Calendar API -->
    <script src="https://apis.google.com/js/api.js" onload="window.gapiLoaded && window.gapiLoaded()" onerror="console.error('Failed to load Google API')"></script>
    <script>
        window.gapiLoaded = function() {
            console.log('Google API loaded');
        };
    </script>
    <!-- EmailJS -->
    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/@emailjs/browser@4/dist/email.min.js"></script>
    <!-- Firebase -->
    <script type="module">
        // Import Firebase modules
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
        import { getAuth, GoogleAuthProvider, signInWithPopup, signOut, onAuthStateChanged } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js';
        import { getFirestore, collection, addDoc, getDocs, query, where, orderBy, limit, doc, getDoc, setDoc, updateDoc, deleteDoc, serverTimestamp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js';
        
        // Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyBnM_7z6rqd0Wnv3LdnTWDtiy_pKiWZeso",
            authDomain: "shotsyn-c24ae.firebaseapp.com",
            projectId: "shotsyn-c24ae",
            storageBucket: "shotsyn-c24ae.firebasestorage.app",
            messagingSenderId: "845157536043",
            appId: "1:845157536043:web:945c7961316be19549b56e"
        };
        
        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        const googleProvider = new GoogleAuthProvider();
        
        // Make Firebase available globally
        window.firebaseAuth = auth;
        window.firebaseDB = db;
        window.googleProvider = googleProvider;
        window.signInWithGoogle = async () => {
            try {
                console.log('signInWithGoogle called');
                if (!auth) {
                    throw new Error('Firebase auth is not initialized');
                }
                if (!googleProvider) {
                    throw new Error('Google provider is not initialized');
                }
                
                console.log('Calling signInWithPopup...');
                const result = await signInWithPopup(auth, googleProvider);
                const user = result.user;
                console.log('Sign-in popup completed, user:', user);
                console.log('User UID:', user.uid);
                console.log('User email:', user.email);
                
                // Verify user is actually signed in
                const currentUser = auth.currentUser;
                if (!currentUser || currentUser.uid !== user.uid) {
                    console.error('User not properly authenticated after sign-in');
                    throw new Error('Authentication failed: User not properly signed in');
                }
                
                console.log('User successfully authenticated');
                return {
                    firstName: user.displayName?.split(' ')[0] || '',
                    lastName: user.displayName?.split(' ').slice(1).join(' ') || '',
                    email: user.email || ''
                };
            } catch (error) {
                console.error('Error signing in:', error);
                console.error('Error details:', {
                    code: error.code,
                    message: error.message,
                    email: error.email,
                    credential: error.credential
                });
                throw error;
            }
        };
        window.signOutUser = () => signOut(auth);
        window.onAuthStateChangedHandler = onAuthStateChanged;
        window.saveUserEmail = async (email, firstName, lastName) => {
            try {
                const user = auth.currentUser;
                if (user) {
                    await addDoc(collection(db, 'users'), {
                        userId: user.uid,
                        email: email,
                        firstName: firstName,
                        lastName: lastName,
                        createdAt: serverTimestamp()
                    });
                }
            } catch (error) {
                console.error('Error saving email:', error);
            }
        };
        window.saveAnalysis = async (userId, analysisData) => {
            try {
                await addDoc(collection(db, 'analyses'), {
                    userId: userId,
                    ...analysisData,
                    createdAt: serverTimestamp()
                });
            } catch (error) {
                console.error('Error saving analysis:', error);
            }
        };
        
        // Save similarity score to training database
        window.saveSimilarityScore = async (userId, player, similarityScore) => {
            try {
                await addDoc(collection(db, 'trainingScores'), {
                    userId: userId,
                    player: player,
                    similarityScore: similarityScore,
                    createdAt: serverTimestamp()
                });
            } catch (error) {
                console.error('Error saving similarity score:', error);
            }
        };
        
        // Save shot tracker data to training database
        window.saveShotTrackerToTrainingDb = async (userId, shotData) => {
            try {
                console.log('Saving shot tracker data:', { userId, shotCount: shotData.shots.length });
                
                // Calculate statistics
                const makes = shotData.shots.filter(s => s.is_make || s.result === 'make').length;
                const attempts = shotData.shots.length;
                const percentage = attempts > 0 ? Math.round((makes / attempts) * 100) : 0;
                
                // Prepare shot locations data
                const shotLocations = shotData.shots.map(shot => ({
                    x: parseFloat(shot.x) || 0.5,
                    y: parseFloat(shot.y) || 0.5,
                    is_make: shot.is_make || shot.result === 'make',
                    timestamp: shot.timestamp || Date.now()
                }));
                
                console.log('Prepared data:', { makes, attempts, percentage, shotLocationsCount: shotLocations.length });
                
                // Save to training database with shot locations
                const docRef = await addDoc(collection(window.firebaseDB, 'trainingScores'), {
                    userId: userId,
                    player: 'shot_tracker', // Special identifier for shot tracker sessions
                    similarityScore: percentage, // Use percentage as similarity score
                    makes: makes,
                    attempts: attempts,
                    shotLocations: shotLocations,
                    sessionType: 'shot_tracker',
                    createdAt: serverTimestamp()
                });
                
                console.log('Successfully saved to Firebase with ID:', docRef.id);
                return { success: true, makes, attempts, percentage };
            } catch (error) {
                console.error('Error saving shot tracker to training database:', error);
                console.error('Error details:', {
                    code: error.code,
                    message: error.message,
                    stack: error.stack
                });
                throw error;
            }
        };
        
        // Get training scores for a user
        window.getTrainingScores = async (userId, player = null) => {
            try {
                let q;
                if (player) {
                    q = query(collection(db, 'trainingScores'), where('userId', '==', userId), where('player', '==', player));
                } else {
                    q = query(collection(db, 'trainingScores'), where('userId', '==', userId));
                }
                const querySnapshot = await getDocs(q);
                const scores = [];
                querySnapshot.forEach((doc) => {
                    scores.push({ id: doc.id, ...doc.data() });
                });
                // Sort by createdAt descending (client-side if orderBy fails)
                scores.sort((a, b) => {
                    const aTime = a.createdAt?.toDate ? a.createdAt.toDate().getTime() : (a.createdAt?.seconds || 0) * 1000;
                    const bTime = b.createdAt?.toDate ? b.createdAt.toDate().getTime() : (b.createdAt?.seconds || 0) * 1000;
                    return bTime - aTime;
                });
                return scores;
            } catch (error) {
                console.error('Error getting training scores:', error);
                // If index error, try without orderBy
                try {
                    let q = query(collection(db, 'trainingScores'), where('userId', '==', userId));
                    if (player) {
                        q = query(collection(db, 'trainingScores'), where('userId', '==', userId), where('player', '==', player));
                    }
                    const querySnapshot = await getDocs(q);
                    const scores = [];
                    querySnapshot.forEach((doc) => {
                        scores.push({ id: doc.id, ...doc.data() });
                    });
                    scores.sort((a, b) => {
                        const aTime = a.createdAt?.toDate ? a.createdAt.toDate().getTime() : (a.createdAt?.seconds || 0) * 1000;
                        const bTime = b.createdAt?.toDate ? b.createdAt.toDate().getTime() : (b.createdAt?.seconds || 0) * 1000;
                        return bTime - aTime;
                    });
                    return scores;
                } catch (retryError) {
                    console.error('Error retrying query:', retryError);
                    return [];
                }
            }
        };
        
        // Track login streak
        window.updateLoginStreak = async (userId) => {
            try {
                const userRef = doc(db, 'users', userId);
                const userDoc = await getDoc(userRef);
                const today = new Date().toDateString();
                
                if (userDoc.exists()) {
                    const userData = userDoc.data();
                    const lastLogin = userData.lastLoginDate;
                    const currentStreak = userData.loginStreak || 0;
                    
                    if (lastLogin === today) {
                        // Already logged in today
                        return currentStreak;
                    }
                    
                    const yesterday = new Date();
                    yesterday.setDate(yesterday.getDate() - 1);
                    const yesterdayStr = yesterday.toDateString();
                    
                    let newStreak = 1;
                    if (lastLogin === yesterdayStr) {
                        // Continuing streak
                        newStreak = currentStreak + 1;
                    }
                    
                    await updateDoc(userRef, {
                        lastLoginDate: today,
                        loginStreak: newStreak
                    });
                    
                    return newStreak;
                } else {
                    // First login
                    await setDoc(userRef, {
                        lastLoginDate: today,
                        loginStreak: 1
                    }, { merge: true });
                    return 1;
                }
            } catch (error) {
                console.error('Error updating login streak:', error);
                return 0;
            }
        };
        
        // Get user badges
        window.getUserBadges = async (userId) => {
            try {
                const userRef = doc(db, 'users', userId);
                const userDoc = await getDoc(userRef);
                if (userDoc.exists()) {
                    return userDoc.data().badges || {};
                }
                return {};
            } catch (error) {
                console.error('Error getting user badges:', error);
                return {};
            }
        };
        
        // Award badge
        window.awardBadge = async (userId, badgeType, level) => {
            try {
                const userRef = doc(db, 'users', userId);
                const userDoc = await getDoc(userRef);
                const badges = userDoc.exists() ? (userDoc.data().badges || {}) : {};
                
                // Only award if user doesn't already have this badge at this level or higher
                const currentLevel = badges[badgeType] || 'none';
                const levels = { 'none': 0, 'bronze': 1, 'silver': 2, 'gold': 3 };
                
                if (levels[level] > levels[currentLevel]) {
                    badges[badgeType] = level;
                    await updateDoc(userRef, {
                        badges: badges
                    }, { merge: true });
                    return true;
                }
                return false;
            } catch (error) {
                console.error('Error awarding badge:', error);
                return false;
            }
        };
        
        // Save nutrition goals
        window.saveNutritionGoals = async (userId, calorieGoal, idealWeight, proteinGoal) => {
            try {
                const userRef = doc(db, 'users', userId);
                await updateDoc(userRef, {
                    nutritionGoals: {
                        calorieGoal: calorieGoal,
                        idealWeight: idealWeight,
                        proteinGoal: proteinGoal
                    }
                }, { merge: true });
                return true;
            } catch (error) {
                console.error('Error saving nutrition goals:', error);
                return false;
            }
        };
        
        // Get nutrition goals
        window.getNutritionGoals = async (userId) => {
            try {
                const userRef = doc(db, 'users', userId);
                const userDoc = await getDoc(userRef);
                if (userDoc.exists()) {
                    return userDoc.data().nutritionGoals || { calorieGoal: 2000, idealWeight: 150, proteinGoal: 150 };
                }
                return { calorieGoal: 2000, idealWeight: 150, proteinGoal: 150 };
            } catch (error) {
                console.error('Error getting nutrition goals:', error);
                return { calorieGoal: 2000, idealWeight: 150, proteinGoal: 150 };
            }
        };
        
        // Save food entry
        window.saveFoodEntry = async (userId, foodData) => {
            try {
                await addDoc(collection(db, 'nutritionEntries'), {
                    userId: userId,
                    ...foodData,
                    createdAt: serverTimestamp()
                });
                return true;
            } catch (error) {
                console.error('Error saving food entry:', error);
                return false;
            }
        };
        
        // Save global benchmark (for all users)
        window.saveGlobalBenchmark = async (benchmarkData) => {
            try {
                console.log(' Attempting to save global benchmark to Firebase...');
                console.log('Benchmark data length:', benchmarkData?.length || 0);
                
                if (!benchmarkData || benchmarkData.length === 0) {
                    console.error(' Cannot save: benchmark data is empty');
                    return false;
                }
                
                // Convert nested arrays to Firebase-compatible format
                // Firebase doesn't support nested arrays, so we need to convert landmarks arrays
                const firebaseCompatibleData = benchmarkData.map(frame => {
                    // Convert landmarks array of arrays to array of objects
                    const landmarks = frame.landmarks.map((landmark, index) => {
                        if (Array.isArray(landmark) && landmark.length >= 3) {
                            return {
                                x: landmark[0],
                                y: landmark[1],
                                z: landmark[2],
                                index: index
                            };
                        }
                        return {
                            x: landmark?.x || 0,
                            y: landmark?.y || 0,
                            z: landmark?.z || 0,
                            index: index
                        };
                    });
                    
                    return {
                        state: frame.state,
                        time: frame.time,
                        elbow_angle: frame.elbow_angle,
                        wrist_angle: frame.wrist_angle,
                        arm_angle: frame.arm_angle,
                        landmarks: landmarks
                    };
                });
                
                const benchmarkRef = doc(db, 'globalBenchmark', 'custom');
                await setDoc(benchmarkRef, {
                    data: firebaseCompatibleData,
                    updatedAt: serverTimestamp(),
                    frameCount: firebaseCompatibleData.length
                }, { merge: true });
                
                console.log(' Global benchmark saved successfully to Firebase');
                console.log('Saved to path: globalBenchmark/custom');
                console.log('Frame count:', firebaseCompatibleData.length);
                return true;
            } catch (error) {
                console.error(' Error saving global benchmark:', error);
                console.error('Error details:', error.message, error.code);
                return false;
            }
        };
        
        // Get global benchmark (for all users)
        window.getGlobalBenchmark = async () => {
            try {
                const benchmarkRef = doc(db, 'globalBenchmark', 'custom');
                const benchmarkDoc = await getDoc(benchmarkRef);
                if (benchmarkDoc.exists()) {
                    const data = benchmarkDoc.data();
                    const firebaseData = data.data || [];
                    console.log(' Global benchmark loaded:', firebaseData.length, 'frames');
                    
                    // Convert Firebase format back to original format (landmarks as arrays)
                    const convertedData = firebaseData.map(frame => {
                        // Convert landmarks from objects back to arrays
                        const landmarks = frame.landmarks.map(landmark => {
                            if (landmark && typeof landmark === 'object' && 'x' in landmark) {
                                return [landmark.x, landmark.y, landmark.z];
                            }
                            return landmark; // Already in array format
                        });
                        
                        return {
                            state: frame.state,
                            time: frame.time,
                            elbow_angle: frame.elbow_angle,
                            wrist_angle: frame.wrist_angle,
                            arm_angle: frame.arm_angle,
                            landmarks: landmarks
                        };
                    });
                    
                    return convertedData;
                }
                console.log('No global benchmark found');
                return null;
            } catch (error) {
                console.error('Error getting global benchmark:', error);
                return null;
            }
        };
        
        // Get nutrition entries for a date
        window.getNutritionEntries = async (userId, date = null) => {
            try {
                const targetDate = date || new Date().toDateString();
                let q = query(collection(db, 'nutritionEntries'), where('userId', '==', userId));
                const querySnapshot = await getDocs(q);
                const entries = [];
                querySnapshot.forEach((doc) => {
                    const data = doc.data();
                    const entryDate = data.createdAt?.toDate ? data.createdAt.toDate().toDateString() : new Date().toDateString();
                    if (entryDate === targetDate) {
                        entries.push({ id: doc.id, ...data });
                    }
                });
                // Sort by time (most recent first)
                entries.sort((a, b) => {
                    const aTime = a.createdAt?.toDate ? a.createdAt.toDate().getTime() : 0;
                    const bTime = b.createdAt?.toDate ? b.createdAt.toDate().getTime() : 0;
                    return bTime - aTime;
                });
                return entries;
            } catch (error) {
                console.error('Error getting nutrition entries:', error);
                return [];
            }
        };
        
        // Get all nutrition entries for chart
        window.getAllNutritionEntries = async (userId) => {
            try {
                let q = query(collection(db, 'nutritionEntries'), where('userId', '==', userId));
                const querySnapshot = await getDocs(q);
                const entries = [];
                querySnapshot.forEach((doc) => {
                    entries.push({ id: doc.id, ...doc.data() });
                });
                // Sort by date
                entries.sort((a, b) => {
                    const aTime = a.createdAt?.toDate ? a.createdAt.toDate().getTime() : 0;
                    const bTime = b.createdAt?.toDate ? b.createdAt.toDate().getTime() : 0;
                    return aTime - bTime;
                });
                return entries;
            } catch (error) {
                console.error('Error getting all nutrition entries:', error);
                return [];
            }
        };
        
        // Save weight entry
        window.saveWeightEntry = async (userId, weight, date = null) => {
            try {
                const entryDate = date || new Date().toDateString();
                await addDoc(collection(db, 'weightEntries'), {
                    userId: userId,
                    weight: weight,
                    date: entryDate,
                    createdAt: serverTimestamp()
                });
                return true;
            } catch (error) {
                console.error('Error saving weight entry:', error);
                return false;
            }
        };
        
        // Get weight entries
        window.getWeightEntries = async (userId) => {
            try {
                let q = query(collection(db, 'weightEntries'), where('userId', '==', userId));
                const querySnapshot = await getDocs(q);
                const entries = [];
                querySnapshot.forEach((doc) => {
                    entries.push({ id: doc.id, ...doc.data() });
                });
                entries.sort((a, b) => {
                    const aTime = a.createdAt?.toDate ? a.createdAt.toDate().getTime() : 0;
                    const bTime = b.createdAt?.toDate ? b.createdAt.toDate().getTime() : 0;
                    return aTime - bTime;
                });
                return entries;
            } catch (error) {
                console.error('Error getting weight entries:', error);
                return [];
            }
        };
        
        // Save favorite food
        window.saveFavoriteFood = async (userId, favoriteData) => {
            try {
                const userRef = doc(db, 'users', userId);
                const userDoc = await getDoc(userRef);
                const favorites = userDoc.exists() ? (userDoc.data().favoriteFoods || []) : [];
                
                // Check if favorite already exists
                const existingIndex = favorites.findIndex(f => f.name.toLowerCase() === favoriteData.name.toLowerCase());
                if (existingIndex !== -1) {
                    favorites[existingIndex] = favoriteData;
                } else {
                    favorites.push(favoriteData);
                }
                
                await updateDoc(userRef, {
                    favoriteFoods: favorites
                }, { merge: true });
                return true;
            } catch (error) {
                console.error('Error saving favorite food:', error);
                return false;
            }
        };
        
        // Get favorite foods
        window.getFavoriteFoods = async (userId) => {
            try {
                const userRef = doc(db, 'users', userId);
                const userDoc = await getDoc(userRef);
                if (userDoc.exists()) {
                    return userDoc.data().favoriteFoods || [];
                }
                return [];
            } catch (error) {
                console.error('Error getting favorite foods:', error);
                return [];
            }
        };
        
        // Delete favorite food
        window.deleteFavoriteFood = async (userId, favoriteName) => {
            try {
                const userRef = doc(db, 'users', userId);
                const userDoc = await getDoc(userRef);
                if (userDoc.exists()) {
                    const favorites = userDoc.data().favoriteFoods || [];
                    const updatedFavorites = favorites.filter(f => f.name !== favoriteName);
                    await updateDoc(userRef, {
                        favoriteFoods: updatedFavorites
                    }, { merge: true });
                    return true;
                }
                return false;
            } catch (error) {
                console.error('Error deleting favorite food:', error);
                return false;
            }
        };
        
        // Delete food entry from database
        window.deleteFoodEntryFromDB = async (entryId) => {
            try {
                await deleteDoc(doc(db, 'nutritionEntries', entryId));
                return true;
            } catch (error) {
                console.error('Error deleting food entry:', error);
                return false;
            }
        };
        
        // Update food entry
        window.updateFoodEntry = async (entryId, foodData) => {
            try {
                const entryRef = doc(db, 'nutritionEntries', entryId);
                await updateDoc(entryRef, foodData);
                return true;
            } catch (error) {
                console.error('Error updating food entry:', error);
                return false;
            }
        };
        
        // Save workout entry
        window.saveWorkoutEntry = async (userId, workoutData) => {
            try {
                await addDoc(collection(db, 'workoutEntries'), {
                    userId: userId,
                    ...workoutData,
                    createdAt: serverTimestamp()
                });
                return true;
            } catch (error) {
                console.error('Error saving workout entry:', error);
                return false;
            }
        };
        
        // Get workout entries for a specific date (defaults to today)
        window.getWorkoutEntries = async (userId, date = null) => {
            try {
                const targetDate = date || new Date().toDateString();
                let q = query(collection(db, 'workoutEntries'), where('userId', '==', userId));
                const querySnapshot = await getDocs(q);
                const entries = [];
                querySnapshot.forEach(doc => {
                    const data = doc.data();
                    const entryDate = data.createdAt?.toDate ? data.createdAt.toDate().toDateString() : new Date().toDateString();
                    if (entryDate === targetDate) {
                        entries.push({
                            id: doc.id,
                            ...data
                        });
                    }
                });
                return entries;
            } catch (error) {
                console.error('Error getting workout entries:', error);
                return [];
            }
        };
        
        // Get all workout entries for a user
        window.getAllWorkoutEntries = async (userId) => {
            try {
                let q = query(collection(db, 'workoutEntries'), where('userId', '==', userId));
                const querySnapshot = await getDocs(q);
                const entries = [];
                querySnapshot.forEach(doc => {
                    entries.push({
                        id: doc.id,
                        ...doc.data()
                    });
                });
                return entries;
            } catch (error) {
                console.error('Error getting all workout entries:', error);
                return [];
            }
        };
        
        // Delete workout entry from database
        window.deleteWorkoutEntryFromDB = async (entryId) => {
            try {
                await deleteDoc(doc(db, 'workoutEntries', entryId));
                return true;
            } catch (error) {
                console.error('Error deleting workout entry:', error);
                return false;
            }
        };
        
        // Update workout entry
        window.updateWorkoutEntry = async (entryId, workoutData) => {
            try {
                const entryRef = doc(db, 'workoutEntries', entryId);
                await updateDoc(entryRef, workoutData);
                return true;
            } catch (error) {
                console.error('Error updating workout entry:', error);
                return false;
            }
        };
        
        // Weekly Schedule Functions
        window.saveWeeklySchedule = async (userId, scheduleData) => {
            try {
                const userRef = doc(db, 'users', userId);
                await updateDoc(userRef, {
                    weeklySchedule: scheduleData
                }, { merge: true });
                return true;
            } catch (error) {
                console.error('Error saving weekly schedule:', error);
                return false;
            }
        };
        
        window.getWeeklySchedule = async (userId) => {
            try {
                const userRef = doc(db, 'users', userId);
                const userDoc = await getDoc(userRef);
                if (userDoc.exists()) {
                    return userDoc.data().weeklySchedule || {};
                }
                return {};
            } catch (error) {
                console.error('Error getting weekly schedule:', error);
                return {};
            }
        };
        
        // Custom Gym Workout Functions
        window.saveCustomGymWorkout = async (userId, workoutData) => {
            try {
                await addDoc(collection(db, 'customGymWorkouts'), {
                    userId: userId,
                    ...workoutData,
                    createdAt: serverTimestamp()
                });
                return true;
            } catch (error) {
                console.error('Error saving custom gym workout:', error);
                return false;
            }
        };
        
        window.getCustomGymWorkouts = async (userId) => {
            try {
                let q = query(collection(db, 'customGymWorkouts'), where('userId', '==', userId));
                const querySnapshot = await getDocs(q);
                const workouts = [];
                querySnapshot.forEach(doc => {
                    workouts.push({
                        id: doc.id,
                        ...doc.data()
                    });
                });
                return workouts;
            } catch (error) {
                console.error('Error getting custom gym workouts:', error);
                return [];
            }
        };
        
        window.updateCustomGymWorkout = async (workoutId, workoutData) => {
            try {
                const workoutRef = doc(db, 'customGymWorkouts', workoutId);
                await updateDoc(workoutRef, workoutData);
                return true;
            } catch (error) {
                console.error('Error updating custom gym workout:', error);
                return false;
            }
        };
        
        window.deleteCustomGymWorkout = async (workoutId) => {
            try {
                await deleteDoc(doc(db, 'customGymWorkouts', workoutId));
                return true;
            } catch (error) {
                console.error('Error deleting custom gym workout:', error);
                return false;
            }
        };
        
        // Custom Sports Workout Functions
        window.saveCustomSportsWorkout = async (userId, workoutData) => {
            try {
                await addDoc(collection(db, 'customSportsWorkouts'), {
                    userId: userId,
                    ...workoutData,
                    createdAt: serverTimestamp()
                });
                return true;
            } catch (error) {
                console.error('Error saving custom sports workout:', error);
                return false;
            }
        };
        
        window.getCustomSportsWorkouts = async (userId) => {
            try {
                let q = query(collection(db, 'customSportsWorkouts'), where('userId', '==', userId));
                const querySnapshot = await getDocs(q);
                const workouts = [];
                querySnapshot.forEach(doc => {
                    workouts.push({
                        id: doc.id,
                        ...doc.data()
                    });
                });
                return workouts;
            } catch (error) {
                console.error('Error getting custom sports workouts:', error);
                return [];
            }
        };
        
        window.updateCustomSportsWorkout = async (workoutId, workoutData) => {
            try {
                const workoutRef = doc(db, 'customSportsWorkouts', workoutId);
                await updateDoc(workoutRef, workoutData);
                return true;
            } catch (error) {
                console.error('Error updating custom sports workout:', error);
                return false;
            }
        };
        
        window.deleteCustomSportsWorkout = async (workoutId) => {
            try {
                await deleteDoc(doc(db, 'customSportsWorkouts', workoutId));
                return true;
            } catch (error) {
                console.error('Error deleting custom sports workout:', error);
                return false;
            }
        };
        
        // Custom Diet Plan Functions
        window.saveCustomDietPlan = async (userId, dietPlanData) => {
            try {
                await addDoc(collection(db, 'customDietPlans'), {
                    userId: userId,
                    ...dietPlanData,
                    createdAt: serverTimestamp()
                });
                return true;
            } catch (error) {
                console.error('Error saving custom diet plan:', error);
                return false;
            }
        };
        
        window.getCustomDietPlans = async (userId) => {
            try {
                let q = query(collection(db, 'customDietPlans'), where('userId', '==', userId));
                const querySnapshot = await getDocs(q);
                const dietPlans = [];
                querySnapshot.forEach(doc => {
                    dietPlans.push({
                        id: doc.id,
                        ...doc.data()
                    });
                });
                return dietPlans;
            } catch (error) {
                console.error('Error getting custom diet plans:', error);
                return [];
            }
        };
        
        window.updateCustomDietPlan = async (dietPlanId, dietPlanData) => {
            try {
                const dietPlanRef = doc(db, 'customDietPlans', dietPlanId);
                await updateDoc(dietPlanRef, dietPlanData);
                return true;
            } catch (error) {
                console.error('Error updating custom diet plan:', error);
                return false;
            }
        };
        
        window.deleteCustomDietPlan = async (dietPlanId) => {
            try {
                await deleteDoc(doc(db, 'customDietPlans', dietPlanId));
                return true;
            } catch (error) {
                console.error('Error deleting custom diet plan:', error);
                return false;
            }
        };
        
        // Check and award all badges based on user's training data
        window.checkAllBadges = async (userId) => {
            try {
                const scores = await window.getTrainingScores(userId);
                if (scores.length === 0) return;
                
                const badges = await window.getUserBadges(userId);
                const today = new Date().toDateString();
                
                // Get user document to check session dates
                const userRef = doc(db, 'users', userId);
                const userDoc = await getDoc(userRef);
                const userData = userDoc.exists() ? userDoc.data() : {};
                
                // Calculate statistics
                const totalSessions = scores.length;
                const scoreValues = scores.map(s => s.similarityScore);
                const maxScore = Math.max(...scoreValues);
                const avgScore = scoreValues.reduce((a, b) => a + b, 0) / scoreValues.length;
                
                // Group scores by player
                const playerScores = {};
                scores.forEach(score => {
                    const player = score.player || 'custom';
                    if (!playerScores[player]) playerScores[player] = [];
                    playerScores[player].push(score);
                });
                
                // Get unique players tried
                const uniquePlayers = Object.keys(playerScores);
                const playersWithHighScores = uniquePlayers.filter(player => {
                    const playerMax = Math.max(...playerScores[player].map(s => s.similarityScore));
                    return playerMax >= 85;
                });
                
                // Calculate improvements
                const recentScores = scoreValues.slice(0, 5);
                const olderScores = scoreValues.slice(5, 10);
                const recentAvg = recentScores.length > 0 ? recentScores.reduce((a, b) => a + b, 0) / recentScores.length : 0;
                const olderAvg = olderScores.length > 0 ? olderScores.reduce((a, b) => a + b, 0) / olderScores.length : 0;
                const improvement = recentAvg > 0 && olderAvg > 0 ? recentAvg - olderAvg : 0;
                
                // Check consecutive days with sessions
                const sessionDates = scores.map(s => {
                    const date = s.createdAt?.toDate ? s.createdAt.toDate() : new Date();
                    return date.toDateString();
                });
                const uniqueDates = [...new Set(sessionDates)];
                uniqueDates.sort((a, b) => new Date(a) - new Date(b));
                
                let consecutiveDays = 1;
                let maxConsecutive = 1;
                for (let i = 1; i < uniqueDates.length; i++) {
                    const prevDate = new Date(uniqueDates[i - 1]);
                    const currDate = new Date(uniqueDates[i]);
                    const daysDiff = (currDate - prevDate) / (1000 * 60 * 60 * 24);
                    if (daysDiff === 1) {
                        consecutiveDays++;
                        maxConsecutive = Math.max(maxConsecutive, consecutiveDays);
                    } else {
                        consecutiveDays = 1;
                    }
                }
                
                // Check last 5 consecutive scores
                const last5Scores = scoreValues.slice(0, 5);
                const allLast5High = last5Scores.length === 5 && last5Scores.every(s => s >= 85);
                const last5Consecutive = last5Scores.length === 5 && last5Scores.every(s => s >= 80);
                
                // Practice Warrior badges (total sessions)
                if (totalSessions >= 10 && totalSessions < 50 && (!badges.practiceWarrior || badges.practiceWarrior === 'none')) {
                    await window.awardBadge(userId, 'practiceWarrior', 'bronze');
                } else if (totalSessions >= 50 && totalSessions < 100 && (!badges.practiceWarrior || badges.practiceWarrior === 'bronze')) {
                    await window.awardBadge(userId, 'practiceWarrior', 'silver');
                } else if (totalSessions >= 100 && badges.practiceWarrior !== 'gold') {
                    await window.awardBadge(userId, 'practiceWarrior', 'gold');
                }
                
                // Milestone badges
                if (totalSessions >= 50 && totalSessions < 100 && !badges.halfCentury) {
                    await window.awardBadge(userId, 'halfCentury', 'bronze');
                } else if (totalSessions >= 100 && totalSessions < 300 && badges.halfCentury !== 'silver') {
                    await window.awardBadge(userId, 'halfCentury', 'silver');
                } else if (totalSessions >= 300 && badges.halfCentury !== 'gold') {
                    await window.awardBadge(userId, 'halfCentury', 'gold');
                }
                
                // First Steps
                if (totalSessions >= 1 && totalSessions < 5 && !badges.firstSteps) {
                    await window.awardBadge(userId, 'firstSteps', 'bronze');
                } else if (totalSessions >= 5 && totalSessions < 10 && (!badges.firstSteps || badges.firstSteps === 'bronze')) {
                    await window.awardBadge(userId, 'firstSteps', 'silver');
                } else if (totalSessions >= 10 && badges.firstSteps !== 'gold') {
                    await window.awardBadge(userId, 'firstSteps', 'gold');
                }
                
                // Improvement badges
                if (improvement >= 10 && improvement < 20 && (!badges.risingStar || badges.risingStar === 'none')) {
                    await window.awardBadge(userId, 'risingStar', 'bronze');
                } else if (improvement >= 20 && improvement < 30 && (!badges.risingStar || badges.risingStar === 'bronze')) {
                    await window.awardBadge(userId, 'risingStar', 'silver');
                } else if (improvement >= 30 && badges.risingStar !== 'gold') {
                    await window.awardBadge(userId, 'risingStar', 'gold');
                }
                
                if (improvement >= 15 && improvement < 20 && last5Scores.length >= 3 && (!badges.fastTrack || badges.fastTrack === 'none')) {
                    await window.awardBadge(userId, 'fastTrack', 'bronze');
                } else if (improvement >= 20 && improvement < 25 && last5Scores.length >= 5 && (!badges.fastTrack || badges.fastTrack === 'bronze')) {
                    await window.awardBadge(userId, 'fastTrack', 'silver');
                } else if (improvement >= 25 && last5Scores.length >= 7 && badges.fastTrack !== 'gold') {
                    await window.awardBadge(userId, 'fastTrack', 'gold');
                }
                
                // Check for breakthrough (new personal best)
                // Count how many times user achieved a new PB
                let pbCount = 0;
                if (scoreValues.length >= 2) {
                    let currentMax = scoreValues[scoreValues.length - 1];
                    for (let i = scoreValues.length - 2; i >= 0; i--) {
                        if (scoreValues[i] > currentMax) {
                            pbCount++;
                            currentMax = scoreValues[i];
                        }
                    }
                }
                
                if (pbCount >= 1 && pbCount < 3 && (!badges.breakthrough || badges.breakthrough === 'none')) {
                    await window.awardBadge(userId, 'breakthrough', 'bronze');
                } else if (pbCount >= 3 && pbCount < 5 && (!badges.breakthrough || badges.breakthrough === 'bronze')) {
                    await window.awardBadge(userId, 'breakthrough', 'silver');
                } else if (pbCount >= 5 && badges.breakthrough !== 'gold') {
                    await window.awardBadge(userId, 'breakthrough', 'gold');
                }
                
                // Player mastery badges
                for (const player of ['curry', 'lebron', 'jordan', 'durant', 'clark']) {
                    if (playerScores[player]) {
                        const playerSessions = playerScores[player].length;
                        const playerMax = Math.max(...playerScores[player].map(s => s.similarityScore));
                        const badgeName = player + 'Specialist';
                        
                        if (playerSessions >= 5 && playerMax >= 85 && playerMax < 90 && (!badges[badgeName] || badges[badgeName] === 'none')) {
                            await window.awardBadge(userId, badgeName, 'bronze');
                        } else if (playerSessions >= 10 && playerMax >= 90 && playerMax < 95 && (!badges[badgeName] || badges[badgeName] === 'bronze')) {
                            await window.awardBadge(userId, badgeName, 'silver');
                        } else if (playerSessions >= 15 && playerMax >= 95 && badges[badgeName] !== 'gold') {
                            await window.awardBadge(userId, badgeName, 'gold');
                        }
                    }
                }
                
                // Versatile Shooter
                if (playersWithHighScores.length >= 3 && playersWithHighScores.length < 4 && (!badges.versatileShooter || badges.versatileShooter === 'none')) {
                    await window.awardBadge(userId, 'versatileShooter', 'bronze');
                } else if (playersWithHighScores.length >= 4 && playersWithHighScores.length < 5 && (!badges.versatileShooter || badges.versatileShooter === 'bronze')) {
                    await window.awardBadge(userId, 'versatileShooter', 'silver');
                } else if (playersWithHighScores.length >= 5 && badges.versatileShooter !== 'gold') {
                    await window.awardBadge(userId, 'versatileShooter', 'gold');
                }
                
                // Consistency badges
                if (avgScore >= 80 && avgScore < 90 && totalSessions >= 10 && (!badges.steadyHand || badges.steadyHand === 'none')) {
                    await window.awardBadge(userId, 'steadyHand', 'bronze');
                } else if (avgScore >= 90 && avgScore < 95 && totalSessions >= 20 && (!badges.steadyHand || badges.steadyHand === 'bronze')) {
                    await window.awardBadge(userId, 'steadyHand', 'silver');
                } else if (avgScore >= 95 && totalSessions >= 30 && badges.steadyHand !== 'gold') {
                    await window.awardBadge(userId, 'steadyHand', 'gold');
                }
                
                const last10High = scoreValues.length >= 10 && scoreValues.slice(0, 10).every(s => s >= 85);
                const last15High = scoreValues.length >= 15 && scoreValues.slice(0, 15).every(s => s >= 85);
                
                if (allLast5High && !last10High && (!badges.rockSolid || badges.rockSolid === 'none')) {
                    await window.awardBadge(userId, 'rockSolid', 'bronze');
                } else if (last10High && !last15High && (!badges.rockSolid || badges.rockSolid === 'bronze')) {
                    await window.awardBadge(userId, 'rockSolid', 'silver');
                } else if (last15High && badges.rockSolid !== 'gold') {
                    await window.awardBadge(userId, 'rockSolid', 'gold');
                }
                
                // Perfect form badges
                if (maxScore >= 95 && maxScore < 98 && (!badges.nearPerfect || badges.nearPerfect === 'none')) {
                    await window.awardBadge(userId, 'nearPerfect', 'bronze');
                } else if (maxScore >= 98 && maxScore < 100 && (!badges.nearPerfect || badges.nearPerfect === 'bronze')) {
                    await window.awardBadge(userId, 'nearPerfect', 'silver');
                } else if (maxScore >= 100 && badges.nearPerfect !== 'gold') {
                    await window.awardBadge(userId, 'nearPerfect', 'gold');
                }
                
                const perfectScores = scoreValues.filter(s => s >= 100).length;
                
                if (maxScore >= 98 && maxScore < 100 && (!badges.perfectionist || badges.perfectionist === 'none')) {
                    await window.awardBadge(userId, 'perfectionist', 'bronze');
                } else if (maxScore >= 100 && perfectScores < 3 && badges.perfectionist !== 'silver') {
                    await window.awardBadge(userId, 'perfectionist', 'silver');
                } else if (perfectScores >= 3 && badges.perfectionist !== 'gold') {
                    await window.awardBadge(userId, 'perfectionist', 'gold');
                }
                
                // Dedication badges (consecutive days with sessions)
                if (maxConsecutive >= 7 && maxConsecutive < 30 && (!badges.weekWarrior || badges.weekWarrior === 'none')) {
                    await window.awardBadge(userId, 'weekWarrior', 'bronze');
                } else if (maxConsecutive >= 30 && maxConsecutive < 365 && (!badges.weekWarrior || badges.weekWarrior === 'bronze')) {
                    await window.awardBadge(userId, 'weekWarrior', 'silver');
                } else if (maxConsecutive >= 365 && badges.weekWarrior !== 'gold') {
                    await window.awardBadge(userId, 'weekWarrior', 'gold');
                }
                
                // Daily Grinder
                if (maxConsecutive >= 3 && maxConsecutive < 7 && (!badges.dailyGrinder || badges.dailyGrinder === 'none')) {
                    await window.awardBadge(userId, 'dailyGrinder', 'bronze');
                } else if (maxConsecutive >= 7 && maxConsecutive < 14 && (!badges.dailyGrinder || badges.dailyGrinder === 'bronze')) {
                    await window.awardBadge(userId, 'dailyGrinder', 'silver');
                } else if (maxConsecutive >= 14 && badges.dailyGrinder !== 'gold') {
                    await window.awardBadge(userId, 'dailyGrinder', 'gold');
                }
                
                // Exploration badges
                const hasCustom = playerScores['custom'] && playerScores['custom'].length > 0;
                const allPlayersMastered = playersWithHighScores.length >= 5;
                
                if (uniquePlayers.length >= 5 && !hasCustom && (!badges.explorer || badges.explorer === 'none')) {
                    await window.awardBadge(userId, 'explorer', 'bronze');
                } else if (uniquePlayers.length >= 5 && hasCustom && (!badges.explorer || badges.explorer === 'bronze')) {
                    await window.awardBadge(userId, 'explorer', 'silver');
                } else if (allPlayersMastered && badges.explorer !== 'gold') {
                    await window.awardBadge(userId, 'explorer', 'gold');
                }
                
                if (playerScores['custom'] && playerScores['custom'].length >= 1 && playerScores['custom'].length < 5 && (!badges.adventurer || badges.adventurer === 'none')) {
                    await window.awardBadge(userId, 'adventurer', 'bronze');
                } else if (playerScores['custom'] && playerScores['custom'].length >= 5 && playerScores['custom'].length < 10 && (!badges.adventurer || badges.adventurer === 'bronze')) {
                    await window.awardBadge(userId, 'adventurer', 'silver');
                } else if (playerScores['custom'] && playerScores['custom'].length >= 10 && badges.adventurer !== 'gold') {
                    await window.awardBadge(userId, 'adventurer', 'gold');
                }
                
                // Complete Collection - check for different score thresholds
                const playersAt90 = uniquePlayers.filter(p => {
                    const playerMax = Math.max(...playerScores[p].map(s => s.similarityScore));
                    return playerMax >= 90;
                }).length;
                const playersAt95 = uniquePlayers.filter(p => {
                    const playerMax = Math.max(...playerScores[p].map(s => s.similarityScore));
                    return playerMax >= 95;
                }).length;
                
                if (playersWithHighScores.length >= 5 && playersAt90 < 5 && (!badges.completeCollection || badges.completeCollection === 'none')) {
                    await window.awardBadge(userId, 'completeCollection', 'bronze');
                } else if (playersAt90 >= 5 && playersAt95 < 5 && (!badges.completeCollection || badges.completeCollection === 'bronze')) {
                    await window.awardBadge(userId, 'completeCollection', 'silver');
                } else if (playersAt95 >= 5 && badges.completeCollection !== 'gold') {
                    await window.awardBadge(userId, 'completeCollection', 'gold');
                }
                
                // Quick Learner
                if (totalSessions <= 5 && maxScore >= 80 && maxScore < 85 && (!badges.quickLearner || badges.quickLearner === 'none')) {
                    await window.awardBadge(userId, 'quickLearner', 'bronze');
                } else if (totalSessions <= 5 && maxScore >= 85 && maxScore < 90 && (!badges.quickLearner || badges.quickLearner === 'bronze')) {
                    await window.awardBadge(userId, 'quickLearner', 'silver');
                } else if (totalSessions <= 5 && maxScore >= 90 && badges.quickLearner !== 'gold') {
                    await window.awardBadge(userId, 'quickLearner', 'gold');
                }
                
                // Rapid Rise
                if (scoreValues.length >= 10) {
                    const first5Avg = scoreValues.slice(-10, -5).reduce((a, b) => a + b, 0) / 5;
                    const last5Avg = scoreValues.slice(0, 5).reduce((a, b) => a + b, 0) / 5;
                    if (first5Avg < 60 && last5Avg >= 85 && last5Avg < 90 && (!badges.rapidRise || badges.rapidRise === 'none')) {
                        await window.awardBadge(userId, 'rapidRise', 'bronze');
                    } else if (first5Avg < 60 && last5Avg >= 90 && last5Avg < 95 && (!badges.rapidRise || badges.rapidRise === 'bronze')) {
                        await window.awardBadge(userId, 'rapidRise', 'silver');
                    } else if (first5Avg < 60 && last5Avg >= 95 && badges.rapidRise !== 'gold') {
                        await window.awardBadge(userId, 'rapidRise', 'gold');
                    }
                }
                
            } catch (error) {
                console.error('Error checking badges:', error);
            }
        };
    </script>
</head>
<body>
    <!-- Navbar -->
    <nav class="navbar">
        <div class="nav-container">
            <div class="nav-content">
                <div class="logo">
                    <a href="../index.html" style="display: flex; align-items: center; text-decoration: none;">
                        <img src="/RootsLogo.png" alt="Roots Logo" style="height: 50px; width: auto; cursor: pointer; object-fit: contain;">
                    </a>
                </div>
                <div class="nav-tabs" style="display: flex; gap: 20px; align-items: center; justify-content: center; flex: 1;">
                    <button id="shotSyncTab" class="nav-tab active" onclick="showShotSync()">Shot Sync</button>
                    <button id="benchmarkUploadTab" class="nav-tab" onclick="showBenchmarkUpload()" style="display: inline-block;">Benchmark Upload</button>
                    <a href="/shotlab" class="nav-tab" style="text-decoration: none;">Shot Lab</a>
                    <button id="trainingDbTab" class="nav-tab" onclick="showTrainingDatabase()" style="display: none;">Training Database</button>
                    <button id="progressPicsTab" class="nav-tab" onclick="showProgressPics()" style="display: none;">Progress Pics</button>
                    <button id="badgesTab" class="nav-tab" onclick="showBadges()" style="display: none;">Badges</button>
                    <button id="nutritionTab" class="nav-tab" onclick="showNutrition()" style="display: none;">Nutrition</button>
                    <button id="workoutsTab" class="nav-tab" onclick="showWorkouts()" style="display: none;">Workouts</button>
                </div>
                <div style="display: flex; align-items: center; gap: 12px;">
                    <button id="backToHomeTab" class="nav-tab">Home</button>
                    <button id="playerDetailsNavBtn" class="nav-tab">Player Details</button>
                </div>
            </div>
        </div>
    </nav>

    <div class="container">
        <!-- Profile Dropdown (positioned in nav area) -->
        <div id="profileDropdown" style="position: fixed; top: 20px; right: 20px; display: none; z-index: 100;">
            <button id="profileButton" class="btn" style="background: rgba(255,255,255,0.2); border: 1px solid rgba(255,255,255,0.3); padding: 8px 12px; border-radius: 20px; color: white; cursor: pointer; display: flex; align-items: center; gap: 8px; transition: all 0.2s;">
                <span id="profileInitials" style="width: 32px; height: 32px; border-radius: 50%; background: rgba(255,255,255,0.3); display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 14px;">U</span>
                <span id="profileName" style="max-width: 150px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; font-size: 14px;"></span>
                <span style="font-size: 10px;"></span>
            </button>
            <div id="profileMenu" style="position: absolute; top: 100%; right: 0; margin-top: 8px; background: white; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); min-width: 200px; display: none; z-index: 1001;">
                <div style="padding: 16px; border-bottom: 1px solid #e0e0e0;">
                    <div id="menuUserName" style="font-weight: bold; color: #333; margin-bottom: 4px;"></div>
                    <div id="menuUserEmail" style="font-size: 12px; color: #666;"></div>
                </div>
                <button id="playerDetailsBtn" style="width: 100%; padding: 12px 16px; text-align: left; background: none; border: none; cursor: pointer; color: #333; font-size: 14px; transition: background 0.2s; border-bottom: 1px solid #e0e0e0;">
                    Player Details
                </button>
                <button id="logoutButton" style="width: 100%; padding: 12px 16px; text-align: left; background: none; border: none; cursor: pointer; color: #333; font-size: 14px; border-radius: 0 0 8px 8px; transition: background 0.2s;">
                    Sign Out
                </button>
            </div>
        </div>

        <!-- Player Details Panel -->
        <div id="playerDetailsPanel" style="display: none; position: fixed; top: 70px; right: 0; width: 340px; height: calc(100% - 70px); background: #1A1A1F; z-index: 200; box-shadow: -4px 0 20px rgba(0,0,0,0.4); overflow-y: auto; border-radius: 0 0 0 12px;">
            <div style="padding: 20px 24px; border-bottom: 1px solid #2A2A30; display: flex; justify-content: space-between; align-items: center; position: sticky; top: 0; background: #1A1A1F; z-index: 1;">
                <div>
                    <h3 style="margin: 0; color: #fff; font-size: 20px; font-weight: 700; letter-spacing: 1px;">PLAYER DETAILS</h3>
                    <p style="margin: 4px 0 0; color: #5A5A64; font-size: 12px;">Your info for analysis reports</p>
                </div>
                <button id="closePlayerDetails" style="background: none; border: none; color: #5A5A64; font-size: 26px; cursor: pointer; padding: 4px 8px; line-height: 1;">&times;</button>
            </div>
            <div style="padding: 28px 24px;">
                <div style="display: flex; flex-direction: column; gap: 24px;">
                    <div>
                        <label style="display: block; color: #8B8B96; font-size: 11px; text-transform: uppercase; letter-spacing: 1.5px; margin-bottom: 8px; font-weight: 600;">Name</label>
                        <input id="pdName" type="text" placeholder="Enter your name" style="width: 100%; padding: 12px 14px; background: #2A2A30; border: 1px solid #3A3A42; border-radius: 8px; color: #fff; font-size: 15px; outline: none; box-sizing: border-box; transition: border-color 0.2s;" onfocus="this.style.borderColor='var(--primary-color)'" onblur="this.style.borderColor='#3A3A42'">
                    </div>
                    <div>
                        <label style="display: block; color: #8B8B96; font-size: 11px; text-transform: uppercase; letter-spacing: 1.5px; margin-bottom: 8px; font-weight: 600;">Height</label>
                        <div style="display: flex; gap: 10px;">
                            <select id="pdFeet" style="flex: 1; padding: 12px 14px; background: #2A2A30; border: 1px solid #3A3A42; border-radius: 8px; color: #fff; font-size: 15px; outline: none; appearance: auto;">
                                <option value="">ft</option>
                                <option value="4">4'</option>
                                <option value="5">5'</option>
                                <option value="6">6'</option>
                                <option value="7">7'</option>
                            </select>
                            <select id="pdInches" style="flex: 1; padding: 12px 14px; background: #2A2A30; border: 1px solid #3A3A42; border-radius: 8px; color: #fff; font-size: 15px; outline: none; appearance: auto;">
                                <option value="">in</option>
                                <option value="0">0"</option>
                                <option value="1">1"</option>
                                <option value="2">2"</option>
                                <option value="3">3"</option>
                                <option value="4">4"</option>
                                <option value="5">5"</option>
                                <option value="6">6"</option>
                                <option value="7">7"</option>
                                <option value="8">8"</option>
                                <option value="9">9"</option>
                                <option value="10">10"</option>
                                <option value="11">11"</option>
                            </select>
                        </div>
                    </div>
                    <div>
                        <label style="display: block; color: #8B8B96; font-size: 11px; text-transform: uppercase; letter-spacing: 1.5px; margin-bottom: 8px; font-weight: 600;">Shooting Hand</label>
                        <div style="display: flex; gap: 10px;">
                            <button class="pd-hand-btn" data-hand="Right" style="flex: 1; padding: 12px; background: #2A2A30; border: 2px solid #3A3A42; border-radius: 8px; color: #8B8B96; font-size: 14px; font-weight: 500; cursor: pointer; transition: all 0.2s;">Right</button>
                            <button class="pd-hand-btn" data-hand="Left" style="flex: 1; padding: 12px; background: #2A2A30; border: 2px solid #3A3A42; border-radius: 8px; color: #8B8B96; font-size: 14px; font-weight: 500; cursor: pointer; transition: all 0.2s;">Left</button>
                        </div>
                    </div>
                    <button id="pdSave" style="margin-top: 12px; padding: 14px; background: linear-gradient(135deg, var(--primary-color) 0%, #ff8a9b 100%); border: none; border-radius: 8px; color: #fff; font-size: 15px; font-weight: 600; cursor: pointer; transition: opacity 0.2s; letter-spacing: 0.5px;">Save</button>
                    <p id="pdSavedMsg" style="display: none; color: #3DD68C; font-size: 13px; text-align: center; margin: 0;">Saved!</p>
                </div>
            </div>
        </div>
        <div id="playerDetailsBg" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 199;"></div>

        <div class="main-content">
            <!-- Step 0: User Information -->
            <section id="step0" class="step active">
                <h2>Welcome to <span style="background: linear-gradient(135deg, var(--primary-color) 0%, var(--primary-hover) 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; font-weight: 700;">Shot</span><span>Sync</span></h2>
                <p style="font-size: 18px; color: #666; margin-bottom: 30px; text-align: center;">
                    AI-powered basketball shot analysis to help you improve your shooting form
                </p>

                <!-- Google Sign-In Button (only show if not signed in) -->
                <div id="signInSection" style="text-align: center;">
                    <p style="font-size: 16px; color: #333; margin-bottom: 20px; font-weight: 500;">
                        Sign in with Google to get started
                    </p>
                    <button id="googleSignInBtn" onclick="handleGoogleSignInClick()" class="btn" style="background: white; color: #333; border: 1px solid #ddd; display: inline-flex; align-items: center; gap: 10px; padding: 14px 28px; font-size: 16px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                        <svg width="20" height="20" viewBox="0 0 18 18">
                            <path fill="#4285F4" d="M17.64 9.2c0-.637-.057-1.251-.164-1.84H9v3.481h4.844c-.209 1.125-.843 2.078-1.796 2.717v2.258h2.908c1.702-1.567 2.684-3.874 2.684-6.615z"/>
                            <path fill="#34A853" d="M9 18c2.43 0 4.467-.806 5.956-2.184l-2.908-2.258c-.806.54-1.837.86-3.048.86-2.344 0-4.328-1.584-5.036-3.711H.957v2.332C2.438 15.983 5.482 18 9 18z"/>
                            <path fill="#FBBC05" d="M3.964 10.712c-.18-.54-.282-1.117-.282-1.712 0-.595.102-1.172.282-1.712V4.956H.957C.348 6.175 0 7.55 0 9s.348 2.825.957 4.044l3.007-2.332z"/>
                            <path fill="#EA4335" d="M9 3.58c1.321 0 2.508.454 3.44 1.345l2.582-2.58C13.463.891 11.426 0 9 0 5.482 0 2.438 2.017.957 4.956L3.964 7.288C4.672 5.163 6.656 3.58 9 3.58z"/>
                        </svg>
                        Sign in with Google
                    </button>
                </div>
            </section>

            <!-- Step 1: Record Benchmark -->
            <section id="step1" class="step" style="display: none;">
                <h2 id="step1Title">Step 1: Record Benchmark Shot</h2>
                <p>Record a reference shot to use as your benchmark for comparison.</p>
                <div class="video-container" style="position: relative;">
                    <video id="benchmarkVideo" autoplay playsinline muted style="width: 100%; max-width: 640px; height: auto; display: block; border-radius: 12px; z-index: 1;"></video>
                    <canvas id="benchmarkCanvas" style="display: none;"></canvas>
                    <canvas id="benchmarkOutput" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; max-width: 640px; z-index: 2; pointer-events: none;"></canvas>
                    <div id="benchmarkBodyWarning" class="body-warning-overlay" style="display: none;">
                        <div class="warning-content">
                            <div class="warning-icon"></div>
                            <h3>Full Body Required</h3>
                            <p>Please step back so your entire body is visible in the frame</p>
                        </div>
                    </div>
                </div>
                <div class="controls" style="display: flex; flex-direction: column; gap: 15px; align-items: center;">
                    <!-- All buttons in one horizontal line -->
                    <div style="display: flex; gap: 10px; justify-content: center; flex-wrap: wrap; align-items: center;">
                        <!-- Upload Video Toggle -->
                        <button id="benchmarkUploadModeBtn" class="btn btn-secondary mode-toggle-btn" style="min-width: 140px;"> Upload Video</button>
                        
                        <!-- Recording Controls -->
                        <button id="startBenchmark" class="btn btn-primary" style="min-width: 140px;">Start Recording</button>
                        <button id="stopBenchmark" class="btn btn-secondary" disabled style="min-width: 140px;">Stop Recording</button>
                        <button id="retakeBenchmark" class="btn btn-warning" style="display: none; min-width: 140px;">Retake</button>
                        
                        <!-- Upload Controls (hidden by default) -->
                        <input type="file" id="benchmarkVideoUpload" accept="video/mp4,video/mov,video/webm,video/quicktime" style="position: absolute; width: 1px; height: 1px; opacity: 0; overflow: hidden; z-index: -1;">
                        <label for="benchmarkVideoUpload" id="selectBenchmarkVideo" class="btn btn-primary" style="display: none; min-width: 140px; cursor: pointer;">Choose Video File</label>
                        <button id="processBenchmarkVideo" class="btn btn-success" style="display: none; min-width: 140px;">Analyze Video</button>
                    </div>
                    
                    <!-- File name display for upload -->
                    <div id="benchmarkUploadedFileName" style="width: 100%; text-align: center; color: #666; font-size: 14px;"></div>
                </div>
                <div id="benchmarkStatus" class="status" style="display: none;"></div>
            </section>

            <!-- Step 2: Record User Shot -->
            <section id="step2" class="step" style="display: none; padding-top: 20px;">
                <h2 id="step2Title" style="font-family: 'Bebas Neue', sans-serif; text-align: center; letter-spacing: 2px; margin-top: 0;">Record Your Shot</h2>
                <p style="text-align: center;">And our AI will do the rest, select what type of analysis next!</p>
                <div class="video-container" style="position: relative;">
                    <video id="userVideo" playsinline muted style="width: 100%; max-width: 640px; height: auto; display: block; border-radius: 12px; z-index: 1;"></video>
                    <canvas id="userCanvas" style="display: none;"></canvas>
                    <canvas id="userOutput" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; max-width: 640px; z-index: 2; pointer-events: none;"></canvas>
                    <div id="userBodyWarning" class="body-warning-overlay" style="display: none;">
                        <div class="warning-content">
                            <div class="warning-icon"></div>
                            <h3>Full Body Required</h3>
                            <p>Please step back so your entire body is visible in the frame</p>
                        </div>
                    </div>
                    <!-- 3D Skeleton Viewer Overlay (shows shot animation loop) -->
                    <div id="videoReadyOverlay" class="video-ready-overlay" style="display: none;">
                        <div class="skeleton-viewer-container">
                            <canvas id="skeletonCanvas3d"></canvas>
                            <div class="skeleton-controls">
                                <button id="playPauseLoop" class="skeleton-btn"></button>
                                <input type="range" id="frameSlider" min="0" max="100" value="0" class="frame-slider">
                                <span id="frameCounter">0 / 0</span>
                                <div class="camera-controls">
                                    <label title="Horizontal"></label>
                                    <input type="range" id="cameraX" min="-5" max="5" value="0" step="0.1" class="camera-slider">
                                    <label title="Vertical"></label>
                                    <input type="range" id="cameraY" min="-5" max="5" value="0" step="0.1" class="camera-slider">
                                    <label title="Zoom"></label>
                                    <input type="range" id="cameraZoom" min="2" max="10" value="5" step="0.1" class="camera-slider">
                                </div>
                            </div>
                            <!-- Processing overlay -->
                            <div id="skeletonProcessing" class="skeleton-processing" style="display: none;">
                                <div class="spinner"></div>
                                <p id="processingStatus">Extracting skeleton...</p>
                                <p id="processingSaying" style="color: #8B8B96; font-size: 13px; margin-top: 8px; font-style: italic; min-height: 20px;"></p>
                            </div>
                            <!-- Video Ready state (replaces skeleton viewer) -->
                            <div id="videoReadyState" style="display: none; position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.88); flex-direction: column; align-items: center; justify-content: center; z-index: 16; border-radius: 12px;">
                                <div style="font-size: 48px; margin-bottom: 12px; color: #3DD68C;">&#10003;</div>
                                <p style="color: #3DD68C; font-size: 18px; font-weight: 600; margin: 0;">Video Ready</p>
                                <p style="color: #8B8B96; font-size: 13px; margin-top: 6px;">Choose an analysis type below</p>
                            </div>
                        </div>
                        <!-- Skeleton Viewer Container (shown when video is ready) -->
                        <div class="skeleton-viewer-container" style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; z-index: 5;">
                            <canvas id="skeletonCanvas3d"></canvas>
                            <div class="skeleton-controls">
                                <button id="playPauseLoop" class="skeleton-btn"></button>
                                <button id="pauseLoopBtn" class="skeleton-btn" style="display: none;"></button>
                                <input type="range" id="frameSlider" min="0" max="100" value="0" class="frame-slider">
                                <span id="frameCounter">0 / 0</span>
                                <div class="camera-controls">
                                    <label title="Horizontal"></label>
                                    <input type="range" id="cameraX" min="-5" max="5" value="0" step="0.1" class="camera-slider">
                                    <label title="Vertical"></label>
                                    <input type="range" id="cameraY" min="-5" max="5" value="0" step="0.1" class="camera-slider">
                                    <label title="Zoom"></label>
                                    <input type="range" id="cameraZoom" min="2" max="10" value="5" step="0.1" class="camera-slider">
                                </div>
                            </div>
                            <!-- Processing overlay -->
                            <div id="skeletonProcessing" class="skeleton-processing" style="display: none;">
                                <div class="spinner"></div>
                                <p id="processingStatus">Extracting skeleton...</p>
                            </div>
                        </div>
                    </div>
                    <!-- Running Analysis Overlay (green - actually processing) -->
                    <div id="analysisRunningOverlay" class="analysis-overlay" style="display: none;">
                        <div class="analysis-content">
                            <div class="analysis-spinner"></div>
                            <h3>Running Analysis</h3>
                            <p>Processing your video...</p>
                        </div>
                    </div>
                </div>
                <div class="controls" style="display: flex; flex-direction: column; gap: 15px; align-items: center; width: 100%;">
                    <!-- Shot Detection Status (shown for upload mode after processing) -->
                    <div id="shotDetectionStatus" style="display: none; text-align: center; margin-bottom: 10px;">
                        <div id="shotDetectionMessage" style="padding: 12px 20px; border-radius: 8px; font-size: 14px; font-weight: 600;"></div>
                    </div>
                    <!-- All buttons in one horizontal line -->
                    <div id="recordingControls" style="display: flex; gap: 12px; justify-content: center; flex-wrap: wrap; align-items: center;">
                        <!-- Upload Video - directly triggers file picker -->
                        <label for="userVideoUpload" class="btn btn-secondary" style="min-width: 180px; height: 48px; border-radius: 8px; font-size: 14px; font-weight: 600; display: inline-flex; align-items: center; justify-content: center; cursor: pointer;">UPLOAD VIDEO</label>
                        <input type="file" id="userVideoUpload" accept="video/mp4,video/mov,video/webm,video/quicktime" style="display: none;">

                        <!-- Recording Controls -->
                        <button id="startUser" class="btn btn-primary" style="min-width: 180px; height: 48px; border-radius: 8px; font-size: 14px; font-weight: 600; clip-path: none;">START RECORDING</button>
                        <button id="stopUser" class="btn btn-secondary" disabled style="min-width: 180px; height: 48px; border-radius: 8px; font-size: 14px; font-weight: 600;">STOP RECORDING</button>
                        <button id="retakeUser" class="btn btn-warning" style="display: none; min-width: 180px; height: 48px; border-radius: 8px; font-size: 14px; font-weight: 600;">RETAKE</button>

                        <!-- Hidden buttons (kept for JS compatibility) -->
                        <button id="userUploadModeBtn" style="display: none;"></button>
                        <button id="selectUserVideo" style="display: none;"></button>
                        <button id="processUserVideo" style="display: none;"></button>
                    </div>
                    
                    <!-- File name display for upload -->
                    <div id="uploadedFileName" style="width: 100%; text-align: center; color: #666; font-size: 14px;"></div>
                </div>

                <!-- Shot Count Modal (shown when START RECORDING is clicked) -->
                <div id="shotCountModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0, 0, 0, 0.85); z-index: 1000; align-items: center; justify-content: center;">
                    <div style="background: var(--bg-card); border: 1px solid var(--border-color); border-radius: 12px; padding: 30px 40px; text-align: center; max-width: 350px; box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);">
                        <h3 style="font-family: 'Bebas Neue', sans-serif; font-size: 24px; letter-spacing: 2px; color: var(--text-dark); margin-bottom: 20px;">HOW MANY SHOTS?</h3>
                        <div style="margin-bottom: 25px;">
                            <input type="number" id="shotCountInput" min="1" max="10" value="5" style="width: 100px; padding: 12px 15px; border: 2px solid var(--border-color); border-radius: 8px; background: var(--bg-elevated); color: var(--text-dark); font-size: 24px; font-weight: 600; text-align: center;">
                            <p style="color: var(--text-gray); font-size: 13px; margin-top: 8px;">Enter 1-10 shots</p>
                        </div>
                        <div style="display: flex; gap: 12px; justify-content: center;">
                            <button id="cancelRecordingBtn" class="btn btn-secondary" style="padding: 12px 24px; border-radius: 8px; font-size: 14px; font-weight: 600;">CANCEL</button>
                            <button id="confirmRecordingBtn" class="btn btn-primary" style="padding: 12px 24px; border-radius: 8px; font-size: 14px; font-weight: 600;">START</button>
                        </div>
                    </div>
                </div>

                <!-- Analysis Type Selection (shown after video is ready) -->
                <div id="analysisTypeSelection" style="display: none; margin-top: 30px; padding-top: 20px; border-top: 1px solid var(--border-color);">
                    <p style="text-align: center; margin-bottom: 15px; color: var(--text-gray); font-family: 'Work Sans', sans-serif;">
                        Choose your analysis type:
                    </p>
                    <div style="display: flex; gap: 15px; justify-content: center; flex-wrap: wrap; align-items: stretch;">
                        <button id="generateAnimationBtn" class="analysis-type-btn" data-type="animation" style="display: none; background: var(--primary-color); color: white; border-color: var(--primary-color);">
                            <span class="analysis-icon"></span>
                            <span class="analysis-title">Generate Animation</span>
                            <span class="analysis-desc">Create 3D pose loop animation</span>
                        </button>
                        <button id="idealFormBtn" class="analysis-type-btn" data-type="ideal">
                            <span class="analysis-icon"></span>
                            <span class="analysis-title">Ideal Form</span>
                            <span class="analysis-desc">Get feedback on your shooting mechanics</span>
                        </button>
                        <button id="playerSimilarityBtn" class="analysis-type-btn" data-type="similarity">
                            <span class="analysis-icon"></span>
                            <span class="analysis-title">Player Match</span>
                            <span class="analysis-desc">See which pros shoot like you</span>
                        </button>
                        <button id="backToRecordBtn" class="analysis-type-btn" style="background: transparent; border-style: dashed;">
                            <span class="analysis-icon"></span>
                            <span class="analysis-title">Back</span>
                            <span class="analysis-desc">Choose a different video</span>
                        </button>
                    </div>
                    
                    <!-- Clip Button (shown after animation is generated) -->
                    <div id="clipButtonContainer" style="display: none; margin-top: 20px; text-align: center;">
                        <button id="clipShotsBtn" class="btn btn-secondary" style="padding: 12px 30px; font-size: 16px; border-radius: 10px;">
                             Clip Shots (Pre-shot to Elbow Drop)
                        </button>
                        <div id="clipStatus" style="margin-top: 10px; padding: 10px; border-radius: 8px; display: none; text-align: center;"></div>
                    </div>
                    
                    <!-- Download Extraction Button (shown after animation is generated) -->
                    <div id="downloadExtractionContainer" style="display: none; margin-top: 30px; padding-top: 30px; border-top: 1px solid var(--border-color); text-align: center;">
                        <button id="downloadExtractionBtn" class="btn btn-secondary" style="padding: 12px 30px; font-size: 16px; border-radius: 10px;">
                             Download Extraction (.js)
                        </button>
                        <p style="margin-top: 10px; color: var(--text-gray); font-size: 14px;">
                            Download angle data from uploaded video
                        </p>
                    </div>
                    
                    <!-- Save Player Data Form (shown after animation is generated) -->
                    <div id="savePlayerDataForm" style="display: none; margin-top: 30px; padding-top: 30px; border-top: 1px solid var(--border-color);">
                        <div style="background: var(--bg-surface); padding: 30px; border-radius: 15px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); max-width: 600px; margin: 0 auto;">
                            <h3 style="font-family: 'Bebas Neue', sans-serif; margin-bottom: 20px; font-size: 24px; letter-spacing: 1px; text-align: center;">Save Player Data</h3>
                            <p style="text-align: center; color: var(--text-gray); margin-bottom: 20px; font-size: 14px;">
                                Extract angles for each frame and save to player_data folder
                            </p>
                            <form id="savePlayerDataFormElement" style="display: flex; flex-direction: column; gap: 20px;">
                                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                                    <div>
                                        <label style="display: block; margin-bottom: 8px; font-weight: 600; font-size: 14px;">First Name *</label>
                                        <input type="text" id="playerFirstName" required style="width: 100%; padding: 12px; border: 2px solid var(--border-color); border-radius: 8px; font-size: 14px; background: var(--bg-card); color: var(--text-dark);">
                                    </div>
                                    <div>
                                        <label style="display: block; margin-bottom: 8px; font-weight: 600; font-size: 14px;">Last Name *</label>
                                        <input type="text" id="playerLastName" required style="width: 100%; padding: 12px; border: 2px solid var(--border-color); border-radius: 8px; font-size: 14px; background: var(--bg-card); color: var(--text-dark);">
                                    </div>
                                </div>
                                <button type="submit" class="btn btn-primary" style="padding: 12px 30px; font-size: 16px; border-radius: 10px; align-self: center;">
                                     Extract Angles & Save to Player Data
                                </button>
                                <div id="savePlayerDataStatus" style="margin-top: 10px; padding: 10px; border-radius: 8px; display: none; text-align: center;"></div>
                            </form>
                        </div>
                    </div>
                </div>

                <!-- Status removed - no longer needed -->
            </section>

            <!-- Step 3: Analysis Results -->
            <section id="step3" class="step" style="display: none;">
                <div id="loading" class="loading" style="display: none;">
                    <p>Analyzing your shot...</p>
                    <div class="spinner"></div>
                </div>

                <!-- Player Match Results UI -->
                <div id="playerMatchResults" class="player-match-results">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 40px;">
                        <div>
                            <h1 style="font-family: 'Bebas Neue', sans-serif; font-size: 48px; letter-spacing: 2px; margin-bottom: 10px;">
                                PLAYER <span style="color: var(--primary-color);">MATCH</span>
                            </h1>
                            <p style="color: var(--text-gray); margin: 0;">Your top 5 most similar pro players</p>
                        </div>
                        <button id="compareBenchmarksBtn" class="btn btn-secondary" style="padding: 12px 24px; font-size: 14px;">
                             Compare Benchmarks
                        </button>
                    </div>

                    <div class="pm-grid">
                        <!-- Left Column: Player List -->
                        <div class="pm-left">
                            <div class="pm-list" id="playerMatchList">
                                <div class="pm-row pm-row-selected" data-player="curry">
                                    <div class="pm-rank pm-rank-1">1</div>
                                    <div class="pm-info">
                                        <div class="pm-name">Stephen Curry</div>
                                        <div class="pm-archetype">Quick Release</div>
                                    </div>
                                    <div class="pm-similarity">
                                        <div class="pm-score">94%</div>
                                        <div class="pm-bar"><div class="pm-fill" style="width: 94%"></div></div>
                                    </div>
                                    <div class="pm-stats">
                                        <span>6'2"</span>
                                        <span>6'4" WS</span>
                                        <span>Right</span>
                                    </div>
                                </div>
                                <div class="pm-row" data-player="trae">
                                    <div class="pm-rank">2</div>
                                    <div class="pm-info">
                                        <div class="pm-name">Trae Young</div>
                                        <div class="pm-archetype">High Arc</div>
                                    </div>
                                    <div class="pm-similarity">
                                        <div class="pm-score">87%</div>
                                        <div class="pm-bar"><div class="pm-fill" style="width: 87%"></div></div>
                                    </div>
                                    <div class="pm-stats">
                                        <span>6'1"</span>
                                        <span>6'3" WS</span>
                                        <span>Right</span>
                                    </div>
                                </div>
                                <div class="pm-row" data-player="dame">
                                    <div class="pm-rank">3</div>
                                    <div class="pm-info">
                                        <div class="pm-name">Damian Lillard</div>
                                        <div class="pm-archetype">Deep Range</div>
                                    </div>
                                    <div class="pm-similarity">
                                        <div class="pm-score">82%</div>
                                        <div class="pm-bar"><div class="pm-fill" style="width: 82%"></div></div>
                                    </div>
                                    <div class="pm-stats">
                                        <span>6'2"</span>
                                        <span>6'8" WS</span>
                                        <span>Right</span>
                                    </div>
                                </div>
                                <div class="pm-row" data-player="kyrie">
                                    <div class="pm-rank">4</div>
                                    <div class="pm-info">
                                        <div class="pm-name">Kyrie Irving</div>
                                        <div class="pm-archetype">Textbook Form</div>
                                    </div>
                                    <div class="pm-similarity">
                                        <div class="pm-score">78%</div>
                                        <div class="pm-bar"><div class="pm-fill" style="width: 78%"></div></div>
                                    </div>
                                    <div class="pm-stats">
                                        <span>6'2"</span>
                                        <span>6'8" WS</span>
                                        <span>Right</span>
                                    </div>
                                </div>
                                <div class="pm-row" data-player="klay">
                                    <div class="pm-rank">5</div>
                                    <div class="pm-info">
                                        <div class="pm-name">Klay Thompson</div>
                                        <div class="pm-archetype">Set Shot</div>
                                    </div>
                                    <div class="pm-similarity">
                                        <div class="pm-score">74%</div>
                                        <div class="pm-bar"><div class="pm-fill" style="width: 74%"></div></div>
                                    </div>
                                    <div class="pm-stats">
                                        <span>6'6"</span>
                                        <span>6'9" WS</span>
                                        <span>Right</span>
                                    </div>
                                </div>
                            </div>

                            <!-- Quick Fixes -->
                            <div class="pm-fixes-header"><span></span> Quick Fixes</div>
                            <div class="pm-fix-item">
                                <button class="pm-fix-toggle">
                                    <div class="pm-fix-icon"></div>
                                    <div class="pm-fix-content">
                                        <div class="pm-fix-title">Stay more upright</div>
                                        <div class="pm-fix-tip">Reduce forward trunk lean to match Curry's vertical posture</div>
                                    </div>
                                    <span class="pm-fix-arrow"></span>
                                </button>
                                <div class="pm-drill-content">
                                    <div class="pm-drill-card">
                                        <div class="pm-drill-label">Recommended Drill</div>
                                        <div class="pm-drill-name">Wall Alignment Drill</div>
                                        <div class="pm-drill-desc">Stand with your back against a wall and practice your shooting motion. Keep your shoulders touching the wall throughout to build muscle memory for upright posture.</div>
                                        <div class="pm-drill-footer">
                                            <div class="pm-drill-meta"><span> 10 mins</span><span> 25 reps</span></div>
                                            <a href="#" target="_blank" class="pm-yt-link" title="Watch drill video">
                                                <svg viewBox="0 0 24 24"><path d="M23.498 6.186a3.016 3.016 0 0 0-2.122-2.136C19.505 3.545 12 3.545 12 3.545s-7.505 0-9.377.505A3.017 3.017 0 0 0 .502 6.186C0 8.07 0 12 0 12s0 3.93.502 5.814a3.016 3.016 0 0 0 2.122 2.136c1.871.505 9.376.505 9.376.505s7.505 0 9.377-.505a3.015 3.015 0 0 0 2.122-2.136C24 15.93 24 12 24 12s0-3.93-.502-5.814zM9.545 15.568V8.432L15.818 12l-6.273 3.568z"/></svg>
                                            </a>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div class="pm-fix-item">
                                <button class="pm-fix-toggle">
                                    <div class="pm-fix-icon"></div>
                                    <div class="pm-fix-content">
                                        <div class="pm-fix-title">Deepen your knee bend</div>
                                        <div class="pm-fix-tip">More knee flexion generates power and consistency at release</div>
                                    </div>
                                    <span class="pm-fix-arrow"></span>
                                </button>
                                <div class="pm-drill-content">
                                    <div class="pm-drill-card">
                                        <div class="pm-drill-label">Recommended Drill</div>
                                        <div class="pm-drill-name">Squat & Shoot</div>
                                        <div class="pm-drill-desc">Start in a low squat position before each shot. Explode up through your legs and transfer that energy into your shot. Focus on consistent knee bend depth.</div>
                                        <div class="pm-drill-footer">
                                            <div class="pm-drill-meta"><span> 15 mins</span><span> 20 reps</span></div>
                                            <a href="#" target="_blank" class="pm-yt-link" title="Watch drill video">
                                                <svg viewBox="0 0 24 24"><path d="M23.498 6.186a3.016 3.016 0 0 0-2.122-2.136C19.505 3.545 12 3.545 12 3.545s-7.505 0-9.377.505A3.017 3.017 0 0 0 .502 6.186C0 8.07 0 12 0 12s0 3.93.502 5.814a3.016 3.016 0 0 0 2.122 2.136c1.871.505 9.376.505 9.376.505s7.505 0 9.377-.505a3.015 3.015 0 0 0 2.122-2.136C24 15.93 24 12 24 12s0-3.93-.502-5.814zM9.545 15.568V8.432L15.818 12l-6.273 3.568z"/></svg>
                                            </a>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div class="pm-fix-item">
                                <button class="pm-fix-toggle">
                                    <div class="pm-fix-icon"></div>
                                    <div class="pm-fix-content">
                                        <div class="pm-fix-title">Snap your wrist fully</div>
                                        <div class="pm-fix-tip">Complete follow-through with a full wrist snap for better rotation</div>
                                    </div>
                                    <span class="pm-fix-arrow"></span>
                                </button>
                                <div class="pm-drill-content">
                                    <div class="pm-drill-card">
                                        <div class="pm-drill-label">Recommended Drill</div>
                                        <div class="pm-drill-name">Gooseneck Hold Drill</div>
                                        <div class="pm-drill-desc">After each shot, hold your follow-through with wrist fully snapped (gooseneck position) until the ball hits the rim. This builds muscle memory for complete wrist rotation.</div>
                                        <div class="pm-drill-footer">
                                            <div class="pm-drill-meta"><span> 10 mins</span><span> 30 reps</span></div>
                                            <a href="#" target="_blank" class="pm-yt-link" title="Watch drill video">
                                                <svg viewBox="0 0 24 24"><path d="M23.498 6.186a3.016 3.016 0 0 0-2.122-2.136C19.505 3.545 12 3.545 12 3.545s-7.505 0-9.377.505A3.017 3.017 0 0 0 .502 6.186C0 8.07 0 12 0 12s0 3.93.502 5.814a3.016 3.016 0 0 0 2.122 2.136c1.871.505 9.376.505 9.376.505s7.505 0 9.377-.505a3.015 3.015 0 0 0 2.122-2.136C24 15.93 24 12 24 12s0-3.93-.502-5.814zM9.545 15.568V8.432L15.818 12l-6.273 3.568z"/></svg>
                                            </a>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Right Column -->
                        <div class="pm-right">
                            <div class="pm-archetype-card">
                                <div class="pm-arch-label">Your Shot Archetype</div>
                                <div class="pm-arch-name">QUICK RELEASE</div>
                                <div class="pm-arch-desc">You have a fast, compact shooting motion with minimal wind-up. Your release point is optimized for getting shots off quickly against defenders.</div>
                            </div>

                            <div class="pm-traits">
                                <div class="pm-section-header">
                                    <span class="pm-section-title">Shared traits with</span>
                                    <span class="pm-player-name">Stephen Curry</span>
                                </div>
                                <div class="pm-trait-item">
                                    <div class="pm-trait-icon"></div>
                                    <div class="pm-trait-text">
                                        <div class="pm-trait-name">Release Angle</div>
                                        <div class="pm-trait-detail">Optimal 52 release trajectory</div>
                                    </div>
                                    <div class="pm-trait-match">96%</div>
                                </div>
                                <div class="pm-trait-item">
                                    <div class="pm-trait-icon"></div>
                                    <div class="pm-trait-text">
                                        <div class="pm-trait-name">Follow Through</div>
                                        <div class="pm-trait-detail">Full extension with wrist snap</div>
                                    </div>
                                    <div class="pm-trait-match">94%</div>
                                </div>
                                <div class="pm-trait-item">
                                    <div class="pm-trait-icon"></div>
                                    <div class="pm-trait-text">
                                        <div class="pm-trait-name">Release Height</div>
                                        <div class="pm-trait-detail">High release point above forehead</div>
                                    </div>
                                    <div class="pm-trait-match">92%</div>
                                </div>
                                <div class="pm-trait-item">
                                    <div class="pm-trait-icon"></div>
                                    <div class="pm-trait-text">
                                        <div class="pm-trait-name">Foot Alignment</div>
                                        <div class="pm-trait-detail">Squared stance to the basket</div>
                                    </div>
                                    <div class="pm-trait-match">89%</div>
                                </div>
                            </div>

                            <div class="pm-differences">
                                <div class="pm-section-header">
                                    <span class="pm-section-title">Key differences from</span>
                                    <span class="pm-player-name">Stephen Curry</span>
                                </div>
                                <div class="pm-diff-item">
                                    <div class="pm-diff-icon"></div>
                                    <div class="pm-diff-text">
                                        <div class="pm-diff-name">Trunk Lean</div>
                                        <div class="pm-diff-detail">More forward lean than Curry's upright form</div>
                                    </div>
                                    <div class="pm-diff-gap">-15%</div>
                                </div>
                                <div class="pm-diff-item">
                                    <div class="pm-diff-icon"></div>
                                    <div class="pm-diff-text">
                                        <div class="pm-diff-name">Knee Bend</div>
                                        <div class="pm-diff-detail">Less knee flexion at release point</div>
                                    </div>
                                    <div class="pm-diff-gap">-11%</div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="controls" style="display: flex; gap: 15px; justify-content: center; flex-wrap: wrap; margin-top: 40px; align-items: center;">
                        <button id="pmTryOther" class="btn btn-primary" style="padding: 18px 36px; font-size: 17px; background: linear-gradient(135deg, var(--primary-color) 0%, #ff8a9b 100%); box-shadow: 0 4px 15px rgba(255, 107, 122, 0.4);">
                             Get Personalized Form Tips
                        </button>
                        <button id="pmDownloadExtraction" class="btn btn-secondary" style="padding: 12px 20px; font-size: 14px; opacity: 0.8;">
                             Download Extraction
                        </button>
                        <button id="pmNewComparison" class="btn btn-secondary" style="padding: 12px 20px; font-size: 14px; opacity: 0.8;">New Comparison</button>
                    </div>
                </div>

                <!-- Benchmark Comparison Modal -->
                <div id="benchmarkComparisonModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.7); z-index: 10000; align-items: center; justify-content: center;">
                    <div style="background: var(--bg-primary); padding: 40px; border-radius: 15px; max-width: 600px; width: 90%; max-height: 90vh; overflow-y: auto; box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);">
                        <h2 style="font-family: 'Bebas Neue', sans-serif; font-size: 32px; margin-bottom: 30px; text-align: center;">
                            Compare <span style="color: var(--primary-color);">Benchmarks</span>
                        </h2>
                        
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 30px;">
                            <div>
                                <label style="display: block; margin-bottom: 8px; font-weight: 600; font-size: 14px;">Player 1</label>
                                <select id="benchmarkSelect1" style="width: 100%; padding: 12px; border: 2px solid var(--border-color); border-radius: 8px; font-size: 14px; background: var(--bg-card); color: var(--text-dark);">
                                    <option value="">Select player...</option>
                                </select>
                            </div>
                            <div>
                                <label style="display: block; margin-bottom: 8px; font-weight: 600; font-size: 14px;">Player 2</label>
                                <select id="benchmarkSelect2" style="width: 100%; padding: 12px; border: 2px solid var(--border-color); border-radius: 8px; font-size: 14px; background: var(--bg-card); color: var(--text-dark);">
                                    <option value="">Select player...</option>
                                </select>
                            </div>
                        </div>
                        
                        <div style="display: flex; gap: 10px; justify-content: center; margin-bottom: 20px;">
                            <button id="compareBenchmarksSubmitBtn" class="btn btn-primary" style="padding: 12px 30px; font-size: 16px;">
                                Compare
                            </button>
                            <button id="closeBenchmarkModalBtn" class="btn btn-secondary" style="padding: 12px 30px; font-size: 16px;">
                                Cancel
                            </button>
                        </div>
                        
                        <div id="benchmarkComparisonResults" style="display: none; margin-top: 30px; padding-top: 30px; border-top: 1px solid var(--border-color);">
                            <h3 style="font-family: 'Bebas Neue', sans-serif; font-size: 24px; margin-bottom: 20px; text-align: center;">
                                Similarity: <span id="benchmarkSimilarityScore" style="color: var(--primary-color);">0%</span>
                            </h3>
                            <div id="benchmarkComparisonDetails" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                                <!-- Comparison details will be populated here -->
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Ideal Form Results (hardcoded UI) -->
                <div id="idealFormResults" class="ideal-form-results">
                    <!-- Header -->
                    <header class="if-header">
                        <div>
                            <h1 class="if-title">IDEAL <span>SHOT</span></h1>
                            <div class="if-player-info">
                                <span><span class="if-label">Player</span>Marcus Chen</span>
                                <span><span class="if-label">Height</span>6'2"</span>
                                <span><span class="if-label">Hand</span>Right</span>
                            </div>
                        </div>
                        <div class="if-consistency-box">
                            <div class="if-consistency-label">Session Consistency</div>
                            <div class="if-consistency-value" id="ifConsistencyValue">78</div>
                            <div class="if-consistency-toggle">
                                <button class="if-toggle-btn active" data-period="session">Session</button>
                                <button class="if-toggle-btn" data-period="week">Week</button>
                                <button class="if-toggle-btn" data-period="month">Month</button>
                                <button class="if-toggle-btn" data-period="career">Career</button>
                            </div>
                        </div>
                    </header>

                    <!-- Main Content -->
                    <div class="if-main">
                        <!-- Left: Individual Metrics -->
                        <div class="if-metrics-grid">
                            <!-- Rhythm -->
                            <div class="if-metric-card">
                                <div class="if-metric-title">Rhythm</div>
                                <div class="if-rhythm-viz">
                                    <div class="if-rhythm-bar-container">
                                        <span class="if-rhythm-label">Knee</span>
                                        <div class="if-rhythm-track">
                                            <div class="if-rhythm-marker knee" style="left: 52%"></div>
                                        </div>
                                    </div>
                                    <div class="if-rhythm-bar-container">
                                        <span class="if-rhythm-label">Elbow</span>
                                        <div class="if-rhythm-track">
                                            <div class="if-rhythm-marker elbow" style="left: 60%"></div>
                                        </div>
                                    </div>
                                    <div class="if-rhythm-status offset">
                                        <span class="if-rhythm-dot"></span>
                                        0.06s offset
                                    </div>
                                </div>
                            </div>

                            <!-- Foot Alignment -->
                            <div class="if-metric-card">
                                <div class="if-metric-title">Foot Alignment</div>
                                <div class="if-arc-container">
                                    <svg class="if-arc-svg" viewBox="0 0 100 60">
                                        <path d="M 10 55 A 40 40 0 0 1 90 55" fill="none" stroke="#2A2A30" stroke-width="8" stroke-linecap="round"/>
                                        <path d="M 45 17.5 A 40 40 0 0 1 55 17.5" fill="none" stroke="rgba(61, 214, 140, 0.3)" stroke-width="10" stroke-linecap="round"/>
                                        <g transform="rotate(-74, 50, 55)">
                                            <line x1="50" y1="55" x2="50" y2="20" stroke="#FFD93D" stroke-width="3" stroke-linecap="round"/>
                                            <circle cx="50" cy="55" r="6" fill="#FFD93D"/>
                                        </g>
                                        <text x="8" y="58" fill="#5A5A64" font-size="8">-45</text>
                                        <text x="46" y="12" fill="#5A5A64" font-size="8">0</text>
                                        <text x="82" y="58" fill="#5A5A64" font-size="8">+45</text>
                                    </svg>
                                    <div class="if-arc-value" style="color: #FFD93D;">
                                        +8<span class="if-arc-unit"></span>
                                    </div>
                                </div>
                            </div>

                            <!-- Foot Stance -->
                            <div class="if-metric-card">
                                <div class="if-metric-title">Foot Stance</div>
                                <div class="if-stance-viz">
                                    <div class="if-stance-track">
                                        <div class="if-stance-zone" style="left: 23%; width: 54%;"></div>
                                        <div class="if-stance-foot" style="left: 36%"></div>
                                        <div class="if-stance-foot" style="left: 64%"></div>
                                    </div>
                                    <span class="if-stance-label" style="color: var(--success-color);">17" width (optimal)</span>
                                </div>
                            </div>

                            <!-- Release Height -->
                            <div class="if-metric-card">
                                <div class="if-metric-title">Release Height</div>
                                <div class="if-release-viz">
                                    <div class="if-release-bar">
                                        <div class="if-release-fill" style="height: 80%"></div>
                                        <div class="if-release-target" style="bottom: 77%; height: 7%;"></div>
                                    </div>
                                    <div class="if-release-info">
                                        <span class="if-release-value">96"</span>
                                        <span class="if-release-target-text">Target: 92-100"</span>
                                        <span class="if-release-target-text" style="color: var(--success-color);">In range</span>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Right: Radar Chart -->
                        <div class="if-radar-container">
                            <div class="if-radar-title">Mechanics Breakdown</div>
                            <div class="if-radar-chart">
                                <svg viewBox="0 0 300 280" style="width: 100%; max-width: 320px;">
                                    <!-- Grid circles -->
                                    <circle cx="150" cy="130" r="100" fill="none" stroke="#2A2A30" stroke-width="1"/>
                                    <circle cx="150" cy="130" r="75" fill="none" stroke="#2A2A30" stroke-width="1"/>
                                    <circle cx="150" cy="130" r="50" fill="none" stroke="#2A2A30" stroke-width="1"/>
                                    <circle cx="150" cy="130" r="25" fill="none" stroke="#2A2A30" stroke-width="1"/>

                                    <!-- Spokes -->
                                    <line x1="150" y1="130" x2="150" y2="30" stroke="#2A2A30" stroke-width="1"/>
                                    <line x1="150" y1="130" x2="245" y2="80" stroke="#2A2A30" stroke-width="1"/>
                                    <line x1="150" y1="130" x2="220" y2="200" stroke="#2A2A30" stroke-width="1"/>
                                    <line x1="150" y1="130" x2="80" y2="200" stroke="#2A2A30" stroke-width="1"/>
                                    <line x1="150" y1="130" x2="55" y2="80" stroke="#2A2A30" stroke-width="1"/>

                                    <!-- Ideal range (dashed) -->
                                    <polygon points="150,45 230,75 205,190 95,190 70,75" fill="rgba(61, 214, 140, 0.15)" stroke="#3DD68C" stroke-width="1" stroke-dasharray="4,4"/>

                                    <!-- Player polygon -->
                                    <polygon points="150,48 222,82 195,185 102,180 72,78" fill="rgba(255, 107, 122, 0.3)" stroke="#FF6B7A" stroke-width="2"/>

                                    <!-- Labels -->
                                    <text x="150" y="18" text-anchor="middle" fill="#8B8B96" font-size="11">Elbow Flare</text>
                                    <text x="258" y="78" text-anchor="start" fill="#8B8B96" font-size="11">Trunk Lean</text>
                                    <text x="228" y="218" text-anchor="start" fill="#8B8B96" font-size="11">Knee Bend</text>
                                    <text x="72" y="218" text-anchor="end" fill="#8B8B96" font-size="11">Elbow Ext.</text>
                                    <text x="42" y="78" text-anchor="end" fill="#8B8B96" font-size="11">Wrist Snap</text>

                                    <!-- Score labels on spokes -->
                                    <text x="150" y="55" text-anchor="middle" fill="#5A5A64" font-size="9">82</text>
                                    <text x="218" y="88" text-anchor="start" fill="#5A5A64" font-size="9">68</text>
                                    <text x="195" y="190" text-anchor="start" fill="#5A5A64" font-size="9">71</text>
                                    <text x="105" y="186" text-anchor="end" fill="#5A5A64" font-size="9">88</text>
                                    <text x="78" y="84" text-anchor="end" fill="#5A5A64" font-size="9">79</text>
                                </svg>
                            </div>
                            <div class="if-radar-legend">
                                <div class="if-legend-item">
                                    <span class="if-legend-dot player"></span>
                                    Your Form
                                </div>
                                <div class="if-legend-item">
                                    <span class="if-legend-dot ideal"></span>
                                    Ideal Range
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Bottom Section -->
                    <div class="if-bottom">
                        <!-- Quick Tips -->
                        <div>
                            <h2 class="if-section-title">Quick Tips</h2>
                            <ul class="if-tips-list">
                                <li class="if-tip-item">
                                    <span class="if-tip-bullet"></span>
                                    Focus on syncing your knee drive with elbow lift for smoother rhythm
                                </li>
                                <li class="if-tip-item">
                                    <span class="if-tip-bullet"></span>
                                    Square your feet to the basket before each shot
                                </li>
                                <li class="if-tip-item">
                                    <span class="if-tip-bullet"></span>
                                    Your release point is solid - maintain that consistency
                                </li>
                            </ul>
                        </div>

                        <!-- Work On -->
                        <div>
                            <h2 class="if-section-title">Work On</h2>
                            <div class="if-workon-grid">
                                <div class="if-workon-card">
                                    <div class="if-workon-title">Trunk Stability</div>
                                    <div class="if-workon-desc">Your torso shows slight forward lean at release, reducing shot consistency.</div>
                                    <div class="if-workon-drill">
                                        <div class="if-workon-drill-label">Recommended Drill</div>
                                        <div class="if-workon-drill-name">Wall Alignment Shots</div>
                                        <div class="if-workon-drill-tip">Stand 1ft from wall, shoot without touching. Builds upright muscle memory.</div>
                                    </div>
                                </div>
                                <div class="if-workon-card">
                                    <div class="if-workon-title">Knee-Elbow Sync</div>
                                    <div class="if-workon-desc">Your elbow extends 0.06s after knee peak, creating timing inconsistency.</div>
                                    <div class="if-workon-drill">
                                        <div class="if-workon-drill-label">Recommended Drill</div>
                                        <div class="if-workon-drill-name">Rhythm Counting</div>
                                        <div class="if-workon-drill-tip">Count "1-2-shoot" aloud. Knee bends on 1, elbow rises on 2, release on shoot.</div>
                                    </div>
                                </div>
                                <div class="if-workon-card">
                                    <div class="if-workon-title">Foot Alignment</div>
                                    <div class="if-workon-desc">Feet are angled 8 off center, affecting accuracy on longer shots.</div>
                                    <div class="if-workon-drill">
                                        <div class="if-workon-drill-label">Recommended Drill</div>
                                        <div class="if-workon-drill-name">Tape Line Drill</div>
                                        <div class="if-workon-drill-tip">Place tape on floor pointing at rim. Align feet parallel before each shot.</div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Controls -->
                    <div class="controls" style="display: flex; gap: 15px; justify-content: center; flex-wrap: wrap; margin-top: 40px; align-items: center;">
                        <button id="ifTryOther" class="btn btn-primary" style="padding: 18px 36px; font-size: 17px; background: linear-gradient(135deg, var(--primary-color) 0%, #ff8a9b 100%); box-shadow: 0 4px 15px rgba(255, 107, 122, 0.4);">
                            Compare to Pro Players
                        </button>
                        <button id="ifNewAnalysis" class="btn btn-secondary" style="padding: 12px 20px; font-size: 14px; opacity: 0.8;">New Analysis</button>
                    </div>
                </div>

            </section>

            <!-- Shot Tracker Section - Uses ONLY AI-Basketball-Shot-Detection-Tracker -->
            <!-- Benchmark Upload Section -->
            <section id="benchmarkUploadSection" class="step" style="display: none;">
                <h2 style="font-family: 'Bebas Neue', sans-serif; text-align: center; margin-bottom: 30px; letter-spacing: 2px;">
                    BENCHMARK <span style="color: var(--primary-color);">UPLOAD</span>
                </h2>
                <p style="text-align: center; color: var(--text-gray); margin-bottom: 30px; font-size: 16px;">
                    Upload a benchmark video to extract and save detailed metrics
                </p>

                <div style="max-width: 1000px; margin: 0 auto;">
                    <!-- Video Upload -->
                    <div style="background: var(--bg-surface); padding: 30px; border-radius: 15px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); margin-bottom: 30px;">
                        <h3 style="font-family: 'Bebas Neue', sans-serif; margin-bottom: 20px; font-size: 24px; letter-spacing: 1px;">Upload Video</h3>
                        <input type="file" id="benchmarkVideoInput" accept="video/*" style="display: none;">
                        <label for="benchmarkVideoInput" class="btn btn-primary" style="cursor: pointer; display: inline-block; padding: 12px 30px; font-size: 16px; border-radius: 10px; margin-bottom: 15px;">
                             Choose Benchmark Video
                        </label>
                        <div id="benchmarkVideoFileName" style="margin-top: 10px; font-size: 14px; color: var(--text-gray);"></div>
                        <button id="processBenchmarkBtn" class="btn btn-success" style="padding: 12px 30px; font-size: 16px; border-radius: 10px; margin-left: 10px; display: none;">
                             Process Video
                        </button>
                        <div id="benchmarkProcessingStatus" style="margin-top: 15px; padding: 10px; border-radius: 8px; display: none;"></div>
                    </div>

                    <!-- 3D Skeleton Viewer (same as shot sync) -->
                    <div id="benchmarkSkeletonContainer" style="background: var(--bg-surface); padding: 30px; border-radius: 15px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); margin-bottom: 30px; position: relative; display: none;">
                        <h3 style="font-family: 'Bebas Neue', sans-serif; margin-bottom: 20px; font-size: 24px; letter-spacing: 1px;">Processing Video</h3>
                        <div class="skeleton-viewer-container" style="position: relative; width: 100%; height: 500px; background: #1a1a1a; border-radius: 12px; overflow: hidden;">
                            <canvas id="benchmarkSkeletonCanvas" style="width: 100%; height: 100%; display: block;"></canvas>
                            
                            <!-- Processing overlay -->
                            <div id="benchmarkSkeletonProcessing" class="skeleton-processing" style="display: none;">
                                <div class="spinner"></div>
                                <p id="benchmarkProcessingStatusText">Extracting skeleton...</p>
                            </div>
                        </div>
                    </div>

                    <!-- Metrics Display -->
                    <div id="benchmarkMetricsDisplay" style="display: none;">
                        <div style="background: var(--bg-surface); padding: 30px; border-radius: 15px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); margin-bottom: 30px;">
                            <h3 style="font-family: 'Bebas Neue', sans-serif; margin-bottom: 20px; font-size: 24px; letter-spacing: 1px;">Extracted Metrics</h3>
                            
                            <!-- Toggle for single frame vs averaged -->
                            <div style="margin-bottom: 20px; display: flex; gap: 10px; align-items: center;">
                                <label style="font-weight: 600; font-size: 14px;">Display Mode:</label>
                                <button id="showSingleFrameBtn" class="btn btn-secondary" style="padding: 8px 16px; font-size: 14px;">Single Frame</button>
                                <button id="showAveragedBtn" class="btn btn-secondary active" style="padding: 8px 16px; font-size: 14px;">Averaged</button>
                            </div>

                            <!-- Frame Selector (for single frame mode) -->
                            <div id="frameSelectorContainer" style="margin-bottom: 20px; display: none;">
                                <label style="font-weight: 600; font-size: 14px; margin-right: 10px;">Frame:</label>
                                <input type="range" id="frameSlider" min="0" max="0" value="0" style="flex: 1; margin-right: 10px;">
                                <span id="frameNumber" style="font-weight: 600; min-width: 80px;">Frame 0</span>
                            </div>

                            <!-- Metrics Table -->
                            <div style="overflow-x: auto;">
                                <table id="benchmarkMetricsTable" style="width: 100%; border-collapse: collapse; font-size: 14px;">
                                    <thead>
                                        <tr style="background: var(--bg-card);">
                                            <th style="padding: 12px; text-align: left; border: 1px solid var(--border-color); font-weight: 600;">Metric</th>
                                            <th style="padding: 12px; text-align: center; border: 1px solid var(--border-color); font-weight: 600;">Value</th>
                                            <th style="padding: 12px; text-align: center; border: 1px solid var(--border-color); font-weight: 600;">Unit</th>
                                        </tr>
                                    </thead>
                                    <tbody id="benchmarkMetricsTableBody">
                                        <!-- Metrics will be populated here -->
                                    </tbody>
                                </table>
                            </div>
                        </div>

                        <!-- Save Benchmark Form -->
                        <div style="background: var(--bg-surface); padding: 30px; border-radius: 15px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                            <h3 style="font-family: 'Bebas Neue', sans-serif; margin-bottom: 20px; font-size: 24px; letter-spacing: 1px;">Save Benchmark</h3>
                            <form id="saveBenchmarkForm" style="display: flex; flex-direction: column; gap: 20px;">
                                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                                    <div>
                                        <label style="display: block; margin-bottom: 8px; font-weight: 600; font-size: 14px;">First Name *</label>
                                        <input type="text" id="benchmarkFirstName" required style="width: 100%; padding: 12px; border: 2px solid var(--border-color); border-radius: 8px; font-size: 14px; background: var(--bg-card); color: var(--text-dark);">
                                    </div>
                                    <div>
                                        <label style="display: block; margin-bottom: 8px; font-weight: 600; font-size: 14px;">Last Name *</label>
                                        <input type="text" id="benchmarkLastName" required style="width: 100%; padding: 12px; border: 2px solid var(--border-color); border-radius: 8px; font-size: 14px; background: var(--bg-card); color: var(--text-dark);">
                                    </div>
                                </div>
                                <button type="submit" class="btn btn-primary" style="padding: 12px 30px; font-size: 16px; border-radius: 10px; align-self: flex-start;">
                                     Save Benchmark to Player Data
                                </button>
                                <div id="saveBenchmarkStatus" style="margin-top: 10px; padding: 10px; border-radius: 8px; display: none;"></div>
                            </form>
                        </div>
                    </div>
                </div>
            </section>

            <section id="shotTrackerSection" class="step" style="display: none;">
                <h2 style="text-align: center; font-family: 'Forum', serif; margin-bottom: 12px;">
                    <span style="background: linear-gradient(135deg, var(--primary-color) 0%, var(--primary-hover) 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; font-weight: 700;">Shooting Percentage</span> Tracker
                </h2>
                <p style="text-align: center; color: #666; margin-bottom: 30px; font-size: 16px;">
                    Track your makes and misses in real-time. Uses <strong>AI-Basketball-Shot-Detection-Tracker</strong> exclusively.
                </p>

                <!-- Upload Form - EXACT COPY from original -->
                <div style="max-width: 800px; margin: 0 auto 30px; background: white; padding: 25px; border-radius: 15px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                    <form id="shotTrackerUploadForm" enctype="multipart/form-data" style="display: flex; flex-direction: column; align-items: center; gap: 15px;">
                        <input type="file" id="shotTrackerFileInput" name="video" accept="video/*" required style="display: none;">
                        <label for="shotTrackerFileInput" class="btn btn-primary" style="cursor: pointer; display: inline-block; padding: 12px 30px; font-size: 16px; border-radius: 10px;">
                             Choose Video File
                        </label>
                        <div id="uploadedFileName" style="margin-top: 10px; font-size: 14px; color: #666;"></div>
                        <button type="submit" id="uploadBtn" class="btn btn-success" style="padding: 12px 40px; font-size: 16px; border-radius: 10px;">Upload & Analyze Video</button>
                        <div id="uploadMessage" style="margin-top: 15px; padding: 10px; border-radius: 8px; display: none; width: 100%; text-align: center;"></div>
                    </form>
                </div>

                <!-- Video Stream - Clean video without overlays (overlays are drawn by ShotDetectorWeb but we'll show stats separately) -->
                <div class="video-container" style="text-align: center; margin-bottom: 30px; max-width: 800px; margin-left: auto; margin-right: auto; position: relative;">
                    <img id="shotTrackerVideoStream" src="/api/video_feed" alt="Video Stream" style="max-width: 100%; border-radius: 15px; background: #000;">
                    <!-- Algorithm Indicator -->
                    <div id="algorithmIndicator" style="position: absolute; top: 10px; left: 10px; background: rgba(0,0,0,0.85); color: white; padding: 12px 16px; border-radius: 8px; font-size: 11px; display: block; z-index: 3; border: 2px solid rgba(255,255,255,0.3); box-shadow: 0 2px 8px rgba(0,0,0,0.5);">
                        <div style="font-weight: 700; margin-bottom: 6px; font-size: 13px; color: #4ade80;"> Model: AI-Basketball-Shot-Detection-Tracker</div>
                        <div style="font-weight: 600; margin-bottom: 4px; font-size: 11px; color: #94a3b8;">YOLOv8 (best.pt)</div>
                    </div>
                    </div>

                <!-- Stats Bar - Above Heatmap -->
                <div style="max-width: 800px; margin: 30px auto; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); padding: 20px; border-radius: 15px; box-shadow: 0 4px 12px rgba(0,0,0,0.15);">
                    <div style="display: flex; justify-content: space-around; align-items: center; flex-wrap: wrap; gap: 20px; color: white;">
                        <div style="text-align: center;">
                            <div style="font-size: 14px; opacity: 0.9; margin-bottom: 5px; text-transform: uppercase; letter-spacing: 1px;">Makes</div>
                            <div style="font-size: 48px; font-weight: 700; font-family: 'Bebas Neue', sans-serif;" id="makesCount">0</div>
                    </div>
                        <div style="text-align: center;">
                            <div style="font-size: 14px; opacity: 0.9; margin-bottom: 5px; text-transform: uppercase; letter-spacing: 1px;">Attempts</div>
                            <div style="font-size: 48px; font-weight: 700; font-family: 'Bebas Neue', sans-serif;" id="attemptsCount">0</div>
                </div>
                        <div style="text-align: center;">
                            <div style="font-size: 14px; opacity: 0.9; margin-bottom: 5px; text-transform: uppercase; letter-spacing: 1px;">Percentage</div>
                            <div style="font-size: 48px; font-weight: 700; font-family: 'Bebas Neue', sans-serif;" id="percentage">0%</div>
                    </div>
                        <div style="text-align: center;">
                            <div style="font-size: 14px; opacity: 0.9; margin-bottom: 5px; text-transform: uppercase; letter-spacing: 1px;">Last Shot</div>
                            <div id="lastShotResult" style="font-size: 32px; font-weight: 700; font-family: 'Bebas Neue', sans-serif;">-</div>
                        </div>
                    </div>
                </div>

                <!-- Heatmap - EXACT COPY from original -->
                <div style="max-width: 800px; margin: 30px auto; background: white; padding: 20px; border-radius: 15px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                    <div style="font-size: 24px; font-weight: bold; margin-bottom: 15px; text-align: center;">Shot Heatmap</div>
                    <canvas id="shotTrackerHeatmap" width="800" height="600" style="background: rgba(0, 0, 0, 0.3); border-radius: 10px; max-width: 100%; height: auto; display: block; margin: 0 auto;"></canvas>
                    <div style="margin-top: 15px; font-size: 14px; text-align: center;">
                        <span style="color: #00ff00;"> Makes</span> | 
                        <span style="color: #ff0000;"> Misses</span>
                    </div>
                </div>
                
                <!-- Shot Tracker Stats Bar -->
                <div id="shotTrackerStatsBar" style="max-width: 800px; margin: 20px auto; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); padding: 20px; border-radius: 15px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); display: none;">
                    <div style="display: flex; justify-content: space-around; align-items: center; flex-wrap: wrap; gap: 20px; color: white;">
                        <div style="text-align: center;">
                            <div style="font-size: 14px; opacity: 0.9; margin-bottom: 5px; text-transform: uppercase; letter-spacing: 1px;">Total Makes</div>
                            <div style="font-size: 36px; font-weight: 700; font-family: 'Bebas Neue', sans-serif;" id="trackerTotalMakes">0</div>
                        </div>
                        <div style="text-align: center;">
                            <div style="font-size: 14px; opacity: 0.9; margin-bottom: 5px; text-transform: uppercase; letter-spacing: 1px;">Total Attempts</div>
                            <div style="font-size: 36px; font-weight: 700; font-family: 'Bebas Neue', sans-serif;" id="trackerTotalAttempts">0</div>
                        </div>
                        <div style="text-align: center;">
                            <div style="font-size: 14px; opacity: 0.9; margin-bottom: 5px; text-transform: uppercase; letter-spacing: 1px;">Shot Percentage</div>
                            <div style="font-size: 36px; font-weight: 700; font-family: 'Bebas Neue', sans-serif;" id="trackerShotPercentage">0%</div>
                        </div>
                    </div>
                </div>

                <!-- Save to Training Database Button -->
                <div style="text-align: center; margin-top: 30px; max-width: 800px; margin-left: auto; margin-right: auto;">
                    <button id="saveToTrainingDbBtn" class="btn btn-primary" onclick="if(typeof window.saveShotTrackerToTrainingDbLocal === 'function') { window.saveShotTrackerToTrainingDbLocal(); } else if(typeof saveShotTrackerToTrainingDb === 'function') { saveShotTrackerToTrainingDb(); } else { console.error('saveShotTrackerToTrainingDb function not found'); alert('Error: Save function not loaded. Please check console.'); }" style="min-width: 200px; padding: 12px 24px; font-size: 16px; font-weight: 600; background: linear-gradient(135deg, var(--primary-color) 0%, var(--primary-hover) 100%); border: none; box-shadow: 0 4px 12px rgba(0,0,0,0.15); cursor: pointer;">
                         Save to Training Database
                    </button>
                    <div id="saveTrainingDbMessage" style="margin-top: 15px; padding: 10px; border-radius: 8px; display: none; width: 100%; text-align: center; font-size: 14px;"></div>
                        </div>

                <!-- Back Button -->
                <div style="text-align: center; margin-top: 20px;">
                        <button id="backToShotSyncFromTracker" class="btn btn-secondary" style="min-width: 160px; padding: 12px 24px; font-size: 16px;"> Back to Shot Sync</button>
                </div>
            </section>
        </div>
    </div>

    <!-- Training Database View -->
    <div id="trainingDatabaseView" class="tab-view" style="display: none;">
        <div class="container" style="max-width: 1200px; margin: 40px auto; padding: 20px;">
            <h2 style="font-family: 'Bebas Neue', sans-serif; margin-bottom: 30px;">Training Database</h2>

            <!-- Shooting Percentage Tracker Button -->
            <div style="text-align: center; margin-bottom: 30px;">
                <button id="shotTrackerBtn" class="btn btn-primary" style="background: linear-gradient(135deg, var(--primary-color) 0%, var(--primary-hover) 100%); color: white; border: none; padding: 12px 28px; font-size: 16px; font-weight: 600; border-radius: 8px; cursor: pointer; box-shadow: 0 4px 12px rgba(255, 107, 122, 0.3); transition: all 0.3s ease;" onclick="showShotTracker()">
                     Shooting Percentage Tracker
                </button>
            </div>

            <div style="margin-bottom: 20px;">
                <label for="playerFilter" style="display: block; margin-bottom: 10px; font-weight: 600;">Filter by Player:</label>
                <select id="playerFilter" style="padding: 10px 15px; border: 2px solid #ddd; border-radius: 8px; font-size: 16px; font-family: 'Bebas Neue', sans-serif; min-width: 200px;">
                    <option value="">All Players</option>
                    <option value="curry">Stephen Curry</option>
                    <option value="lebron">LeBron James</option>
                    <option value="jordan">Michael Jordan</option>
                    <option value="durant">Kevin Durant</option>
                    <option value="clark">Caitlin Clark</option>
                    <option value="custom">Custom</option>
                </select>
            </div>
            <div style="background: white; padding: 30px; border-radius: 12px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                <canvas id="trainingChart" style="max-height: 400px;"></canvas>
            </div>
            
            <!-- Form Similarity Stats Bar -->
            <div id="formSimilarityStats" style="max-width: 1200px; margin: 20px auto; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); padding: 20px; border-radius: 15px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); display: none;">
                <div style="display: flex; justify-content: space-around; align-items: center; flex-wrap: wrap; gap: 20px; color: white;">
                    <div style="text-align: center;">
                        <div style="font-size: 14px; opacity: 0.9; margin-bottom: 5px; text-transform: uppercase; letter-spacing: 1px;">Total Sessions</div>
                        <div style="font-size: 36px; font-weight: 700; font-family: 'Bebas Neue', sans-serif;" id="formTotalSessions">0</div>
                    </div>
                    <div style="text-align: center;">
                        <div style="font-size: 14px; opacity: 0.9; margin-bottom: 5px; text-transform: uppercase; letter-spacing: 1px;">Average Score</div>
                        <div style="font-size: 36px; font-weight: 700; font-family: 'Bebas Neue', sans-serif;" id="formAvgScore">0%</div>
                    </div>
                    <div style="text-align: center;">
                        <div style="font-size: 14px; opacity: 0.9; margin-bottom: 5px; text-transform: uppercase; letter-spacing: 1px;">Best Score</div>
                        <div style="font-size: 36px; font-weight: 700; font-family: 'Bebas Neue', sans-serif;" id="formBestScore">0%</div>
                    </div>
                    <div style="text-align: center;">
                        <div style="font-size: 14px; opacity: 0.9; margin-bottom: 5px; text-transform: uppercase; letter-spacing: 1px;">Recent Average</div>
                        <div style="font-size: 36px; font-weight: 700; font-family: 'Bebas Neue', sans-serif;" id="formRecentAvg">0%</div>
                    </div>
                </div>
            </div>
            <div style="background: white; padding: 30px; border-radius: 12px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); margin-top: 30px;">
                <h3 style="font-family: 'Bebas Neue', sans-serif; margin-bottom: 20px; color: #333;">Shot Location Heatmap</h3>
                <p style="color: #666; margin-bottom: 20px; font-size: 14px;">Visualize your shot locations over time. Filter by time period to see your shooting patterns.</p>
                
                <!-- Shot Tracker Stats Bar for Training Database -->
                <div id="trainingDbShotTrackerStats" style="max-width: 100%; margin: 20px auto; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); padding: 20px; border-radius: 15px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); display: none;">
                    <div style="display: flex; justify-content: space-around; align-items: center; flex-wrap: wrap; gap: 20px; color: white;">
                        <div style="text-align: center;">
                            <div style="font-size: 14px; opacity: 0.9; margin-bottom: 5px; text-transform: uppercase; letter-spacing: 1px;">Total Makes</div>
                            <div style="font-size: 36px; font-weight: 700; font-family: 'Bebas Neue', sans-serif;" id="trainingDbTotalMakes">0</div>
                        </div>
                        <div style="text-align: center;">
                            <div style="font-size: 14px; opacity: 0.9; margin-bottom: 5px; text-transform: uppercase; letter-spacing: 1px;">Total Attempts</div>
                            <div style="font-size: 36px; font-weight: 700; font-family: 'Bebas Neue', sans-serif;" id="trainingDbTotalAttempts">0</div>
                        </div>
                        <div style="text-align: center;">
                            <div style="font-size: 14px; opacity: 0.9; margin-bottom: 5px; text-transform: uppercase; letter-spacing: 1px;">Shot Percentage</div>
                            <div style="font-size: 36px; font-weight: 700; font-family: 'Bebas Neue', sans-serif;" id="trainingDbShotPercentage">0%</div>
                        </div>
                    </div>
                </div>
                
                <!-- Time Interval Toggles -->
                <div style="margin-bottom: 20px; display: flex; gap: 10px; flex-wrap: wrap; justify-content: center;">
                    <button class="heatmap-interval-btn active" data-interval="session" onclick="setHeatmapInterval('session')" style="padding: 8px 16px; border: 2px solid var(--primary-color); background: var(--primary-color); color: white; border-radius: 8px; cursor: pointer; font-family: 'Bebas Neue', sans-serif; font-size: 14px; font-weight: 600;">Previous Session</button>
                    <button class="heatmap-interval-btn" data-interval="3" onclick="setHeatmapInterval(3)" style="padding: 8px 16px; border: 2px solid #ddd; background: white; color: #666; border-radius: 8px; cursor: pointer; font-family: 'Bebas Neue', sans-serif; font-size: 14px;">3 Sessions</button>
                    <button class="heatmap-interval-btn" data-interval="7" onclick="setHeatmapInterval(7)" style="padding: 8px 16px; border: 2px solid #ddd; background: white; color: #666; border-radius: 8px; cursor: pointer; font-family: 'Bebas Neue', sans-serif; font-size: 14px;">7 Sessions</button>
                    <button class="heatmap-interval-btn" data-interval="15" onclick="setHeatmapInterval(15)" style="padding: 8px 16px; border: 2px solid #ddd; background: white; color: #666; border-radius: 8px; cursor: pointer; font-family: 'Bebas Neue', sans-serif; font-size: 14px;">15 Sessions</button>
                    <button class="heatmap-interval-btn" data-interval="30" onclick="setHeatmapInterval(30)" style="padding: 8px 16px; border: 2px solid #ddd; background: white; color: #666; border-radius: 8px; cursor: pointer; font-family: 'Bebas Neue', sans-serif; font-size: 14px;">30 Sessions</button>
                    <button class="heatmap-interval-btn" data-interval="60" onclick="setHeatmapInterval(60)" style="padding: 8px 16px; border: 2px solid #ddd; background: white; color: #666; border-radius: 8px; cursor: pointer; font-family: 'Bebas Neue', sans-serif; font-size: 14px;">60 Sessions</button>
                    <button class="heatmap-interval-btn" data-interval="all" onclick="setHeatmapInterval('all')" style="padding: 8px 16px; border: 2px solid #ddd; background: white; color: #666; border-radius: 8px; cursor: pointer; font-family: 'Bebas Neue', sans-serif; font-size: 14px;">All Time</button>
                </div>
                
                <div style="position: relative; width: 100%; height: 500px; border: 2px solid #ddd; border-radius: 8px; background: #f8f9fa;">
                    <canvas id="shotHeatmap" style="width: 100%; height: 100%; border-radius: 6px;"></canvas>
                </div>
                <div style="margin-top: 15px; display: flex; gap: 20px; align-items: center; justify-content: center; flex-wrap: wrap;">
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <div style="width: 20px; height: 20px; background: #00ff00; border-radius: 50%; border: 2px solid #333;"></div>
                        <span style="font-size: 14px; color: #666;">Make</span>
                    </div>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <div style="width: 20px; height: 20px; background: #ff0000; border-radius: 50%; border: 2px solid #333;"></div>
                        <span style="font-size: 14px; color: #666;">Miss</span>
                    </div>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <div style="width: 20px; height: 20px; background: linear-gradient(to right, rgba(0,255,0,0.1), rgba(255,0,0,0.8)); border-radius: 4px; border: 1px solid #333;"></div>
                        <span style="font-size: 14px; color: #666;">Heat Intensity</span>
                    </div>
                </div>
            </div>
            <div id="trainingStats" style="margin-top: 30px; display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px;">
                <!-- Stats will be populated here -->
            </div>
        </div>
    </div>

    <!-- Progress Pics View -->
    <div id="progressPicsView" class="tab-view" style="display: none;">
        <div class="container" style="max-width: 1200px; margin: 40px auto; padding: 20px;">
            <h2 style="font-family: 'Bebas Neue', sans-serif; margin-bottom: 30px;"> Progress Pics</h2>
            <p style="color: var(--text-gray); margin-bottom: 30px; text-align: center;">
                Track your progress by uploading photos daily. See how far you've come!
            </p>
            
            <!-- Upload Section -->
            <div style="background: var(--bg-surface); padding: 30px; border-radius: 12px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); margin-bottom: 30px;">
                <h3 style="font-family: 'Bebas Neue', sans-serif; margin-bottom: 20px; color: var(--text-dark);">Add New Progress Pic</h3>
                <div style="display: flex; flex-direction: column; gap: 15px; align-items: center;">
                    <input type="file" id="progressPicUpload" accept="image/*" capture="environment" style="display: none;">
                    <button id="selectProgressPicBtn" class="btn btn-primary" style="min-width: 200px; padding: 12px 24px;">
                         Choose Photo
                    </button>
                    <div id="progressPicPreview" style="display: none; margin-top: 20px; width: 100%; max-width: 300px;">
                        <img id="previewImage" src="" alt="Preview" style="max-width: 100%; max-height: 300px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.2); display: block; margin: 0 auto;">
                        <div style="margin-top: 15px; width: 100%;">
                            <label style="display: block; margin-bottom: 5px; font-weight: 600; font-size: 14px; color: var(--text-dark); font-family: 'Bebas Neue', sans-serif;">Caption (optional):</label>
                            <input type="text" id="progressPicCaption" placeholder="e.g., Weight: 180 lbs, Body Fat: 12%" style="width: 100%; padding: 10px; border: 2px solid #ddd; border-radius: 8px; font-family: 'Bebas Neue', sans-serif; font-size: 14px; box-sizing: border-box;">
                            <div style="font-size: 12px; color: var(--text-gray); margin-top: 5px; font-family: 'Bebas Neue', sans-serif;">Add weight, body fat %, or any notes</div>
                        </div>
                        <div style="margin-top: 15px; display: flex; gap: 10px; justify-content: center;">
                            <button id="saveProgressPicBtn" class="btn btn-success" style="min-width: 150px;"> Save Photo</button>
                            <button id="cancelProgressPicBtn" class="btn btn-secondary" style="min-width: 150px;"> Cancel</button>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Gallery Section -->
            <div style="background: var(--bg-surface); padding: 30px; border-radius: 12px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                <h3 style="font-family: 'Bebas Neue', sans-serif; margin-bottom: 20px; color: var(--text-dark);">Your Progress Gallery</h3>
                <div id="progressPicsGallery" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(250px, 1fr)); gap: 20px;">
                    <p style="grid-column: 1 / -1; text-align: center; color: var(--text-gray); padding: 40px;">
                        No progress pics yet. Upload your first photo to get started!
                    </p>
                </div>
            </div>
        </div>
    </div>

    <!-- Badges View -->
    <div id="badgesView" class="tab-view" style="display: none;">
        <div class="container" style="max-width: 1200px; margin: 40px auto; padding: 20px;">
            <h2 style="font-family: 'Bebas Neue', sans-serif; margin-bottom: 30px;">Your Badges</h2>
            <div id="badgesContainer" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(250px, 1fr)); gap: 30px;">
                <!-- Badges will be populated here -->
            </div>
        </div>
    </div>

    <!-- Workouts View -->
    <div id="workoutsView" class="tab-view" style="display: none;">
        <div class="container" style="max-width: 1200px; margin: 40px auto; padding: 20px;">
            <h2 style="font-family: 'Bebas Neue', sans-serif; margin-bottom: 30px;">Workout Tracker</h2>
            
            <!-- Tabs for different workout sections -->
            <div style="display: flex; gap: 10px; border-bottom: 2px solid #e2e8f0; margin-bottom: 30px;">
                <button id="weeklyScheduleTab" class="chart-tab active" onclick="switchWorkoutTab('schedule')" style="padding: 10px 20px; background: none; border: none; border-bottom: 3px solid var(--primary-color); color: var(--primary-color); font-weight: 600; cursor: pointer; font-family: 'Bebas Neue', sans-serif;">Weekly Schedule</button>
                <button id="customGymTab" class="chart-tab" onclick="switchWorkoutTab('gym')" style="padding: 10px 20px; background: none; border: none; border-bottom: 3px solid transparent; color: #aaa; cursor: pointer; font-family: 'Bebas Neue', sans-serif;">Custom Gym Workouts</button>
                <button id="customSportsTab" class="chart-tab" onclick="switchWorkoutTab('sports')" style="padding: 10px 20px; background: none; border: none; border-bottom: 3px solid transparent; color: #aaa; cursor: pointer; font-family: 'Bebas Neue', sans-serif;">Custom Sports Workouts</button>
            </div>
            
            <!-- Weekly Schedule Section -->
            <div id="weeklyScheduleSection" class="workout-section">
                <div style="background: white; padding: 30px; border-radius: 12px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); margin-bottom: 30px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                        <h3 style="font-family: 'Bebas Neue', sans-serif; margin: 0;">Weekly Workout Schedule</h3>
                        <div style="display: flex; gap: 10px; align-items: center;">
                            <!-- Google Calendar sync button hidden for now -->
                            <!-- <button id="syncToCalendarBtn" onclick="syncToGoogleCalendar()" class="btn" style="padding: 8px 16px; background: #34a853; color: white;">
                                 Sync to Google Calendar
                            </button> -->
                            <button id="editScheduleBtn" onclick="toggleScheduleEditMode()" class="btn btn-secondary" style="padding: 8px 16px;">Edit</button>
                        </div>
                    </div>
                    <!-- Google Calendar status hidden for now -->
                    <!-- <div id="calendarStatus" style="margin-bottom: 15px; padding: 10px; background: #f8f9fa; border-radius: 8px; font-family: 'Bebas Neue', sans-serif; font-size: 14px; color: #666;">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <span id="calendarStatusText">Click "Connect Google Calendar" to sync your schedule</span>
                            <a href="https://calendar.google.com" target="_blank" style="color: #4285f4; text-decoration: none; font-weight: 600; margin-left: 10px;">
                                 Open Google Calendar 
                            </a>
                        </div>
                    </div> -->
                    <div style="overflow-x: auto;">
                        <div id="weeklyScheduleContainer" style="display: grid; grid-template-columns: repeat(7, 1fr); gap: 15px; font-family: 'Bebas Neue', sans-serif;">
                            <!-- Weekly schedule will be populated here -->
                        </div>
                    </div>
                </div>
                
                <!-- Add Workout to Day Modal/Form -->
                <div id="addWorkoutToDayForm" style="background: white; padding: 30px; border-radius: 12px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); display: none;">
                    <h3 style="font-family: 'Bebas Neue', sans-serif; margin-bottom: 20px;">Add Workout to <span id="selectedDayName"></span></h3>
                    <div style="margin-bottom: 15px;">
                        <label style="display: block; margin-bottom: 5px; font-weight: 600; font-size: 14px;">Select Workout:</label>
                        <select id="workoutSelect" style="width: 100%; padding: 10px; border: 2px solid #ddd; border-radius: 8px; font-family: 'Bebas Neue', sans-serif;">
                            <option value="">-- Select a workout --</option>
                        </select>
                    </div>
                    <div style="display: flex; gap: 10px;">
                        <button onclick="addWorkoutToDay()" class="btn" style="padding: 10px 20px; background: #6b7280; color: white;">Add</button>
                        <button onclick="cancelAddWorkoutToDay()" class="btn btn-secondary" style="padding: 10px 20px;">Cancel</button>
                    </div>
                </div>
            </div>
            
            <!-- Custom Gym Workouts Section -->
            <div id="customGymSection" class="workout-section" style="display: none;">
                <div style="background: white; padding: 30px; border-radius: 12px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); margin-bottom: 30px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                        <h3 style="font-family: 'Bebas Neue', sans-serif; margin: 0;">My Custom Gym Workouts</h3>
                        <button onclick="showCreateGymWorkoutForm()" class="btn" style="padding: 10px 20px; background: #6b7280; color: white;">Create New Workout</button>
                    </div>
                    <div id="customGymWorkoutsList">
                        <!-- Custom gym workouts will be populated here -->
                    </div>
                </div>
                
                <!-- Create/Edit Gym Workout Form -->
                <div id="createGymWorkoutForm" style="background: white; padding: 30px; border-radius: 12px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); display: none;">
                    <h3 style="font-family: 'Bebas Neue', sans-serif; margin-bottom: 20px;" id="gymWorkoutFormTitle">Create Custom Gym Workout</h3>
                    <div style="margin-bottom: 20px;">
                        <label style="display: block; margin-bottom: 5px; font-weight: 600; font-size: 14px;">Workout Name:</label>
                        <input type="text" id="gymWorkoutName" placeholder="e.g., Push Day" style="width: 100%; padding: 10px; border: 2px solid #ddd; border-radius: 8px; font-family: 'Bebas Neue', sans-serif;">
                    </div>
                    <div style="margin-bottom: 20px;">
                        <label style="display: block; margin-bottom: 10px; font-weight: 600; font-size: 14px;">Days of the Week:</label>
                        <div style="display: flex; flex-wrap: wrap; gap: 15px; font-family: 'Bebas Neue', sans-serif;">
                            <label style="display: flex; align-items: center; cursor: pointer; color: #1a1a1a; font-weight: 500;">
                                <input type="checkbox" id="gymWorkoutDay-Monday" value="Monday" style="margin-right: 8px; width: 18px; height: 18px; cursor: pointer;">
                                Monday
                            </label>
                            <label style="display: flex; align-items: center; cursor: pointer; color: #1a1a1a; font-weight: 500;">
                                <input type="checkbox" id="gymWorkoutDay-Tuesday" value="Tuesday" style="margin-right: 8px; width: 18px; height: 18px; cursor: pointer;">
                                Tuesday
                            </label>
                            <label style="display: flex; align-items: center; cursor: pointer; color: #1a1a1a; font-weight: 500;">
                                <input type="checkbox" id="gymWorkoutDay-Wednesday" value="Wednesday" style="margin-right: 8px; width: 18px; height: 18px; cursor: pointer;">
                                Wednesday
                            </label>
                            <label style="display: flex; align-items: center; cursor: pointer; color: #1a1a1a; font-weight: 500;">
                                <input type="checkbox" id="gymWorkoutDay-Thursday" value="Thursday" style="margin-right: 8px; width: 18px; height: 18px; cursor: pointer;">
                                Thursday
                            </label>
                            <label style="display: flex; align-items: center; cursor: pointer; color: #1a1a1a; font-weight: 500;">
                                <input type="checkbox" id="gymWorkoutDay-Friday" value="Friday" style="margin-right: 8px; width: 18px; height: 18px; cursor: pointer;">
                                Friday
                            </label>
                            <label style="display: flex; align-items: center; cursor: pointer; color: #1a1a1a; font-weight: 500;">
                                <input type="checkbox" id="gymWorkoutDay-Saturday" value="Saturday" style="margin-right: 8px; width: 18px; height: 18px; cursor: pointer;">
                                Saturday
                            </label>
                            <label style="display: flex; align-items: center; cursor: pointer; color: #1a1a1a; font-weight: 500;">
                                <input type="checkbox" id="gymWorkoutDay-Sunday" value="Sunday" style="margin-right: 8px; width: 18px; height: 18px; cursor: pointer;">
                                Sunday
                            </label>
                        </div>
                    </div>
                    <div id="gymWorkoutExercises" style="margin-bottom: 20px;">
                        <h4 style="font-family: 'Bebas Neue', sans-serif; margin-bottom: 15px;">Exercises</h4>
                        <div id="gymWorkoutExercisesList">
                            <!-- Exercises will be added here -->
                        </div>
                        <button onclick="addExerciseToGymWorkout()" class="btn btn-secondary" style="padding: 8px 16px; margin-top: 10px;">+ Add Exercise</button>
                    </div>
                    <div style="display: flex; gap: 10px;">
                        <button onclick="saveGymWorkout()" class="btn" style="padding: 10px 20px; background: #6b7280; color: white;">Save Workout</button>
                        <button onclick="cancelGymWorkoutForm()" class="btn btn-secondary" style="padding: 10px 20px;">Cancel</button>
                    </div>
                </div>
            </div>
            
            <!-- Custom Sports Workouts Section -->
            <div id="customSportsSection" class="workout-section" style="display: none;">
                <div style="background: white; padding: 30px; border-radius: 12px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); margin-bottom: 30px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                        <h3 style="font-family: 'Bebas Neue', sans-serif; margin: 0;">My Custom Sports Workouts</h3>
                        <button onclick="showCreateSportsWorkoutForm()" class="btn" style="padding: 10px 20px; background: #6b7280; color: white;">Create New Workout</button>
                    </div>
                    <div id="customSportsWorkoutsList">
                        <!-- Custom sports workouts will be populated here -->
                    </div>
                </div>
                
                <!-- Create/Edit Sports Workout Form -->
                <div id="createSportsWorkoutForm" style="background: white; padding: 30px; border-radius: 12px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); display: none;">
                    <h3 style="font-family: 'Bebas Neue', sans-serif; margin-bottom: 20px;" id="sportsWorkoutFormTitle">Create Custom Sports Workout</h3>
                    <div style="margin-bottom: 20px;">
                        <label style="display: block; margin-bottom: 5px; font-weight: 600; font-size: 14px;">Workout Name:</label>
                        <input type="text" id="sportsWorkoutName" placeholder="e.g., Shooting Practice" style="width: 100%; padding: 10px; border: 2px solid #ddd; border-radius: 8px; font-family: 'Bebas Neue', sans-serif;">
                    </div>
                    <div style="margin-bottom: 20px;">
                        <label style="display: block; margin-bottom: 10px; font-weight: 600; font-size: 14px;">Days of the Week:</label>
                        <div style="display: flex; flex-wrap: wrap; gap: 15px; font-family: 'Bebas Neue', sans-serif;">
                            <label style="display: flex; align-items: center; cursor: pointer; color: #1a1a1a; font-weight: 500;">
                                <input type="checkbox" id="sportsWorkoutDay-Monday" value="Monday" style="margin-right: 8px; width: 18px; height: 18px; cursor: pointer;">
                                Monday
                            </label>
                            <label style="display: flex; align-items: center; cursor: pointer; color: #1a1a1a; font-weight: 500;">
                                <input type="checkbox" id="sportsWorkoutDay-Tuesday" value="Tuesday" style="margin-right: 8px; width: 18px; height: 18px; cursor: pointer;">
                                Tuesday
                            </label>
                            <label style="display: flex; align-items: center; cursor: pointer; color: #1a1a1a; font-weight: 500;">
                                <input type="checkbox" id="sportsWorkoutDay-Wednesday" value="Wednesday" style="margin-right: 8px; width: 18px; height: 18px; cursor: pointer;">
                                Wednesday
                            </label>
                            <label style="display: flex; align-items: center; cursor: pointer; color: #1a1a1a; font-weight: 500;">
                                <input type="checkbox" id="sportsWorkoutDay-Thursday" value="Thursday" style="margin-right: 8px; width: 18px; height: 18px; cursor: pointer;">
                                Thursday
                            </label>
                            <label style="display: flex; align-items: center; cursor: pointer; color: #1a1a1a; font-weight: 500;">
                                <input type="checkbox" id="sportsWorkoutDay-Friday" value="Friday" style="margin-right: 8px; width: 18px; height: 18px; cursor: pointer;">
                                Friday
                            </label>
                            <label style="display: flex; align-items: center; cursor: pointer; color: #1a1a1a; font-weight: 500;">
                                <input type="checkbox" id="sportsWorkoutDay-Saturday" value="Saturday" style="margin-right: 8px; width: 18px; height: 18px; cursor: pointer;">
                                Saturday
                            </label>
                            <label style="display: flex; align-items: center; cursor: pointer; color: #1a1a1a; font-weight: 500;">
                                <input type="checkbox" id="sportsWorkoutDay-Sunday" value="Sunday" style="margin-right: 8px; width: 18px; height: 18px; cursor: pointer;">
                                Sunday
                            </label>
                        </div>
                    </div>
                    <div style="margin-bottom: 20px;">
                        <label style="display: block; margin-bottom: 5px; font-weight: 600; font-size: 14px;">Workout Details:</label>
                        <textarea id="sportsWorkoutDetails" placeholder="e.g., Shoot 1000 shots from the three-point line, focusing on form and consistency" rows="5" style="width: 100%; padding: 10px; border: 2px solid #ddd; border-radius: 8px; font-family: 'Bebas Neue', sans-serif; resize: vertical;"></textarea>
                    </div>
                    <div style="display: flex; gap: 10px;">
                        <button onclick="saveSportsWorkout()" class="btn" style="padding: 10px 20px; background: #6b7280; color: white;">Save Workout</button>
                        <button onclick="cancelSportsWorkoutForm()" class="btn btn-secondary" style="padding: 10px 20px;">Cancel</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Nutrition View -->
    <div id="nutritionView" class="tab-view" style="display: none;">
        <div class="container" style="max-width: 1200px; margin: 40px auto; padding: 20px;">
            <h2 style="font-family: 'Bebas Neue', sans-serif; margin-bottom: 30px;">Nutrition Tracker</h2>
            
            <!-- Settings for goals -->
            <div style="background: white; padding: 20px; border-radius: 12px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); margin-bottom: 30px;">
                <h3 style="font-family: 'Bebas Neue', sans-serif; margin-bottom: 15px; color: #333;">Daily Goals</h3>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                    <div>
                        <label style="display: block; margin-bottom: 5px; font-weight: 600; color: #333;">Daily Calorie Goal:</label>
                        <input type="number" id="calorieGoal" placeholder="2000" style="width: 100%; padding: 8px; border: 2px solid #ddd; border-radius: 8px; font-family: 'Bebas Neue', sans-serif; color: #333;">
                    </div>
                    <div>
                        <label style="display: block; margin-bottom: 5px; font-weight: 600; color: #333;">Ideal Weight (lbs):</label>
                        <input type="number" id="idealWeight" placeholder="150" style="width: 100%; padding: 8px; border: 2px solid #ddd; border-radius: 8px; font-family: 'Bebas Neue', sans-serif; color: #333;">
                    </div>
                    <div>
                        <label style="display: block; margin-bottom: 5px; font-weight: 600; color: #333;">Daily Protein Goal (g):</label>
                        <input type="number" id="proteinGoal" placeholder="150" style="width: 100%; padding: 8px; border: 2px solid #ddd; border-radius: 8px; font-family: 'Bebas Neue', sans-serif; color: #333;">
                    </div>
                    <div style="display: flex; align-items: flex-end;">
                        <button onclick="saveNutritionGoalsLocal()" class="btn btn-primary" style="width: 100%;">Save Goals</button>
                    </div>
                </div>
            </div>

            <!-- Nutrition Section Tabs -->
            <div style="display: flex; gap: 10px; border-bottom: 2px solid #e2e8f0; margin-bottom: 30px;">
                <button id="nutritionTrackerTab" class="chart-tab active" onclick="switchNutritionTab('tracker')" style="padding: 10px 20px; background: none; border: none; border-bottom: 3px solid var(--primary-color); color: var(--primary-color); font-weight: 600; cursor: pointer; font-family: 'Bebas Neue', sans-serif;">Nutrition Tracker</button>
                <button id="customDietPlansTab" class="chart-tab" onclick="switchNutritionTab('dietPlans')" style="padding: 10px 20px; background: none; border: none; border-bottom: 3px solid transparent; color: #aaa; cursor: pointer; font-family: 'Bebas Neue', sans-serif;">Custom Diet Plans</button>
            </div>

            <!-- Nutrition Tracker Section -->
            <div id="nutritionTrackerSection" class="nutrition-section">
            <!-- Chart Tabs -->
            <div style="background: white; padding: 30px; border-radius: 12px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); margin-bottom: 30px;">
                <div style="display: flex; gap: 10px; border-bottom: 2px solid #e2e8f0; margin-bottom: 15px;">
                    <button id="calorieChartTab" class="chart-tab active" onclick="switchNutritionChart('calories')">Daily Calories</button>
                    <button id="weightChartTab" class="chart-tab" onclick="switchNutritionChart('weight')">Weight</button>
                </div>
                <div style="display: flex; gap: 8px; margin-bottom: 20px; flex-wrap: wrap;">
                    <button class="period-tab" data-days="3" onclick="switchTimePeriod(3, this)">Past 3 days</button>
                    <button class="period-tab active" data-days="7" onclick="switchTimePeriod(7, this)">Past 7 days</button>
                    <button class="period-tab" data-days="15" onclick="switchTimePeriod(15, this)">Past 15 days</button>
                    <button class="period-tab" data-days="30" onclick="switchTimePeriod(30, this)">Past 30 days</button>
                    <button class="period-tab" data-days="60" onclick="switchTimePeriod(60, this)">Past 60 days</button>
                </div>
                <canvas id="nutritionChart" style="max-height: 400px;"></canvas>
                <!-- Weight Entry Form (shown only on weight tab) -->
                <div id="weightEntryForm" style="display: none; margin-top: 20px; padding-top: 20px; border-top: 2px solid #e2e8f0;">
                    <h4 style="font-family: 'Bebas Neue', sans-serif; margin-bottom: 15px;">Add Weight Entry</h4>
                    <div style="display: grid; grid-template-columns: 1fr auto; gap: 10px; align-items: end;">
                        <div>
                            <label style="display: block; margin-bottom: 5px; font-weight: 600; font-size: 14px;">Weight (lbs):</label>
                            <input type="number" id="weightInput" placeholder="150" step="0.1" min="0" style="width: 100%; padding: 10px; border: 2px solid #ddd; border-radius: 8px; font-family: 'Bebas Neue', sans-serif;">
                        </div>
                        <div>
                            <button onclick="addWeightEntry()" class="btn" style="padding: 10px 20px; background: #6b7280; color: white;">Add Weight</button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Daily Food Log -->
            <div id="foodLogSection" style="background: white; padding: 30px; border-radius: 12px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); margin-bottom: 30px;">
                <h3 id="foodLogTitle" style="font-family: 'Bebas Neue', sans-serif; margin-bottom: 20px;">Today's Food Log</h3>
                <div id="dailyFoodLog" style="display: flex; flex-direction: column; gap: 10px;">
                    <!-- Food log entries will be populated here -->
                </div>
                <div id="dailyTotals" style="margin-top: 20px; padding-top: 20px; border-top: 2px solid #e2e8f0; display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 15px;">
                    <!-- Totals will be calculated and displayed here -->
                </div>
            </div>

            <!-- Food Entry Section -->
            <div style="background: white; padding: 30px; border-radius: 12px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); margin-bottom: 30px;">
                <h3 style="font-family: 'Bebas Neue', sans-serif; margin-bottom: 20px;">Add Food</h3>
                
                <!-- Regular Food Entry -->
                <div id="regularFoodEntry" style="display: grid; grid-template-columns: 2fr 1fr 1fr 1fr auto; gap: 10px; margin-bottom: 20px; align-items: end;">
                    <div>
                        <label style="display: block; margin-bottom: 5px; font-weight: 600; font-size: 14px;">Food Name:</label>
                        <input type="text" id="foodName" placeholder="e.g., Grilled Chicken" style="width: 100%; padding: 10px; border: 2px solid #ddd; border-radius: 8px; font-family: 'Bebas Neue', sans-serif;">
                    </div>
                    <div>
                        <label style="display: block; margin-bottom: 5px; font-weight: 600; font-size: 14px;">Servings:</label>
                        <input type="number" id="foodServings" placeholder="1" step="0.25" min="0" style="width: 100%; padding: 10px; border: 2px solid #ddd; border-radius: 8px; font-family: 'Bebas Neue', sans-serif;">
                    </div>
                    <div>
                        <label style="display: block; margin-bottom: 5px; font-weight: 600; font-size: 14px;">Calories per serving:</label>
                        <input type="number" id="foodCalories" placeholder="200" min="0" style="width: 100%; padding: 10px; border: 2px solid #ddd; border-radius: 8px; font-family: 'Bebas Neue', sans-serif;">
                    </div>
                    <div>
                        <label style="display: block; margin-bottom: 5px; font-weight: 600; font-size: 14px;">Protein per serving (g):</label>
                        <input type="number" id="foodProtein" placeholder="25" min="0" step="0.1" style="width: 100%; padding: 10px; border: 2px solid #ddd; border-radius: 8px; font-family: 'Bebas Neue', sans-serif;">
                    </div>
                    <div>
                        <button onclick="addFood()" class="btn" style="padding: 10px 20px; background: #6b7280; color: white;">Add</button>
                    </div>
                </div>

                <!-- Favorites Section -->
                <div style="border-top: 2px solid #e2e8f0; padding-top: 20px;">
                    <h4 style="font-family: 'Bebas Neue', sans-serif; margin-bottom: 15px;">Favorites</h4>
                    <div style="display: grid; grid-template-columns: 2fr 1fr 1fr auto; gap: 10px; align-items: end; margin-bottom: 20px;">
                        <div>
                            <label style="display: block; margin-bottom: 5px; font-weight: 600; font-size: 14px;">Add to Favorites:</label>
                            <input type="text" id="favoriteFoodName" placeholder="Food name" style="width: 100%; padding: 10px; border: 2px solid #ddd; border-radius: 8px; font-family: 'Bebas Neue', sans-serif;">
                        </div>
                        <div>
                            <label style="display: block; margin-bottom: 5px; font-weight: 600; font-size: 14px;">Calories per serving:</label>
                            <input type="number" id="favoriteCalories" placeholder="200" min="0" style="width: 100%; padding: 10px; border: 2px solid #ddd; border-radius: 8px; font-family: 'Bebas Neue', sans-serif;">
                        </div>
                        <div>
                            <label style="display: block; margin-bottom: 5px; font-weight: 600; font-size: 14px;">Protein per serving (g):</label>
                            <input type="number" id="favoriteProtein" placeholder="25" min="0" step="0.1" style="width: 100%; padding: 10px; border: 2px solid #ddd; border-radius: 8px; font-family: 'Bebas Neue', sans-serif;">
                        </div>
                        <div>
                            <button onclick="addFavorite()" class="btn" style="padding: 10px 20px; white-space: nowrap; background: #6b7280; color: white;">Save Favorite</button>
                        </div>
                    </div>
                    <div id="favoritesList" style="display: flex; flex-direction: column; gap: 10px;">
                        <!-- Favorites will be populated here -->
                    </div>
                </div>
            </div>
            </div>

            <!-- Custom Diet Plans Section -->
            <div id="customDietPlansSection" class="nutrition-section" style="display: none;">
                <div style="background: white; padding: 30px; border-radius: 12px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); margin-bottom: 30px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                        <h3 style="font-family: 'Bebas Neue', sans-serif; margin: 0;">My Custom Diet Plans</h3>
                        <button onclick="showCreateDietPlanForm()" class="btn" style="padding: 10px 20px; background: #6b7280; color: white;">Create New Diet Plan</button>
                    </div>
                    <div id="customDietPlansList">
                        <!-- Custom diet plans will be populated here -->
                    </div>
                </div>
                
                <!-- Create/Edit Diet Plan Form -->
                <div id="createDietPlanForm" style="background: white; padding: 30px; border-radius: 12px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); display: none;">
                    <h3 style="font-family: 'Bebas Neue', sans-serif; margin-bottom: 20px;" id="dietPlanFormTitle">Create Custom Diet Plan</h3>
                    <div style="margin-bottom: 20px;">
                        <label style="display: block; margin-bottom: 5px; font-weight: 600; font-size: 14px;">Plan Name:</label>
                        <input type="text" id="dietPlanName" placeholder="e.g., High Protein Cutting Plan" style="width: 100%; padding: 10px; border: 2px solid #ddd; border-radius: 8px; font-family: 'Bebas Neue', sans-serif;">
                    </div>
                    <div style="margin-bottom: 20px;">
                        <label style="display: block; margin-bottom: 10px; font-weight: 600; font-size: 14px;">Days of the Week:</label>
                        <div style="display: flex; flex-wrap: wrap; gap: 15px; font-family: 'Bebas Neue', sans-serif;">
                            <label style="display: flex; align-items: center; cursor: pointer; color: #1a1a1a; font-weight: 500;">
                                <input type="checkbox" id="dietPlanDay-Monday" value="Monday" style="margin-right: 8px; width: 18px; height: 18px; cursor: pointer;">
                                Monday
                            </label>
                            <label style="display: flex; align-items: center; cursor: pointer; color: #1a1a1a; font-weight: 500;">
                                <input type="checkbox" id="dietPlanDay-Tuesday" value="Tuesday" style="margin-right: 8px; width: 18px; height: 18px; cursor: pointer;">
                                Tuesday
                            </label>
                            <label style="display: flex; align-items: center; cursor: pointer; color: #1a1a1a; font-weight: 500;">
                                <input type="checkbox" id="dietPlanDay-Wednesday" value="Wednesday" style="margin-right: 8px; width: 18px; height: 18px; cursor: pointer;">
                                Wednesday
                            </label>
                            <label style="display: flex; align-items: center; cursor: pointer; color: #1a1a1a; font-weight: 500;">
                                <input type="checkbox" id="dietPlanDay-Thursday" value="Thursday" style="margin-right: 8px; width: 18px; height: 18px; cursor: pointer;">
                                Thursday
                            </label>
                            <label style="display: flex; align-items: center; cursor: pointer; color: #1a1a1a; font-weight: 500;">
                                <input type="checkbox" id="dietPlanDay-Friday" value="Friday" style="margin-right: 8px; width: 18px; height: 18px; cursor: pointer;">
                                Friday
                            </label>
                            <label style="display: flex; align-items: center; cursor: pointer; color: #1a1a1a; font-weight: 500;">
                                <input type="checkbox" id="dietPlanDay-Saturday" value="Saturday" style="margin-right: 8px; width: 18px; height: 18px; cursor: pointer;">
                                Saturday
                            </label>
                            <label style="display: flex; align-items: center; cursor: pointer; color: #1a1a1a; font-weight: 500;">
                                <input type="checkbox" id="dietPlanDay-Sunday" value="Sunday" style="margin-right: 8px; width: 18px; height: 18px; cursor: pointer;">
                                Sunday
                            </label>
                        </div>
                    </div>
                    <div id="dietPlanMeals" style="margin-bottom: 20px;">
                        <h4 style="font-family: 'Bebas Neue', sans-serif; margin-bottom: 15px;">Meals</h4>
                        <div style="margin-bottom: 10px; padding: 10px; background: #f8f9fa; border-radius: 4px; font-size: 12px; color: #666; font-family: 'Bebas Neue', sans-serif;">
                            <strong>Time fields:</strong> Hour (1-12), Minute (0-59), AM/PM
                        </div>
                        <div id="dietPlanMealsList">
                            <!-- Meals will be added here -->
                        </div>
                        <button onclick="addMealToDietPlan()" class="btn btn-secondary" style="padding: 8px 16px; margin-top: 10px;">+ Add Meal</button>
                    </div>
                    <div id="dietPlanTotals" style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; font-family: 'Bebas Neue', sans-serif;">
                            <div>
                                <strong>Total Calories:</strong> <span id="dietPlanTotalCalories">0</span>
                            </div>
                            <div>
                                <strong>Total Protein:</strong> <span id="dietPlanTotalProtein">0</span> g
                            </div>
                        </div>
                    </div>
                    <div style="display: flex; gap: 10px;">
                        <button onclick="saveDietPlan()" class="btn" style="padding: 10px 20px; background: #6b7280; color: white;">Save Diet Plan</button>
                        <button onclick="cancelDietPlanForm()" class="btn btn-secondary" style="padding: 10px 20px;">Cancel</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Player Benchmark Data -->
    <script src="/tool/player_data/lebron_benchmark.js"></script>
    <script src="/tool/player_data/curry_benchmark.js"></script>
    <script>
        // ====================== API CONFIGURATION ======================
        // Set the backend API base URL
        // If running Flask on a different port, change this to match (e.g., 'http://localhost:5001')
        // Set to empty string to disable backend and use only client-side detection
        // Using Python backend with AI-Basketball-Shot-Detection-Tracker (YOLOv8)
        const API_BASE_URL = 'http://localhost:5001';  // Python backend with YOLOv8 detection
        
        // ====================== GLOBAL STATE ======================
        // Make lebron_data available globally
        if (typeof lebron_data !== 'undefined') {
            window.lebron_benchmark_data = lebron_data;
        }
        // Make curry_data available globally
        if (typeof curry_data !== 'undefined') {
            window.curry_benchmark_data = curry_data;
        }
    </script>
    <script src="/tool/app.js"></script>
    <script>
        // Tab navigation functions
        let trainingChart = null;
        
        function showShotSync() {
            // Hide all tab views
            document.querySelectorAll('.tab-view').forEach(view => view.style.display = 'none');
            
            // Hide shot tracker section
            const shotTrackerSection = document.getElementById('shotTrackerSection');
            if (shotTrackerSection) shotTrackerSection.style.display = 'none';
            
            // Hide benchmark upload section
            const benchmarkUploadSection = document.getElementById('benchmarkUploadSection');
            if (benchmarkUploadSection) benchmarkUploadSection.style.display = 'none';
            
            // Show ShotSync header
            const header = document.querySelector('header');
            if (header) header.style.display = 'block';
            
            // Show main content (player selection page)
            const mainContent = document.querySelector('.main-content');
            if (mainContent) mainContent.style.display = 'block';
            
            // Show step2 (record shot) by default - skip player selection
            document.querySelectorAll('.step').forEach(step => step.style.display = 'none');
            const step2 = document.getElementById('step2');
            if (step2) step2.style.display = 'block';
            
            // Update nav tabs
            document.querySelectorAll('.nav-tab').forEach(tab => tab.classList.remove('active'));
            document.getElementById('shotSyncTab').classList.add('active');
            
            // Save active tab to localStorage
            localStorage.setItem('activeTab', 'shotSync');
        }
        
        function showBenchmarkUpload() {
            // Hide all tab views
            document.querySelectorAll('.tab-view').forEach(view => view.style.display = 'none');
            
            // Hide shot tracker section
            const shotTrackerSection = document.getElementById('shotTrackerSection');
            if (shotTrackerSection) shotTrackerSection.style.display = 'none';
            
            // Show ShotSync header
            const header = document.querySelector('header');
            if (header) header.style.display = 'block';
            
            // Show main content
            const mainContent = document.querySelector('.main-content');
            if (mainContent) mainContent.style.display = 'block';
            
            // Hide all steps
            document.querySelectorAll('.step').forEach(step => step.style.display = 'none');
            
            // Show benchmark upload section
            document.getElementById('benchmarkUploadSection').style.display = 'block';
            
            // Update nav tabs
            document.querySelectorAll('.nav-tab').forEach(tab => tab.classList.remove('active'));
            document.getElementById('benchmarkUploadTab').classList.add('active');
            
            // Save active tab to localStorage
            localStorage.setItem('activeTab', 'benchmarkUpload');
        }
        
        window.showBenchmarkUpload = showBenchmarkUpload;
        window.showWorkouts = showWorkouts;
        
        function showTrainingDatabase() {
            // Hide all views
            document.querySelectorAll('.tab-view').forEach(view => view.style.display = 'none');
            const mainContent = document.querySelector('.main-content');
            if (mainContent) mainContent.style.display = 'none';
            
            // Hide ShotSync header on Training Database page
            const header = document.querySelector('header');
            if (header) header.style.display = 'none';

            // Show training database
            document.getElementById('trainingDatabaseView').style.display = 'block';
            
            // Update nav tabs
            document.querySelectorAll('.nav-tab').forEach(tab => tab.classList.remove('active'));
            document.getElementById('trainingDbTab').classList.add('active');
            
            // Save active tab to localStorage
            localStorage.setItem('activeTab', 'trainingDatabase');
            
            // Load training data
            loadTrainingDatabase();
        }
        
        function showProgressPics() {
            // Hide all views
            document.querySelectorAll('.tab-view').forEach(view => view.style.display = 'none');
            const mainContent = document.querySelector('.main-content');
            if (mainContent) mainContent.style.display = 'none';

            // Hide ShotSync header on Progress Pics page
            const header = document.querySelector('header');
            if (header) header.style.display = 'none';

            // Show progress pics
            document.getElementById('progressPicsView').style.display = 'block';
            
            // Update nav tabs
            document.querySelectorAll('.nav-tab').forEach(tab => tab.classList.remove('active'));
            document.getElementById('progressPicsTab').classList.add('active');
            
            // Save active tab to localStorage
            localStorage.setItem('activeTab', 'progressPics');
            
            // Load progress pics
            loadProgressPics();
        }
        
        function showBadges() {
            // Hide all views
            document.querySelectorAll('.tab-view').forEach(view => view.style.display = 'none');
            const mainContent = document.querySelector('.main-content');
            if (mainContent) mainContent.style.display = 'none';

            // Hide ShotSync header on Badges page
            const header = document.querySelector('header');
            if (header) header.style.display = 'none';

            // Show badges
            document.getElementById('badgesView').style.display = 'block';
            
            // Update nav tabs
            document.querySelectorAll('.nav-tab').forEach(tab => tab.classList.remove('active'));
            document.getElementById('badgesTab').classList.add('active');
            
            // Save active tab to localStorage
            localStorage.setItem('activeTab', 'badges');
            
            // Load badges
            loadBadges();
        }
        
        function showMainContent() {
            // Hide all tab views
            document.querySelectorAll('.tab-view').forEach(view => view.style.display = 'none');
            
            // Show main content
            const mainContent = document.querySelector('.main-content');
            if (mainContent) mainContent.style.display = 'block';
            
            // Update nav tabs
            document.querySelectorAll('.nav-tab').forEach(tab => tab.classList.remove('active'));
        }
        
        async function loadTrainingDatabase() {
            const user = window.firebaseAuth?.currentUser;
            if (!user) {
                document.getElementById('trainingChart').parentElement.innerHTML = '<p style="text-align: center; padding: 40px;">Please sign in to view your training database.</p>';
                return;
            }
            
            const playerFilter = document.getElementById('playerFilter').value;
            // Get all scores (including shot tracker sessions) - don't filter by player for shot tracker
            let scores = await window.getTrainingScores(user.uid, null);
            
            // If player filter is set and not empty, filter out shot tracker sessions (they're separate)
            if (playerFilter) {
                scores = scores.filter(s => s.player === playerFilter);
            } else {
                // Include all sessions (form sessions and shot tracker sessions)
                // No filtering needed
            }
            
            if (scores.length === 0) {
                document.getElementById('trainingChart').parentElement.innerHTML = '<p style="text-align: center; padding: 40px;">No training data yet. Start practicing to see your progress!</p>';
                document.getElementById('trainingStats').innerHTML = '';
                return;
            }
            
            // Prepare chart data
            const labels = [];
            const dataPoints = [];
            const playerNames = {
                'curry': 'Stephen Curry',
                'lebron': 'LeBron James',
                'jordan': 'Michael Jordan',
                'durant': 'Kevin Durant',
                'clark': 'Caitlin Clark',
                'custom': 'Custom',
                'shot_tracker': 'Shot Tracker'
            };
            
            // Create a copy for processing (don't modify original)
            const scoresCopy = [...scores];
            
            // Reverse to show chronological order
            scoresCopy.reverse().forEach((score, index) => {
                const date = score.createdAt?.toDate ? score.createdAt.toDate() : new Date();
                labels.push(date.toLocaleDateString());
                // Use similarityScore (which is percentage for shot tracker sessions)
                dataPoints.push(score.similarityScore || 0);
            });
            
            console.log('Loaded scores:', scores.length, 'shot tracker sessions:', scores.filter(s => s.sessionType === 'shot_tracker').length);
            
            // Create or update chart
            const ctx = document.getElementById('trainingChart').getContext('2d');
            if (trainingChart) {
                trainingChart.destroy();
            }
            
            trainingChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Similarity Score (%)',
                        data: dataPoints,
                        borderColor: 'rgb(255, 107, 122)',
                        backgroundColor: 'rgba(255, 107, 122, 0.1)',
                        tension: 0.4,
                        fill: true
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    plugins: {
                        title: {
                            display: true,
                            text: `Training Progress ${playerFilter ? `- ${playerNames[playerFilter] || playerFilter}` : ''}`,
                            font: {
                                size: 18,
                                family: "'Courier Prime', monospace"
                            }
                        },
                        legend: {
                            display: true
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            max: 100,
                            ticks: {
                                callback: function(value) {
                                    return value + '%';
                                }
                            }
                        }
                    }
                }
            });
            
            // Calculate stats - include shot tracker sessions
            const allScores = dataPoints;
            const shotTrackerSessions = scores.filter(s => s.sessionType === 'shot_tracker');
            const formSessions = scores.filter(s => !s.sessionType || s.sessionType !== 'shot_tracker');
            
            // Calculate form-based stats (only from form sessions, not shot tracker)
            const formScores = formSessions.map(s => s.similarityScore || 0);
            const avgScore = formScores.length > 0 ? formScores.reduce((a, b) => a + b, 0) / formScores.length : 0;
            const maxScore = formScores.length > 0 ? Math.max(...formScores) : 0;
            const minScore = formScores.length > 0 ? Math.min(...formScores) : 0;
            const recentFormScores = formScores.slice(-5);
            const recentAvg = recentFormScores.length > 0 ? recentFormScores.reduce((a, b) => a + b, 0) / recentFormScores.length : 0;
            
            // Calculate shot tracker stats
            const totalMakes = shotTrackerSessions.reduce((sum, s) => sum + (s.makes || 0), 0);
            const totalAttempts = shotTrackerSessions.reduce((sum, s) => sum + (s.attempts || 0), 0);
            const shotPercentage = totalAttempts > 0 ? Math.round((totalMakes / totalAttempts) * 100) : 0;
            
            // Update form similarity stats bar
            const formStatsBar = document.getElementById('formSimilarityStats');
            if (formStatsBar && formSessions.length > 0) {
                formStatsBar.style.display = 'block';
                document.getElementById('formTotalSessions').textContent = formSessions.length;
                document.getElementById('formAvgScore').textContent = avgScore.toFixed(1) + '%';
                document.getElementById('formBestScore').textContent = maxScore.toFixed(1) + '%';
                document.getElementById('formRecentAvg').textContent = recentAvg.toFixed(1) + '%';
            } else if (formStatsBar) {
                formStatsBar.style.display = 'none';
            }
            
            // Update shot tracker stats bar (will be updated by heatmap function based on interval)
            
            document.getElementById('trainingStats').innerHTML = `
                <div class="stat-card">
                    <div class="stat-label">Total Sessions</div>
                    <div class="stat-value">${scores.length}</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Form Sessions</div>
                    <div class="stat-value">${formSessions.length}</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Shot Tracker Sessions</div>
                    <div class="stat-value">${shotTrackerSessions.length}</div>
                </div>
            `;
            
            // Store scores and labels for heatmap filtering
            window.trainingScores = scoresCopy;
            window.trainingDateLabels = labels;
            
            // Load and render heatmap with current interval
            const currentInterval = window.currentHeatmapInterval || 'session';
            loadShotHeatmap(scoresCopy, labels, currentInterval);
        }
        
        // Heatmap interval state
        window.currentHeatmapInterval = 'session';
        
        function setHeatmapInterval(interval) {
            window.currentHeatmapInterval = interval;
            
            // Update button styles
            document.querySelectorAll('.heatmap-interval-btn').forEach(btn => {
                btn.classList.remove('active');
                btn.style.border = '2px solid #ddd';
                btn.style.background = 'white';
                btn.style.color = '#666';
            });
            
            const activeBtn = document.querySelector(`.heatmap-interval-btn[data-interval="${interval}"]`);
            if (activeBtn) {
                activeBtn.classList.add('active');
                activeBtn.style.border = '2px solid var(--primary-color)';
                activeBtn.style.background = 'var(--primary-color)';
                activeBtn.style.color = 'white';
            }
            
            // Reload heatmap with new interval
            if (window.trainingScores && window.trainingDateLabels) {
                loadShotHeatmap(window.trainingScores, window.trainingDateLabels, interval);
            }
        }
        
        async function loadShotHeatmap(scores, dateLabels, interval = 'session') {
            try {
                const heatmapCanvas = document.getElementById('shotHeatmap');
                if (!heatmapCanvas) return;
                
                const ctx = heatmapCanvas.getContext('2d');
                const rect = heatmapCanvas.parentElement.getBoundingClientRect();
                heatmapCanvas.width = rect.width;
                heatmapCanvas.height = 500;
                
                // Clear canvas
                ctx.clearRect(0, 0, heatmapCanvas.width, heatmapCanvas.height);
                
                // Get shot data from backend
                const user = window.firebaseAuth?.currentUser;
                if (!user) return;
                
                // Get date range from scores
                if (scores.length === 0) {
                    ctx.fillStyle = '#999';
                    ctx.font = '16px "Courier Prime", monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText('No shot data available', heatmapCanvas.width / 2, heatmapCanvas.height / 2);
                    return;
                }
                
                // Filter scores based on interval
                // IMPORTANT: scores array is already sorted by date (newest first) from getTrainingScores
                let filteredScores = [];
                if (interval === 'session') {
                    // Previous session only (most recent) - prioritize shot tracker sessions
                    if (scores.length > 0) {
                        // Find the most recent shot tracker session, or fall back to most recent any session
                        const shotTrackerSession = scores.find(s => s.sessionType === 'shot_tracker');
                        filteredScores = shotTrackerSession ? [shotTrackerSession] : [scores[0]]; // scores[0] is newest
                    }
                } else if (interval === 'all') {
                    // All time
                    filteredScores = scores;
                } else if (typeof interval === 'number') {
                    // Number of sessions (most recent N sessions)
                    filteredScores = scores.slice(0, interval); // Already sorted newest first
                } else {
                    filteredScores = scores;
                }
                
                console.log('Filtered scores for heatmap:', filteredScores.length, 'sessions, interval:', interval, 'first session type:', filteredScores[0]?.sessionType);
                
                if (filteredScores.length === 0) {
                    ctx.fillStyle = '#999';
                    ctx.font = '16px "Courier Prime", monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText('No data for selected interval', heatmapCanvas.width / 2, heatmapCanvas.height / 2);
                    return;
                }
                
                const firstDate = filteredScores[0].createdAt?.toDate ? filteredScores[0].createdAt.toDate() : new Date();
                const lastDate = filteredScores[filteredScores.length - 1].createdAt?.toDate ? filteredScores[filteredScores.length - 1].createdAt.toDate() : new Date();
                
                // Fetch shot locations from backend AND from Firebase training database
                const [backendResponse, firebaseShots] = await Promise.all([
                    fetch('/api/get_shot_heatmap_data', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            start_date: firstDate.toISOString().split('T')[0],
                            end_date: lastDate.toISOString().split('T')[0]
                        })
                    }),
                    // Also get shot tracker sessions from Firebase
                    (async () => {
                        try {
                            const user = window.firebaseAuth?.currentUser;
                            if (!user) return [];
                            
                            const q = query(
                                collection(window.firebaseDB, 'trainingScores'),
                                where('userId', '==', user.uid),
                                where('sessionType', '==', 'shot_tracker')
                            );
                            const querySnapshot = await getDocs(q);
                            const sessions = [];
                            querySnapshot.forEach((doc) => {
                                const data = doc.data();
                                if (data.shotLocations && Array.isArray(data.shotLocations)) {
                                    sessions.push({
                                        shotLocations: data.shotLocations,
                                        createdAt: data.createdAt
                                    });
                                }
                            });
                            return sessions;
                        } catch (error) {
                            console.error('Error fetching Firebase shot data:', error);
                            return [];
                        }
                    })()
                ]);
                
                const backendData = await backendResponse.json();
                let allShots = [];
                
                // Add backend shots
                if (backendData.success && backendData.shots && backendData.shots.length > 0) {
                    allShots = allShots.concat(backendData.shots.map(shot => ({
                        ...shot,
                        source: 'backend'
                    })));
                }
                
                // Add Firebase shots (from saved training database sessions)
                // Filter by the selected interval
                firebaseShots.forEach(session => {
                    const sessionDate = session.createdAt?.toDate ? session.createdAt.toDate() : new Date();
                    
                    // Check if this session matches the filtered scores
                    const sessionMatches = filteredScores.some(score => {
                        const scoreDate = score.createdAt?.toDate ? score.createdAt.toDate() : new Date();
                        // Match by date (same day) or by sessionType if it's a shot tracker session
                        return (score.sessionType === 'shot_tracker' && 
                                Math.abs(sessionDate.getTime() - scoreDate.getTime()) < 60000) || // Within 1 minute
                               (sessionDate.toDateString() === scoreDate.toDateString());
                    });
                    
                    if (sessionMatches && sessionDate >= firstDate && sessionDate <= lastDate) {
                        session.shotLocations.forEach(shot => {
                            allShots.push({
                                x: shot.x,
                                y: shot.y,
                                is_make: shot.is_make,
                                result: shot.is_make ? 'make' : 'miss',
                                timestamp: shot.timestamp || sessionDate.getTime() / 1000,
                                source: 'firebase'
                            });
                        });
                    }
                });
                
                console.log('Total shots after filtering:', allShots.length, 'from backend:', backendData.shots?.length || 0, 'from firebase:', firebaseShots.length);
                
                if (allShots.length === 0) {
                    ctx.fillStyle = '#999';
                    ctx.font = '16px "Courier Prime", monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText('No shot locations recorded yet', heatmapCanvas.width / 2, heatmapCanvas.height / 2);
                    return;
                }
                
                // Filter shots to match the selected interval
                const filteredShots = allShots.filter(shot => {
                    const shotDate = new Date((shot.timestamp || 0) * 1000);
                    return shotDate >= firstDate && shotDate <= lastDate;
                });
                
                if (filteredShots.length === 0) {
                    ctx.fillStyle = '#999';
                    ctx.font = '16px "Courier Prime", monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText('No shots in selected interval', heatmapCanvas.width / 2, heatmapCanvas.height / 2);
                    return;
                }
                
                // Use the same drawing function as shot tracker
                // Draw basketball court background
                drawBasketballCourtForHeatmap(ctx, heatmapCanvas.width, heatmapCanvas.height);
                
                // Calculate and display stats for this interval
                const intervalShotTrackerSessions = filteredScores.filter(s => s.sessionType === 'shot_tracker');
                const intervalMakes = intervalShotTrackerSessions.reduce((sum, s) => sum + (s.makes || 0), 0);
                const intervalAttempts = intervalShotTrackerSessions.reduce((sum, s) => sum + (s.attempts || 0), 0);
                const intervalPercentage = intervalAttempts > 0 ? Math.round((intervalMakes / intervalAttempts) * 100) : 0;
                
                // Update shot tracker stats bar (for shot tracker section)
                const trackerStatsBar = document.getElementById('shotTrackerStatsBar');
                if (trackerStatsBar && intervalShotTrackerSessions.length > 0) {
                    trackerStatsBar.style.display = 'block';
                    document.getElementById('trackerTotalMakes').textContent = intervalMakes;
                    document.getElementById('trackerTotalAttempts').textContent = intervalAttempts;
                    document.getElementById('trackerShotPercentage').textContent = intervalPercentage + '%';
                } else if (trackerStatsBar) {
                    trackerStatsBar.style.display = 'none';
                }
                
                // Update shot tracker stats bar (for training database)
                const trainingDbStatsBar = document.getElementById('trainingDbShotTrackerStats');
                if (trainingDbStatsBar && intervalShotTrackerSessions.length > 0) {
                    trainingDbStatsBar.style.display = 'block';
                    document.getElementById('trainingDbTotalMakes').textContent = intervalMakes;
                    document.getElementById('trainingDbTotalAttempts').textContent = intervalAttempts;
                    document.getElementById('trainingDbShotPercentage').textContent = intervalPercentage + '%';
                } else if (trainingDbStatsBar) {
                    trainingDbStatsBar.style.display = 'none';
                }
                
                // Draw each shot using the same mapping as shot tracker (EXACT COPY from drawHeatmap)
                const courtX = heatmapCanvas.width * 0.05;
                const courtY = heatmapCanvas.height * 0.1;
                const courtWidth = heatmapCanvas.width * 0.9;
                const courtHeight = heatmapCanvas.height * 0.85;
                
                filteredShots.forEach(shot => {
                    // EXACT COPY from shot tracker drawHeatmap function
                    // X coordinate: 0 = left edge of court, 1 = right edge of court
                    const x = courtX + (shot.x * courtWidth);
                    
                    // Y coordinate: Map to court height (0 = top/hoop, 1 = bottom/3pt)
                    const y = courtY + (shot.y * courtHeight);
                    
                    // Draw shot marker
                    if (shot.is_make || shot.result === 'make') {
                        // Green circle for makes
                        ctx.fillStyle = 'rgba(0, 255, 0, 0.8)';
                        ctx.strokeStyle = 'rgba(0, 200, 0, 1)';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(x, y, 12, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.stroke();
                    } else {
                        // Red X for misses
                        ctx.strokeStyle = 'rgba(255, 0, 0, 1)';
                        ctx.lineWidth = 3;
                        const size = 10;
                        ctx.beginPath();
                        ctx.moveTo(x - size, y - size);
                        ctx.lineTo(x + size, y + size);
                        ctx.moveTo(x + size, y - size);
                        ctx.lineTo(x - size, y + size);
                        ctx.stroke();
                    }
                });
                
                
            } catch (error) {
                console.error('Error loading heatmap:', error);
                const ctx = heatmapCanvas.getContext('2d');
                ctx.fillStyle = '#999';
                ctx.font = '14px "Courier Prime", monospace';
                ctx.textAlign = 'center';
                ctx.fillText('Error loading heatmap data', heatmapCanvas.width / 2, heatmapCanvas.height / 2);
            }
        }
        
        async function loadBadges() {
            const user = window.firebaseAuth?.currentUser;
            if (!user) {
                document.getElementById('badgesContainer').innerHTML = '<p style="text-align: center; padding: 40px;">Please sign in to view your badges.</p>';
                return;
            }
            
            // Check all badges first
            if (window.checkAllBadges) {
                await window.checkAllBadges(user.uid);
            }
            
            const badges = await window.getUserBadges(user.uid);
            const loginStreak = await window.updateLoginStreak(user.uid);
            
            // Get training data for calculations
            const scores = await window.getTrainingScores(user.uid);
            const totalSessions = scores.length;
            const scoreValues = scores.map(s => s.similarityScore);
            const maxSimilarity = scoreValues.length > 0 ? Math.max(...scoreValues) : 0;
            const avgScore = scoreValues.length > 0 ? scoreValues.reduce((a, b) => a + b, 0) / scoreValues.length : 0;
            
            // Group by player
            const playerScores = {};
            scores.forEach(score => {
                const player = score.player || 'custom';
                if (!playerScores[player]) playerScores[player] = [];
                playerScores[player].push(score);
            });
            const uniquePlayers = Object.keys(playerScores);
            const playersWithHighScores = uniquePlayers.filter(player => {
                const playerMax = Math.max(...playerScores[player].map(s => s.similarityScore));
                return playerMax >= 85;
            });
            
            // Calculate consecutive days
            const sessionDates = scores.map(s => {
                const date = s.createdAt?.toDate ? s.createdAt.toDate() : new Date();
                return date.toDateString();
            });
            const uniqueDates = [...new Set(sessionDates)];
            uniqueDates.sort((a, b) => new Date(a) - new Date(b));
            let maxConsecutive = 1;
            let consecutiveDays = 1;
            for (let i = 1; i < uniqueDates.length; i++) {
                const prevDate = new Date(uniqueDates[i - 1]);
                const currDate = new Date(uniqueDates[i]);
                const daysDiff = (currDate - prevDate) / (1000 * 60 * 60 * 24);
                if (daysDiff === 1) {
                    consecutiveDays++;
                    maxConsecutive = Math.max(maxConsecutive, consecutiveDays);
                } else {
                    consecutiveDays = 1;
                }
            }
            
            // Calculate improvements
            const recentScores = scoreValues.slice(0, 5);
            const olderScores = scoreValues.slice(5, 10);
            const recentAvg = recentScores.length > 0 ? recentScores.reduce((a, b) => a + b, 0) / recentScores.length : 0;
            const olderAvg = olderScores.length > 0 ? olderScores.reduce((a, b) => a + b, 0) / olderScores.length : 0;
            const improvement = recentAvg > 0 && olderAvg > 0 ? recentAvg - olderAvg : 0;
            
            // Player-specific stats
            const playerStats = {};
            ['curry', 'lebron', 'jordan', 'durant', 'clark'].forEach(player => {
                if (playerScores[player]) {
                    playerStats[player] = {
                        sessions: playerScores[player].length,
                        maxScore: Math.max(...playerScores[player].map(s => s.similarityScore))
                    };
                }
            });
            
            // Display all badges
            const badgeDefinitions = [
                {
                    id: 'loginStreak',
                    name: 'Consistency Champion',
                    description: 'Log in consecutive days',
                    icon: '',
                    levels: [
                        { level: 'bronze', requirement: '5 days', current: loginStreak + ' days' },
                        { level: 'silver', requirement: '10 days', current: loginStreak + ' days' },
                        { level: 'gold', requirement: '30 days', current: loginStreak + ' days' }
                    ]
                },
                {
                    id: 'similarity',
                    name: 'Form Master',
                    description: 'Achieve high similarity scores',
                    icon: '',
                    levels: [
                        { level: 'bronze', requirement: '80%', current: maxSimilarity.toFixed(1) + '%' },
                        { level: 'silver', requirement: '90%', current: maxSimilarity.toFixed(1) + '%' },
                        { level: 'gold', requirement: '95%', current: maxSimilarity.toFixed(1) + '%' }
                    ]
                },
                {
                    id: 'practiceWarrior',
                    name: 'Practice Warrior',
                    description: 'Complete training sessions',
                    icon: '',
                    levels: [
                        { level: 'bronze', requirement: '10 sessions', current: totalSessions + ' sessions' },
                        { level: 'silver', requirement: '50 sessions', current: totalSessions + ' sessions' },
                        { level: 'gold', requirement: '100 sessions', current: totalSessions + ' sessions' }
                    ]
                },
                {
                    id: 'firstSteps',
                    name: 'First Steps',
                    description: 'Complete your first analysis',
                    icon: '',
                    levels: [
                        { level: 'bronze', requirement: '1 session', current: totalSessions + ' sessions' },
                        { level: 'silver', requirement: '5 sessions', current: totalSessions + ' sessions' },
                        { level: 'gold', requirement: '10 sessions', current: totalSessions + ' sessions' }
                    ]
                },
                {
                    id: 'halfCentury',
                    name: 'Milestone Master',
                    description: 'Reach session milestones',
                    icon: '',
                    levels: [
                        { level: 'bronze', requirement: '50 sessions', current: totalSessions + ' sessions' },
                        { level: 'silver', requirement: '100 sessions', current: totalSessions + ' sessions' },
                        { level: 'gold', requirement: '300 sessions', current: totalSessions + ' sessions' }
                    ]
                },
                {
                    id: 'risingStar',
                    name: 'Rising Star',
                    description: 'Improve your scores over time',
                    icon: '',
                    levels: [
                        { level: 'bronze', requirement: '10% improvement', current: improvement.toFixed(1) + '%' },
                        { level: 'silver', requirement: '20% improvement', current: improvement.toFixed(1) + '%' },
                        { level: 'gold', requirement: '30% improvement', current: improvement.toFixed(1) + '%' }
                    ]
                },
                {
                    id: 'fastTrack',
                    name: 'Fast Track',
                    description: 'Rapid improvement in sessions',
                    icon: '',
                    levels: [
                        { level: 'bronze', requirement: '15% in 3 sessions', current: improvement.toFixed(1) + '%' },
                        { level: 'silver', requirement: '20% in 5 sessions', current: improvement.toFixed(1) + '%' },
                        { level: 'gold', requirement: '25% in 7 sessions', current: improvement.toFixed(1) + '%' }
                    ]
                },
                {
                    id: 'breakthrough',
                    name: 'Breakthrough',
                    description: 'Achieve new personal bests',
                    icon: '',
                    levels: [
                        { level: 'bronze', requirement: '1 new PB', current: maxSimilarity.toFixed(1) + '%' },
                        { level: 'silver', requirement: '3 new PBs', current: maxSimilarity.toFixed(1) + '%' },
                        { level: 'gold', requirement: '5 new PBs', current: maxSimilarity.toFixed(1) + '%' }
                    ]
                },
                {
                    id: 'versatileShooter',
                    name: 'Versatile Shooter',
                    description: 'Master multiple players',
                    icon: '',
                    levels: [
                        { level: 'bronze', requirement: '3 players at 85%+', current: playersWithHighScores.length + ' players' },
                        { level: 'silver', requirement: '4 players at 85%+', current: playersWithHighScores.length + ' players' },
                        { level: 'gold', requirement: '5 players at 85%+', current: playersWithHighScores.length + ' players' }
                    ]
                },
                {
                    id: 'steadyHand',
                    name: 'Steady Hand',
                    description: 'Maintain consistent high scores',
                    icon: '',
                    levels: [
                        { level: 'bronze', requirement: '80%+ avg (10 sessions)', current: avgScore.toFixed(1) + '% avg' },
                        { level: 'silver', requirement: '90%+ avg (20 sessions)', current: avgScore.toFixed(1) + '% avg' },
                        { level: 'gold', requirement: '95%+ avg (30 sessions)', current: avgScore.toFixed(1) + '% avg' }
                    ]
                },
                {
                    id: 'rockSolid',
                    name: 'Rock Solid',
                    description: 'Consecutive sessions at 85%+',
                    icon: '',
                    levels: [
                        { level: 'bronze', requirement: '5x 85%+', current: recentScores.length >= 5 ? recentScores.every(s => s >= 85) ? 'Achieved!' : 'In progress' : 'Need 5 sessions' },
                        { level: 'silver', requirement: '10x 85%+', current: scoreValues.length >= 10 ? scoreValues.slice(0, 10).every(s => s >= 85) ? 'Achieved!' : 'In progress' : 'Need 10 sessions' },
                        { level: 'gold', requirement: '15x 85%+', current: scoreValues.length >= 15 ? scoreValues.slice(0, 15).every(s => s >= 85) ? 'Achieved!' : 'In progress' : 'Need 15 sessions' }
                    ]
                },
                {
                    id: 'nearPerfect',
                    name: 'Near Perfect',
                    description: 'Achieve near-perfect scores',
                    icon: '',
                    levels: [
                        { level: 'bronze', requirement: '95%', current: maxSimilarity.toFixed(1) + '%' },
                        { level: 'silver', requirement: '98%', current: maxSimilarity.toFixed(1) + '%' },
                        { level: 'gold', requirement: '100%', current: maxSimilarity.toFixed(1) + '%' }
                    ]
                },
                {
                    id: 'perfectionist',
                    name: 'Perfectionist',
                    description: 'Achieve perfect form',
                    icon: '',
                    levels: [
                        { level: 'bronze', requirement: '98%', current: maxSimilarity.toFixed(1) + '%' },
                        { level: 'silver', requirement: '100%', current: maxSimilarity.toFixed(1) + '%' },
                        { level: 'gold', requirement: '100% multiple times', current: maxSimilarity.toFixed(1) + '%' }
                    ]
                },
                {
                    id: 'weekWarrior',
                    name: 'Week Warrior',
                    description: 'Practice consecutive days',
                    icon: '',
                    levels: [
                        { level: 'bronze', requirement: '7 days', current: maxConsecutive + ' days' },
                        { level: 'silver', requirement: '30 days', current: maxConsecutive + ' days' },
                        { level: 'gold', requirement: '365 days', current: maxConsecutive + ' days' }
                    ]
                },
                {
                    id: 'dailyGrinder',
                    name: 'Daily Grinder',
                    description: 'Consecutive days with sessions',
                    icon: '',
                    levels: [
                        { level: 'bronze', requirement: '3 days', current: maxConsecutive + ' days' },
                        { level: 'silver', requirement: '7 days', current: maxConsecutive + ' days' },
                        { level: 'gold', requirement: '14 days', current: maxConsecutive + ' days' }
                    ]
                },
                {
                    id: 'explorer',
                    name: 'Explorer',
                    description: 'Try all pro players',
                    icon: '',
                    levels: [
                        { level: 'bronze', requirement: '5 players', current: uniquePlayers.length + ' players' },
                        { level: 'silver', requirement: '5 players + custom', current: uniquePlayers.length + ' players' },
                        { level: 'gold', requirement: 'All players mastered', current: playersWithHighScores.length + ' mastered' }
                    ]
                },
                {
                    id: 'adventurer',
                    name: 'Adventurer',
                    description: 'Try custom benchmarks',
                    icon: '',
                    levels: [
                        { level: 'bronze', requirement: '1 custom session', current: playerScores['custom'] ? playerScores['custom'].length + ' sessions' : 'Not yet' },
                        { level: 'silver', requirement: '5 custom sessions', current: playerScores['custom'] ? playerScores['custom'].length + ' sessions' : 'Not yet' },
                        { level: 'gold', requirement: '10 custom sessions', current: playerScores['custom'] ? playerScores['custom'].length + ' sessions' : 'Not yet' }
                    ]
                },
                {
                    id: 'completeCollection',
                    name: 'Complete Collection',
                    description: 'Master all players (85%+)',
                    icon: '',
                    levels: [
                        { level: 'bronze', requirement: 'All 5 players', current: playersWithHighScores.length + '/5 players' },
                        { level: 'silver', requirement: 'All 5 at 90%+', current: uniquePlayers.filter(p => {
                            const playerMax = Math.max(...playerScores[p].map(s => s.similarityScore));
                            return playerMax >= 90;
                        }).length + '/5 players' },
                        { level: 'gold', requirement: 'All 5 at 95%+', current: uniquePlayers.filter(p => {
                            const playerMax = Math.max(...playerScores[p].map(s => s.similarityScore));
                            return playerMax >= 95;
                        }).length + '/5 players' }
                    ]
                },
                {
                    id: 'quickLearner',
                    name: 'Quick Learner',
                    description: 'Reach high scores quickly',
                    icon: '',
                    levels: [
                        { level: 'bronze', requirement: '80%+ in 5 sessions', current: totalSessions <= 5 && maxSimilarity >= 80 ? 'Achieved!' : totalSessions > 5 ? 'Time passed' : 'In progress' },
                        { level: 'silver', requirement: '85%+ in 5 sessions', current: totalSessions <= 5 && maxSimilarity >= 85 ? 'Achieved!' : totalSessions > 5 ? 'Time passed' : 'In progress' },
                        { level: 'gold', requirement: '90%+ in 5 sessions', current: totalSessions <= 5 && maxSimilarity >= 90 ? 'Achieved!' : totalSessions > 5 ? 'Time passed' : 'In progress' }
                    ]
                },
                {
                    id: 'rapidRise',
                    name: 'Rapid Rise',
                    description: 'Dramatic improvement in 10 sessions',
                    icon: '',
                    levels: [
                        { level: 'bronze', requirement: '<60% to >85%', current: scoreValues.length >= 10 ? (scoreValues.slice(-10, -5).reduce((a, b) => a + b, 0) / 5 < 60 && recentAvg >= 85 ? 'Achieved!' : 'In progress') : 'Need 10 sessions' },
                        { level: 'silver', requirement: '<60% to >90%', current: scoreValues.length >= 10 ? (scoreValues.slice(-10, -5).reduce((a, b) => a + b, 0) / 5 < 60 && recentAvg >= 90 ? 'Achieved!' : 'In progress') : 'Need 10 sessions' },
                        { level: 'gold', requirement: '<60% to >95%', current: scoreValues.length >= 10 ? (scoreValues.slice(-10, -5).reduce((a, b) => a + b, 0) / 5 < 60 && recentAvg >= 95 ? 'Achieved!' : 'In progress') : 'Need 10 sessions' }
                    ]
                }
            ];
            
            // Player icon mapping
            const playerIcons = {
                'curry': '/tool/stephrootsicon.jpeg',
                'lebron': '/tool/lebron_icon.jpeg',
                'jordan': '/tool/jordan_icon.jpeg',
                'durant': '/tool/kd_icon.webp',
                'clark': '/tool/caitlin_icon.webp'
            };
            
            // Add player-specific badges
            ['curry', 'lebron', 'jordan', 'durant', 'clark'].forEach(player => {
                const playerName = player.charAt(0).toUpperCase() + player.slice(1);
                const stats = playerStats[player];
                if (stats) {
                    badgeDefinitions.push({
                        id: player + 'Specialist',
                        name: playerName + ' Specialist',
                        description: `Master ${playerName}'s form`,
                        icon: '',
                        playerIcon: playerIcons[player], // Store player icon path
                        levels: [
                            { level: 'bronze', requirement: '5 sessions at 85%+', current: stats.sessions + ' sessions, ' + stats.maxScore.toFixed(1) + '% max' },
                            { level: 'silver', requirement: '10 sessions at 90%+', current: stats.sessions + ' sessions, ' + stats.maxScore.toFixed(1) + '% max' },
                            { level: 'gold', requirement: '15 sessions at 95%+', current: stats.sessions + ' sessions, ' + stats.maxScore.toFixed(1) + '% max' }
                        ]
                    });
                } else {
                    badgeDefinitions.push({
                        id: player + 'Specialist',
                        name: playerName + ' Specialist',
                        description: `Master ${playerName}'s form`,
                        icon: '',
                        playerIcon: playerIcons[player], // Store player icon path
                        levels: [
                            { level: 'bronze', requirement: '5 sessions at 85%+', current: 'Not started' },
                            { level: 'silver', requirement: '10 sessions at 90%+', current: 'Not started' },
                            { level: 'gold', requirement: '15 sessions at 95%+', current: 'Not started' }
                        ]
                    });
                }
            });
            
            let badgesHTML = '';
            badgeDefinitions.forEach(badge => {
                const currentLevel = badges[badge.id] || 'none';
                const isUnlocked = currentLevel !== 'none';
                
                // Use player icon for specialist badges, otherwise use emoji icon
                const iconHTML = badge.playerIcon 
                    ? `<img src="${badge.playerIcon}" alt="${badge.name}" style="width: 64px; height: 64px; border-radius: 50%; object-fit: cover; margin: 0 auto;">`
                    : `<div class="badge-icon">${badge.icon}</div>`;
                
                badgesHTML += `
                    <div class="badge-card ${!isUnlocked ? 'locked' : ''}">
                        ${iconHTML}
                        <div class="badge-name">${badge.name}</div>
                        <div style="color: #666; margin-bottom: 15px; font-size: 14px;">${badge.description}</div>
                        ${badge.levels.map(levelInfo => {
                            const isAchieved = currentLevel === levelInfo.level || 
                                (levelInfo.level === 'bronze' && currentLevel !== 'none') ||
                                (levelInfo.level === 'silver' && (currentLevel === 'silver' || currentLevel === 'gold')) ||
                                (levelInfo.level === 'gold' && currentLevel === 'gold');
                            
                            return `
                                <div style="margin: 10px 0; padding: 10px; background: ${isAchieved ? '#f0f9ff' : '#f5f5f5'}; border-radius: 8px;">
                                    <div style="display: flex; justify-content: space-between; align-items: center;">
                                        <span style="font-weight: 600;">${levelInfo.level.charAt(0).toUpperCase() + levelInfo.level.slice(1)}</span>
                                        <span class="badge-level ${isAchieved ? levelInfo.level : 'none'}">
                                            ${isAchieved ? '' : ''} ${levelInfo.requirement}
                                        </span>
                                    </div>
                                    <div style="font-size: 12px; color: #666; margin-top: 5px;">
                                        Current: ${levelInfo.current}
                                    </div>
                                </div>
                            `;
                        }).join('')}
                    </div>
                `;
            });
            
            document.getElementById('badgesContainer').innerHTML = badgesHTML;
        }
        
        // Add event listener for player filter
        // Restore active tab from localStorage on page load
        function restoreActiveTab() {
            // Only restore tab if we're on the tool page (not the landing page)
            const pathname = window.location.pathname;
            if (!pathname.includes('/tool/') && !pathname.endsWith('/tool/index.html')) {
                return; // Don't restore tab if we're not on the tool page
            }
            
            const activeTab = localStorage.getItem('activeTab');
            // Removed shotTracker tab - functionality moved to Shot Sync tab
            if (activeTab) {
                switch(activeTab) {
                    case 'shotSync':
                        showShotSync();
                        break;
                    case 'trainingDatabase':
                        showTrainingDatabase();
                        break;
                    case 'progressPics':
                        showProgressPics();
                        break;
                    case 'badges':
                        showBadges();
                        break;
                    case 'nutrition':
                        showNutrition();
                        break;
                    case 'workouts':
                        showWorkouts();
                        break;
                    default:
                        showShotSync();
                }
            } else {
                // Default to shot sync if no saved tab
                showShotSync();
            }
            
            // Re-attach sign-in button handlers after tab restoration
            // This ensures handlers work even if buttons were hidden/shown during tab switch
            setTimeout(() => {
                // Check if handlers are available (from app.js)
                if (typeof handleGoogleSignIn !== 'undefined' && window.signInWithGoogle) {
                    const googleSignInBtn = document.getElementById('googleSignInBtn');
                    if (googleSignInBtn) {
                        // Clone to remove old listeners and re-add
                        const newBtn = googleSignInBtn.cloneNode(true);
                        googleSignInBtn.parentNode.replaceChild(newBtn, googleSignInBtn);
                        newBtn.addEventListener('click', handleGoogleSignIn);
                    }
                }
                
                if (typeof handlePlayerPageSignIn !== 'undefined' && window.signInWithGoogle) {
                    const playerGoogleSignInBtn = document.getElementById('playerGoogleSignInBtn');
                    if (playerGoogleSignInBtn) {
                        // Clone to remove old listeners and re-add
                        const newBtn = playerGoogleSignInBtn.cloneNode(true);
                        playerGoogleSignInBtn.parentNode.replaceChild(newBtn, playerGoogleSignInBtn);
                        newBtn.addEventListener('click', handlePlayerPageSignIn);
                    }
                }
            }, 500);
        }
        
        document.addEventListener('DOMContentLoaded', () => {
            const playerFilter = document.getElementById('playerFilter');
            if (playerFilter) {
                playerFilter.addEventListener('change', loadTrainingDatabase);
            }
            
            // Add click handler for Home button
            const homeButton = document.getElementById('backToHomeTab');
            if (homeButton) {
                homeButton.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    goToHome();
                });
            }
            
            // Restore active tab after a delay to ensure all scripts (including app.js) are loaded
            // Wait for app.js to attach handlers first, then restore tab
            setTimeout(() => {
                restoreActiveTab();
            }, 300);
        });
        
        function goToHome() {
            console.log('goToHome called');
            // Clear the activeTab from localStorage so it doesn't restore a tab when returning
            localStorage.removeItem('activeTab');
            
            // Navigate to the root index.html (landing page) - go up one directory from /tool/
            // Use replace instead of href to prevent back button from going back to tool page
            const baseUrl = window.location.origin;
            const pathParts = window.location.pathname.split('/').filter(p => p); // Remove empty strings
            const toolIndex = pathParts.indexOf('tool');
            console.log('pathParts:', pathParts, 'toolIndex:', toolIndex);
            
            if (toolIndex > 0) {
                const basePath = '/' + pathParts.slice(0, toolIndex).join('/');
                const targetUrl = baseUrl + basePath + '/index.html';
                console.log('Navigating to:', targetUrl);
                window.location.replace(targetUrl);
            } else {
                console.log('Using relative path: ../index.html');
                window.location.replace('../index.html');
            }
        }
        
        function showWorkouts() {
            // Hide all views
            document.querySelectorAll('.tab-view').forEach(view => view.style.display = 'none');
            const mainContent = document.querySelector('.main-content');
            if (mainContent) mainContent.style.display = 'none';
            
            // Hide ShotSync header/tagline on workouts page (but keep logo)
            const header = document.querySelector('header');
            if (header) header.style.display = 'none';
            
            // Show workouts
            document.getElementById('workoutsView').style.display = 'block';
            
            // Update nav tabs
            document.querySelectorAll('.nav-tab').forEach(tab => tab.classList.remove('active'));
            document.getElementById('workoutsTab').classList.add('active');
            
            // Save active tab to localStorage
            localStorage.setItem('activeTab', 'workouts');
            
            // Load workouts data
            loadWorkouts();
        }
        
        function showNutrition() {
            // Hide all views
            document.querySelectorAll('.tab-view').forEach(view => view.style.display = 'none');
            const mainContent = document.querySelector('.main-content');
            if (mainContent) mainContent.style.display = 'none';
            
            // Hide ShotSync header/tagline on nutrition page (but keep logo)
            const header = document.querySelector('header');
            if (header) header.style.display = 'none';
            
            // Show nutrition
            document.getElementById('nutritionView').style.display = 'block';
            
            // Update nav tabs
            document.querySelectorAll('.nav-tab').forEach(tab => tab.classList.remove('active'));
            document.getElementById('nutritionTab').classList.add('active');
            
            // Save active tab to localStorage
            localStorage.setItem('activeTab', 'nutrition');
            
            // Load nutrition data
            loadNutrition();
            
            // Make sure Custom Diet Plans tab shows correctly if it was previously selected
            const customDietPlansSection = document.getElementById('customDietPlansSection');
            if (customDietPlansSection && customDietPlansSection.style.display !== 'none') {
                const user = window.firebaseAuth?.currentUser;
                if (user) {
                    loadCustomDietPlans(user.uid);
                }
            }
        }
        
        // Wait for Firebase to be ready
        async function waitForFirebase(maxWait = 5000) {
            const startTime = Date.now();
            while (!window.signInWithGoogle && (Date.now() - startTime) < maxWait) {
                await new Promise(resolve => setTimeout(resolve, 100));
            }
            return !!window.signInWithGoogle;
        }
        
        // Wrapper functions for sign-in buttons (call handlers from app.js)
        async function handleGoogleSignInClick() {
            // Wait for Firebase to be ready
            const firebaseReady = await waitForFirebase();
            if (!firebaseReady) {
                alert('Sign-in is not ready yet. Please wait a moment and try again, or refresh the page.');
                return;
            }
            
            if (typeof handleGoogleSignIn !== 'undefined') {
                try {
                    await handleGoogleSignIn();
                } catch (error) {
                    console.error('Sign-in error:', error);
                    // The handler should show its own error, but if it doesn't, show a generic one
                }
            } else {
                // Fallback: try to sign in directly and update UI
                if (window.signInWithGoogle) {
                    try {
                        console.log('Attempting Google sign-in...');
                        const userData = await window.signInWithGoogle();
                        console.log('Sign-in successful, user data:', userData);
                        
                        // Wait a moment for auth state to update
                        await new Promise(resolve => setTimeout(resolve, 300));
                        
                        // Check if user is actually signed in
                        const currentUser = window.firebaseAuth?.currentUser;
                        console.log('Current user after sign-in:', currentUser);
                        
                        if (currentUser) {
                            console.log('User is signed in, updating UI...');
                            
                            // Update UI directly instead of reloading
                            const signInSection = document.getElementById('signInSection');
                            if (signInSection) {
                                signInSection.style.display = 'none';
                            }
                            
                            const playerSelectionContainer = document.getElementById('playerSelectionContainer');
                            if (playerSelectionContainer) {
                                playerSelectionContainer.style.opacity = '1';
                                playerSelectionContainer.style.pointerEvents = 'auto';
                            }
                            
                            // Move to record shot step (skip player selection)
                            const step0 = document.getElementById('step0');
                            const step2 = document.getElementById('step2');
                            if (step0) {
                                step0.classList.remove('active');
                                step0.style.display = 'none';
                            }
                            if (step2) {
                                step2.classList.add('active');
                                step2.style.display = 'block';
                            }
                            
                            // Save user email
                            if (window.saveUserEmail) {
                                await window.saveUserEmail(userData.email, userData.firstName, userData.lastName);
                            }
                            
                            console.log('UI updated successfully');
                        } else {
                            console.error('User is not signed in after sign-in attempt');
                            alert('Sign-in completed but authentication state was not updated. Please refresh the page manually.');
                        }
                    } catch (error) {
                        console.error('Error signing in:', error);
                        let errorMessage = 'Failed to sign in with Google. ';
                        if (error.code === 'auth/popup-closed-by-user') {
                            errorMessage = 'Sign-in was cancelled. Please try again.';
                        } else if (error.code) {
                            errorMessage += `Error code: ${error.code}. `;
                        }
                        if (error.message) {
                            errorMessage += error.message;
                        } else {
                            errorMessage += 'Please check the browser console for details.';
                        }
                        alert(errorMessage);
                    }
                } else {
                    alert('Sign-in functionality is not available. Please refresh the page.');
                }
            }
        }
        
        async function handlePlayerPageSignInClick() {
            // Wait for Firebase to be ready
            const firebaseReady = await waitForFirebase();
            if (!firebaseReady) {
                alert('Sign-in is not ready yet. Please wait a moment and try again, or refresh the page.');
                return;
            }
            
            if (typeof handlePlayerPageSignIn !== 'undefined') {
                try {
                    await handlePlayerPageSignIn();
                } catch (error) {
                    console.error('Sign-in error:', error);
                    // The handler should show its own error, but if it doesn't, show a generic one
                }
            } else {
                // Fallback: try to sign in directly and update UI
                if (window.signInWithGoogle) {
                    try {
                        console.log('Attempting Google sign-in (player page)...');
                        const userData = await window.signInWithGoogle();
                        console.log('Sign-in successful, user data:', userData);
                        
                        // Wait a moment for auth state to update
                        await new Promise(resolve => setTimeout(resolve, 300));
                        
                        // Check if user is actually signed in
                        const currentUser = window.firebaseAuth?.currentUser;
                        console.log('Current user after sign-in:', currentUser);
                        
                        if (currentUser) {
                            console.log('User is signed in, updating UI...');
                            
                            // Update UI directly instead of reloading
                            const playerSelectionContainer = document.getElementById('playerSelectionContainer');
                            if (playerSelectionContainer) {
                                playerSelectionContainer.style.opacity = '1';
                                playerSelectionContainer.style.pointerEvents = 'auto';
                            }
                            
                            const playerSignInSection = document.getElementById('playerSignInSection');
                            if (playerSignInSection) {
                                playerSignInSection.style.display = 'none';
                            }
                            
                            // Save user email
                            if (window.saveUserEmail) {
                                await window.saveUserEmail(userData.email, userData.firstName, userData.lastName);
                            }
                            
                            console.log('UI updated successfully');
                        } else {
                            console.error('User is not signed in after sign-in attempt');
                            alert('Sign-in completed but authentication state was not updated. Please refresh the page manually.');
                        }
                    } catch (error) {
                        console.error('Error signing in:', error);
                        let errorMessage = 'Failed to sign in with Google. ';
                        if (error.code === 'auth/popup-closed-by-user') {
                            errorMessage = 'Sign-in was cancelled. Please try again.';
                        } else if (error.code) {
                            errorMessage += `Error code: ${error.code}. `;
                        }
                        if (error.message) {
                            errorMessage += error.message;
                        } else {
                            errorMessage += 'Please check the browser console for details.';
                        }
                        alert(errorMessage);
                    }
                } else {
                    alert('Sign-in functionality is not available. Please refresh the page.');
                }
            }
        }
        
        // Make functions globally available
        window.showShotSync = showShotSync;
        window.showTrainingDatabase = showTrainingDatabase;
        window.showProgressPics = showProgressPics;
        window.showBadges = showBadges;
        window.showNutrition = showNutrition;
        
        // ====================== SHOT TRACKER FUNCTIONALITY ======================
        
        let shotTrackerStream = null;
        let shotTrackerCamera = null;
        let shotTrackerActive = false;
        let shotTrackerStats = {
            total: 0,
            makes: 0,
            misses: 0
        };
        let shotHistory = [];
        let shotTrackerRenderLoopId = null;
        let shotTrackerMode = 'live'; // 'live' or 'upload'
        let uploadedVideoFile = null;
        let videoAnalysisActive = false;
        let videoAnalysisPaused = false;
        
        // Client-side detection state
        let clientSideTrackerState = {
            ballPositions: [],
            rimPosition: null,
            rimRadius: null,
            lastShotTime: 0,
            useBackend: false // Will be set based on backend availability
        };
        
        function showShotTracker() {
            // Hide all tab views
            document.querySelectorAll('.tab-view').forEach(view => view.style.display = 'none');
            
            // Hide all steps
            document.querySelectorAll('.step').forEach(step => step.style.display = 'none');
            
            // Show shot tracker section
            const shotTrackerSection = document.getElementById('shotTrackerSection');
            if (shotTrackerSection) {
                shotTrackerSection.style.display = 'block';
            }
            
            // Ensure main content is visible
            const mainContent = document.querySelector('.main-content');
            if (mainContent) mainContent.style.display = 'block';
            
            // Setup event listeners for shot tracker (in case they weren't set up yet)
            setupShotTrackerEventListeners();
            
            // Start polling stats (EXACT COPY from original)
            startStatsPolling();
        }
        
        function setupShotTrackerEventListeners() {
            // EXACT COPY from original shot_detector_web_simple.py HTML template
            const fileInput = document.getElementById('shotTrackerFileInput');
            const uploadForm = document.getElementById('shotTrackerUploadForm');
            
            // File input handler - show filename
            if (fileInput) {
                fileInput.addEventListener('change', function(e) {
                    const fileName = e.target.files[0] ? e.target.files[0].name : '';
                    document.getElementById('uploadedFileName').textContent = fileName ? 'Selected: ' + fileName : '';
                });
            }
            
            // Upload form handler - EXACT COPY from original
            if (uploadForm) {
                uploadForm.addEventListener('submit', function(e) {
                    e.preventDefault();
                    const formData = new FormData();
                    const fileInput = document.getElementById('shotTrackerFileInput');
                    
                    if (!fileInput.files[0]) {
                        showMessage('Please select a video file', 'error');
                        return;
                    }
                    
                    formData.append('video', fileInput.files[0]);
                    const uploadBtn = document.getElementById('uploadBtn');
                    uploadBtn.disabled = true;
                    uploadBtn.textContent = 'Uploading...';
                    
                    fetch('/api/upload', {
                        method: 'POST',
                        body: formData
                    })
                    .then(response => response.json())
                    .then(data => {
                        if (data.success) {
                            showMessage('Video uploaded successfully! Processing...', 'success');
                            setTimeout(() => {
                                const videoStream = document.getElementById('shotTrackerVideoStream');
                                videoStream.src = '/api/video_feed?t=' + new Date().getTime();
                            }, 1000);
                        } else {
                            showMessage(data.message || 'Upload failed', 'error');
                        }
                    })
                    .catch(error => {
                        showMessage('Error uploading video: ' + error.message, 'error');
                    })
                    .finally(() => {
                        uploadBtn.disabled = false;
                        uploadBtn.textContent = 'Upload & Analyze Video';
                    });
                });
            }
            
            // Reset button
            const resetBtn = document.getElementById('resetShotTracker');
            if (resetBtn) {
                resetBtn.addEventListener('click', function() {
                    fetch('/api/reset_shot_tracker', { method: 'POST' })
                        .then(() => {
                            // Reload stats
                            fetch('/api/stats')
                                .then(response => response.json())
                                .then(data => updateStats(data));
                        });
                });
            }
            
            // Save to Training Database button
            const saveBtn = document.getElementById('saveToTrainingDbBtn');
            console.log('Setting up save button:', saveBtn);
            if (saveBtn) {
                saveBtn.addEventListener('click', async function(e) {
                    e.preventDefault();
                    console.log('Save button clicked!');
                    try {
                        await saveShotTrackerToTrainingDb();
                    } catch (error) {
                        console.error('Error in save button handler:', error);
                        showPopup('Error: ' + error.message, 'error');
                    }
                });
                console.log('Save button event listener added');
            } else {
                console.error('Save button not found!');
            }
            
            // Back button
            const backBtn = document.getElementById('backToShotSyncFromTracker');
            if (backBtn) {
                backBtn.addEventListener('click', function() {
                    // Hide shot tracker section
                    document.getElementById('shotTrackerSection').style.display = 'none';
                    // Show first step
                    document.querySelector('.step').style.display = 'block';
                });
            }
        }
        
        // Popup notification function
        function showPopup(message, type = 'success') {
            console.log('showPopup called with:', message, type);
            
            // Remove existing popup if any
            const existingPopup = document.getElementById('savePopup');
            if (existingPopup) {
                existingPopup.remove();
            }
            
            // Create popup element
            const popup = document.createElement('div');
            popup.id = 'savePopup';
            popup.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: ${type === 'success' ? 'linear-gradient(135deg, #4ade80 0%, #22c55e 100%)' : 'linear-gradient(135deg, #ef4444 0%, #dc2626 100%)'};
                color: white;
                padding: 30px 50px;
                border-radius: 15px;
                box-shadow: 0 10px 40px rgba(0,0,0,0.3);
                z-index: 10000;
                font-size: 24px;
                font-weight: 700;
                font-family: 'Bebas Neue', sans-serif;
                text-align: center;
                animation: popupFadeIn 0.3s ease-out;
            `;
            popup.textContent = message;
            
            console.log('Popup element created, appending to body');
            
            // Add animation
            const style = document.createElement('style');
            style.textContent = `
                @keyframes popupFadeIn {
                    from {
                        opacity: 0;
                        transform: translate(-50%, -50%) scale(0.8);
                    }
                    to {
                        opacity: 1;
                        transform: translate(-50%, -50%) scale(1);
                    }
                }
                @keyframes popupFadeOut {
                    from {
                        opacity: 1;
                        transform: translate(-50%, -50%) scale(1);
                    }
                    to {
                        opacity: 0;
                        transform: translate(-50%, -50%) scale(0.8);
                    }
                }
            `;
            if (!document.getElementById('popupStyles')) {
                style.id = 'popupStyles';
                document.head.appendChild(style);
            }
            
            document.body.appendChild(popup);
            console.log('Popup appended to body');
            
            // Remove after 2 seconds
            setTimeout(() => {
                if (popup && popup.parentNode) {
                    popup.style.animation = 'popupFadeOut 0.3s ease-out';
                    setTimeout(() => {
                        if (popup && popup.parentNode) {
                            popup.remove();
                        }
                    }, 300);
                }
            }, 2000);
        }
        
        async function saveShotTrackerToTrainingDb() {
            console.log('saveShotTrackerToTrainingDb called');
            
            const user = window.firebaseAuth?.currentUser;
            console.log('Current user:', user);
            if (!user) {
                console.log('No user, showing sign in message');
                showPopup('Please sign in to save', 'error');
                return;
            }
            
            const saveBtn = document.getElementById('saveToTrainingDbBtn');
            const messageDiv = document.getElementById('saveTrainingDbMessage');
            
            if (!saveBtn) {
                console.error('Save button not found in saveShotTrackerToTrainingDb!');
                showPopup('Error: Button not found', 'error');
                return;
            }
            
            // Disable button and show loading
            saveBtn.disabled = true;
            const originalText = saveBtn.textContent;
            saveBtn.textContent = ' Saving...';
            if (messageDiv) messageDiv.style.display = 'none';
            
            try {
                console.log('Fetching stats from /api/stats');
                // Get current stats and heatmap data from backend
                const statsResponse = await fetch('/api/stats');
                console.log('Stats response:', statsResponse);
                const statsData = await statsResponse.json();
                console.log('Stats data:', statsData);
                
                if (!statsData.heatmap || statsData.heatmap.length === 0) {
                    console.log('No heatmap data found');
                    // Don't show error popup, just return silently
                    saveBtn.disabled = false;
                    saveBtn.textContent = originalText;
                    if (messageDiv) {
                        showSaveMessage('No shot data to save. Please analyze a video first.', 'error');
                    }
                    return;
                }
                
                console.log('Preparing shot data, count:', statsData.heatmap.length);
                // Prepare shot data
                const shotData = {
                    shots: statsData.heatmap.map(shot => ({
                        x: shot.x,
                        y: shot.y,
                        is_make: shot.is_make,
                        result: shot.is_make ? 'make' : 'miss',
                        timestamp: Date.now() // Use current timestamp
                    }))
                };
                
                console.log('Calling window.saveShotTrackerToTrainingDb with:', shotData);
                // Save to training database
                let result;
                try {
                    result = await window.saveShotTrackerToTrainingDb(user.uid, shotData);
                    console.log('Save result:', result);
                } catch (saveError) {
                    console.error('Error in saveShotTrackerToTrainingDb:', saveError);
                    // Re-throw to be caught by outer catch
                    throw saveError;
                }
                
                if (result && result.success) {
                    // Show popup notification
                    console.log('Showing success popup');
                    showPopup(' Saved!', 'success');
                    
                    // Also update message div
                    if (messageDiv) {
                        showSaveMessage(
                            `Saved successfully! ${result.makes} makes, ${result.attempts} attempts (${result.percentage}%)`,
                            'success'
                        );
                    }
                } else {
                    console.log('Save failed, result:', result);
                    showPopup('Failed to save', 'error');
                    if (messageDiv) showSaveMessage('Failed to save to training database', 'error');
                }
            } catch (error) {
                console.error('Error saving to training database:', error);
                console.error('Error stack:', error.stack);
                // Only show error popup for unexpected errors
                const errorMessage = error.message || 'Unknown error';
                if (!errorMessage.includes('No shot data') && 
                    error.code !== 'auth/popup-closed-by-user' &&
                    !errorMessage.includes('Button not found')) {
                    showPopup('Error: ' + errorMessage, 'error');
                }
                if (messageDiv && !errorMessage.includes('No shot data')) {
                    showSaveMessage('Error saving to training database: ' + errorMessage, 'error');
                }
            } finally {
                if (saveBtn) {
                    saveBtn.disabled = false;
                    saveBtn.textContent = originalText;
                }
            }
        }
        
        // Make functions globally available (note: window.saveShotTrackerToTrainingDb is the Firebase save function at line 380)
        // This local function handles the UI logic
        window.saveShotTrackerToTrainingDbLocal = saveShotTrackerToTrainingDb;
        window.showPopup = showPopup;
        
        function showSaveMessage(text, type) {
            const messageDiv = document.getElementById('saveTrainingDbMessage');
            messageDiv.textContent = text;
            messageDiv.style.display = 'block';
            if (type === 'success') {
                messageDiv.style.background = 'rgba(0, 255, 0, 0.2)';
                messageDiv.style.color = '#00aa00';
                messageDiv.style.border = '1px solid #00aa00';
            } else if (type === 'error') {
                messageDiv.style.background = 'rgba(255, 0, 0, 0.2)';
                messageDiv.style.color = '#cc0000';
                messageDiv.style.border = '1px solid #cc0000';
            }
            setTimeout(() => {
                messageDiv.textContent = '';
                messageDiv.style.display = 'none';
            }, 5000);
        }
        
        function showMessage(text, type) {
            const messageDiv = document.getElementById('uploadMessage');
            messageDiv.textContent = text;
            messageDiv.style.display = 'block';
            if (type === 'success') {
                messageDiv.style.background = 'rgba(0, 255, 0, 0.2)';
                messageDiv.style.color = '#00ff00';
            } else if (type === 'error') {
                messageDiv.style.background = 'rgba(255, 0, 0, 0.2)';
                messageDiv.style.color = '#ff0000';
            }
            setTimeout(() => {
                messageDiv.textContent = '';
                messageDiv.style.display = 'none';
            }, 5000);
        }
        
        function updateStats(data) {
            const makes = data.makes || 0;
            const attempts = data.attempts || 0;
            const percentage = attempts > 0 ? Math.round((makes / attempts) * 100) : 0;
            
            document.getElementById('makesCount').textContent = makes;
            document.getElementById('attemptsCount').textContent = attempts;
            document.getElementById('percentage').textContent = percentage + '%';
            
            // Update last shot result
            const lastShotResult = document.getElementById('lastShotResult');
            if (data.overlay_text === 'Make') {
                lastShotResult.textContent = ' MAKE';
                lastShotResult.style.color = '#00ff00';
            } else if (data.overlay_text === 'Miss') {
                lastShotResult.textContent = ' MISS';
                lastShotResult.style.color = '#ff0000';
            } else {
                lastShotResult.textContent = '-';
                lastShotResult.style.color = 'rgba(255, 255, 255, 0.7)';
            }
            
            // Update heatmap if new shots detected
            if (data.heatmap) {
                drawHeatmap(data.heatmap);
            }
        }
        
        // Heatmap drawing - EXACT COPY from original
        let lastHeatmapLength = 0;
        const canvas = document.getElementById('shotTrackerHeatmap');
        let ctx = null;
        if (canvas) {
            ctx = canvas.getContext('2d');
        }
        
        // Drawing function for Training Database heatmap (reuses same logic)
        function drawBasketballCourtForHeatmap(ctx, width, height) {
            // Draw a grid instead of court for debugging
            ctx.fillStyle = 'rgba(240, 240, 240, 0.8)';
            ctx.fillRect(0, 0, width, height);
            
            // Draw grid lines
            ctx.strokeStyle = 'rgba(200, 200, 200, 0.6)';
            ctx.lineWidth = 1;
            
            // Vertical lines (10 columns)
            const numCols = 10;
            for (let i = 0; i <= numCols; i++) {
                const x = (width / numCols) * i;
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, height);
                ctx.stroke();
            }
            
            // Horizontal lines (10 rows)
            const numRows = 10;
            for (let i = 0; i <= numRows; i++) {
                const y = (height / numRows) * i;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                ctx.stroke();
            }
            
            // Draw coordinate labels
            ctx.fillStyle = 'rgba(100, 100, 100, 0.8)';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            // Label columns (X: 0.0 to 1.0)
            for (let i = 0; i <= numCols; i++) {
                const x = (width / numCols) * i;
                const label = (i / numCols).toFixed(1);
                ctx.fillText(label, x, 15);
            }
            
            // Label rows (Y: 0.0 to 1.0)
            ctx.textAlign = 'left';
            for (let i = 0; i <= numRows; i++) {
                const y = (height / numRows) * i;
                const label = (i / numRows).toFixed(1);
                ctx.fillText(label, 5, y);
            }
            
            // Mark center (0.5, 0.5) and hoop position
            ctx.strokeStyle = 'rgba(255, 0, 0, 0.8)';
            ctx.lineWidth = 2;
            const centerX = width * 0.5;
            const centerY = height * 0.5;
            ctx.beginPath();
            ctx.arc(centerX, centerY, 5, 0, Math.PI * 2);
            ctx.stroke();
            ctx.fillStyle = 'rgba(255, 0, 0, 0.8)';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('CENTER (0.5, 0.5)', centerX, centerY - 20);
            
            // Mark hoop position - EXACT COPY from original
            const courtY = height * 0.1;
            const courtHeight = height * 0.85;
            const hoopX = width * 0.5;
            const hoopY = courtY + courtHeight * 0.05;  // 5% down from court top (matches original)
            ctx.strokeStyle = 'rgba(0, 0, 255, 0.8)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(hoopX, hoopY, 8, 0, Math.PI * 2);
            ctx.stroke();
            ctx.fillStyle = 'rgba(0, 0, 255, 0.8)';
            ctx.fillText('HOOP (0.5, ~0.14)', hoopX, hoopY - 25);
        }
        
        function drawBasketballCourt(ctx, width, height) {
            // Draw a grid instead of court for debugging
            ctx.fillStyle = 'rgba(240, 240, 240, 0.8)';
            ctx.fillRect(0, 0, width, height);
            
            // Draw grid lines
            ctx.strokeStyle = 'rgba(200, 200, 200, 0.6)';
            ctx.lineWidth = 1;
            
            // Vertical lines (10 columns)
            const numCols = 10;
            for (let i = 0; i <= numCols; i++) {
                const x = (width / numCols) * i;
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, height);
                ctx.stroke();
            }
            
            // Horizontal lines (10 rows)
            const numRows = 10;
            for (let i = 0; i <= numRows; i++) {
                const y = (height / numRows) * i;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                ctx.stroke();
            }
            
            // Draw coordinate labels
            ctx.fillStyle = 'rgba(100, 100, 100, 0.8)';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            // Label columns (X: 0.0 to 1.0)
            for (let i = 0; i <= numCols; i++) {
                const x = (width / numCols) * i;
                const label = (i / numCols).toFixed(1);
                ctx.fillText(label, x, 15);
            }
            
            // Label rows (Y: 0.0 to 1.0)
            ctx.textAlign = 'left';
            for (let i = 0; i <= numRows; i++) {
                const y = (height / numRows) * i;
                const label = (i / numRows).toFixed(1);
                ctx.fillText(label, 5, y);
            }
            
            // Mark center (0.5, 0.5) and hoop position
            ctx.strokeStyle = 'rgba(255, 0, 0, 0.8)';
            ctx.lineWidth = 2;
            const centerX = width * 0.5;
            const centerY = height * 0.5;
            ctx.beginPath();
            ctx.arc(centerX, centerY, 5, 0, Math.PI * 2);
            ctx.stroke();
            ctx.fillStyle = 'rgba(255, 0, 0, 0.8)';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('CENTER (0.5, 0.5)', centerX, centerY - 20);
            
            // Mark hoop position - EXACT COPY from original
            // Court area: courtY = height * 0.1, courtHeight = height * 0.85
            // Hoop is at: courtY + courtHeight * 0.05 = height * 0.1 + height * 0.85 * 0.05 = height * 0.1425
            const courtY = height * 0.1;
            const courtHeight = height * 0.85;
            const hoopX = width * 0.5;
            const hoopY = courtY + courtHeight * 0.05;  // 5% down from court top (matches original)
            ctx.strokeStyle = 'rgba(0, 0, 255, 0.8)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(hoopX, hoopY, 8, 0, Math.PI * 2);
            ctx.stroke();
            ctx.fillStyle = 'rgba(0, 0, 255, 0.8)';
            ctx.fillText('HOOP (0.5, ~0.14)', hoopX, hoopY - 25);
        }
        
        function drawHeatmap(heatmapData) {
            if (!ctx || !canvas) return;
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw basketball court (image or drawn)
            drawBasketballCourt(ctx, canvas.width, canvas.height);
            
            // Court area mapping - EXACT COPY from original shot_detector_web_simple.py (line 1667-1674)
            const courtX = canvas.width * 0.05;  // Left edge of court
            const courtY = canvas.height * 0.1;  // Top edge of court
            const courtWidth = canvas.width * 0.9;  // Court width
            const courtHeight = canvas.height * 0.85;  // Court height
            
            // Hoop position (matches drawBasketballCourt function - EXACT COPY from original line 1673-1674)
            const hoopX = courtX + courtWidth / 2;  // Hoop X (center of court)
            const hoopY = courtY + courtHeight * 0.05;  // Hoop Y (5% down from court top)
            
            heatmapData.forEach((shot, index) => {
                // EXACT COPY from original (line 1681-1689)
                // X coordinate: 0 = left edge of court, 1 = right edge of court
                // shot.x = 0.5 should be at hoop center (which is at court center)
                const x = courtX + (shot.x * courtWidth);
                
                // Y coordinate: Map to court height
                // The court drawing shows hoop at top (y = courtY + 5% of courtHeight)
                // shot.y values from backend: smaller = closer to hoop, larger = farther
                // Map directly: 0 = top of court (hoop area), 1 = bottom of court (3pt line)
                const y = courtY + (shot.y * courtHeight);
                
                if (shot.is_make) {
                    // Green circle for makes
                    ctx.fillStyle = 'rgba(0, 255, 0, 0.8)';
                    ctx.strokeStyle = 'rgba(0, 200, 0, 1)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(x, y, 12, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                } else {
                    // Red X for misses
                    ctx.strokeStyle = 'rgba(255, 0, 0, 1)';
                    ctx.lineWidth = 3;
                    const size = 10;
                    ctx.beginPath();
                    ctx.moveTo(x - size, y - size);
                    ctx.lineTo(x + size, y + size);
                    ctx.moveTo(x + size, y - size);
                    ctx.lineTo(x - size, y + size);
                    ctx.stroke();
                }
            });
        }
        
        // Poll stats every 500ms - EXACT COPY from original
        let statsInterval = null;
        function startStatsPolling() {
            if (statsInterval) return; // Already polling
            
            statsInterval = setInterval(function() {
                fetch('/api/stats')
                    .then(response => response.json())
                    .then(data => {
                        updateStats(data);
                        
                        // Update heatmap if new shots detected
                        if (data.heatmap) {
                            if (data.heatmap.length !== lastHeatmapLength || (lastHeatmapLength === 0 && data.heatmap.length > 0)) {
                                drawHeatmap(data.heatmap);
                                lastHeatmapLength = data.heatmap.length;
                            }
                        }
                    })
                    .catch(error => console.error('Error fetching stats:', error));
            }, 500);
        }
        
        function stopStatsPolling() {
            if (statsInterval) {
                clearInterval(statsInterval);
                statsInterval = null;
            }
        }
        
        // Old functions removed - now using AI-Basketball-Shot-Detection-Tracker exclusively
        // Stats are updated via polling /api/stats endpoint
        
        // Placeholder to prevent errors if any old code references these
        function resetShotTracker() {
            fetch('/api/reset_shot_tracker', { method: 'POST' })
                .then(() => {
                    fetch('/api/stats')
                        .then(response => response.json())
                        .then(data => updateStats(data));
                });
        }
        
        // Old processShotTrackerFrame removed - now using video stream from /api/video_feed
        // This function is no longer needed
        async function processShotTrackerFrame() {
            if (!shotTrackerActive) return;
            
            const video = document.getElementById('shotTrackerVideo');
            const canvas = document.getElementById('shotTrackerCanvas');
            const outputCanvas = document.getElementById('shotTrackerOutput');
            
            if (video.readyState === video.HAVE_ENOUGH_DATA) {
                const ctx = canvas.getContext('2d');
                const outputCtx = outputCanvas.getContext('2d');
                
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                outputCanvas.width = video.videoWidth;
                outputCanvas.height = video.videoHeight;
                
                ctx.drawImage(video, 0, 0);
                
                // Try backend first (YOLOv8), fallback to client-side detection
                let result = null;
                
                // Try backend first if available (uses AI-Basketball-Shot-Detection-Tracker YOLOv8)
                if (API_BASE_URL) {
                    try {
                        const response = await fetch(`${API_BASE_URL}/api/detect_shot`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ frame: canvas.toDataURL('image/jpeg', 0.7) })
                        });
                        
                        if (response.ok) {
                            const backendResult = await response.json();
                            if (backendResult.success) {
                                // Use backend result (AI-Basketball-Shot-Detection-Tracker YOLOv8 detection)
                                console.log(' Using YOLOv8 backend detection:', backendResult.tracker || 'AI-Basketball-Shot-Detection-Tracker (YOLOv8)');
                                result = {
                                    algorithm: 'yolo8',
                                    tracker: backendResult.tracker || 'AI-Basketball-Shot-Detection-Tracker (YOLOv8)',
                                    ball_detected: backendResult.ball_detected,
                                    ball_x: backendResult.ball_x,
                                    ball_y: backendResult.ball_y,
                                    ball_radius: backendResult.ball_radius,
                                    ball_box: backendResult.ball_box,  // Bounding box from YOLOv8
                                    rim_detected: backendResult.rim_detected,
                                    rim_x: backendResult.rim_x,
                                    rim_y: backendResult.rim_y,
                                    rim_radius: backendResult.rim_radius,
                                    rim_box: backendResult.rim_box,  // Bounding box from YOLOv8
                                    shot_result: backendResult.shot_result,
                                    makes: backendResult.makes || 0,
                                    attempts: backendResult.attempts || 0,
                                    confidence: (backendResult.ball_detected ? 0.9 : 0) + (backendResult.rim_detected ? 0.1 : 0),
                                    processed_frame: backendResult.processed_frame  // Frame with yellow lines, corner rectangles, shot counter
                                };
                                
                                // Update stats from backend (YOLOv8 tracker counts)
                                if (backendResult.makes !== undefined && backendResult.attempts !== undefined) {
                                    shotTrackerStats.makes = backendResult.makes;
                                    shotTrackerStats.total = backendResult.attempts;
                                    shotTrackerStats.misses = backendResult.attempts - backendResult.makes;
                                    updateShotTrackerDisplay();
                                }
                                
                                clientSideTrackerState.useBackend = true;
                            }
                        }
                    } catch (error) {
                        // Backend not available - log error and disable backend
                        console.error('Backend detection error:', error);
                        clientSideTrackerState.useBackend = false;
                    }
                }
                
                // Only use client-side if backend is completely unavailable
                // Do NOT fallback if backend exists but just didn't detect anything this frame
                if (!result && !API_BASE_URL) {
                    console.warn(' Using client-side detection (backend not configured)');
                    result = detectBallAndRimClientSide(ctx, canvas.width, canvas.height);
                    if (result) {
                        result.tracker = 'Client-side (fallback)';
                    }
                } else if (!result && API_BASE_URL) {
                    // Backend is available but didn't detect anything - that's OK, don't fallback
                    console.log('Backend active but no detection this frame (normal)');
                }
                
                // Store result for algorithm indicator
                if (result) {
                    latestDetectionResult = result;
                    updateAlgorithmIndicator();
                }
                
                if (result) {
                    // Draw detection results on output canvas
                    outputCtx.clearRect(0, 0, outputCanvas.width, outputCanvas.height);
                    
                    // Draw ball bounding box if available (YOLOv8)
                    if (result.ball_box && result.ball_box.length === 4) {
                        const [x1, y1, x2, y2] = result.ball_box;
                        outputCtx.strokeStyle = '#00ff00';
                        outputCtx.lineWidth = 3;
                        outputCtx.strokeRect(x1, y1, x2 - x1, y2 - y1);
                        
                        // Draw label
                        outputCtx.fillStyle = '#00ff00';
                        outputCtx.font = '14px Arial';
                        outputCtx.fillText('Basketball', x1, y1 - 5);
                    } else if (result.ball_detected && result.ball_x > 0 && result.ball_y > 0) {
                        // Fallback to circle if no bounding box
                        outputCtx.strokeStyle = '#00ff00';
                        outputCtx.lineWidth = 3;
                        outputCtx.beginPath();
                        outputCtx.arc(result.ball_x, result.ball_y, Math.max(result.ball_radius, 10), 0, 2 * Math.PI);
                        outputCtx.stroke();
                        
                        // Draw ball center
                        outputCtx.fillStyle = '#00ff00';
                        outputCtx.beginPath();
                        outputCtx.arc(result.ball_x, result.ball_y, 5, 0, 2 * Math.PI);
                        outputCtx.fill();
                    }
                    
                    // Draw rim bounding box if available (YOLOv8)
                    if (result.rim_box && result.rim_box.length === 4) {
                        const [x1, y1, x2, y2] = result.rim_box;
                        outputCtx.strokeStyle = '#ff0000';
                        outputCtx.lineWidth = 3;
                        outputCtx.strokeRect(x1, y1, x2 - x1, y2 - y1);
                        
                        // Draw label
                        outputCtx.fillStyle = '#ff0000';
                        outputCtx.font = '14px Arial';
                        outputCtx.fillText('Basketball Hoop', x1, y1 - 5);
                    } else if ((result.rim_detected || result.rim_x > 0) && result.rim_y > 0) {
                        // Fallback to circle if no bounding box
                        outputCtx.strokeStyle = '#ff0000';
                        outputCtx.lineWidth = 3;
                        outputCtx.beginPath();
                        outputCtx.arc(result.rim_x, result.rim_y, Math.max(result.rim_radius, 20), 0, 2 * Math.PI);
                        outputCtx.stroke();
                    }
                    
                    // Handle shot result
                    if (result.shot_result) {
                        handleShotResult(result.shot_result);
                    }
                }
            }
            
            if (shotTrackerActive) {
                shotTrackerRenderLoopId = requestAnimationFrame(processShotTrackerFrame);
            }
        }
        
        // ====================== MULTIPLE DETECTION ALGORITHMS ======================
        // Track results from all algorithms
        let algorithmResults = {
            colorBased: null,
            motionBased: null,
            contourBased: null,
            trajectoryBased: null,
            hsvBased: null,
            edgeBased: null,
            roiBased: null
        };
        
        // Algorithm 1: Color-based detection (fallback)
        function detectBallAndRimColorBased(ctx, width, height) {
            const imageData = ctx.getImageData(0, 0, width, height);
            const data = imageData.data;
            
            let ballDetected = false;
            let ballX = 0, ballY = 0, ballRadius = 0;
            let rimDetected = false;
            let rimX = 0, rimY = 0, rimRadius = 0;
            
            // Sample every 4th pixel for performance
            const step = 4;
            const ballCandidates = [];
            const rimCandidates = [];
            
            for (let y = 0; y < height; y += step) {
                for (let x = 0; x < width; x += step) {
                    const idx = (y * width + x) * 4;
                    const r = data[idx];
                    const g = data[idx + 1];
                    const b = data[idx + 2];
                    
                    // Detect orange/red basketball (typical colors) - more lenient thresholds
                    // Orange: high red, medium green, low blue
                    // Red: very high red, low green, low blue
                    // Also detect brown/tan basketballs
                    const isOrangeRed = (r > 120 && r > g * 1.1 && b < g * 0.9) || 
                                       (r > 180 && g < 120 && b < 120) ||
                                       (r > 100 && g > 80 && b < 60 && r > b * 1.5); // Brown/tan ball
                    
                    if (isOrangeRed) {
                        ballCandidates.push({x, y, r, g, b});
                    }
                    
                    // Detect white/bright rim (high brightness, low saturation)
                    const brightness = (r + g + b) / 3;
                    const maxColor = Math.max(r, g, b);
                    const minColor = Math.min(r, g, b);
                    const saturation = maxColor > 0 ? (maxColor - minColor) / maxColor : 0;
                    
                    // Detect rim: white, metallic, or bright colors (more lenient)
                    if (brightness > 180 && saturation < 0.4) {
                        rimCandidates.push({x, y, brightness});
                    }
                }
            }
            
            // Find ball: cluster orange/red pixels (lower threshold for better detection)
            if (ballCandidates.length > 20) {
                // Simple clustering: find center of mass
                let sumX = 0, sumY = 0, count = 0;
                let minX = width, maxX = 0, minY = height, maxY = 0;
                
                ballCandidates.forEach(p => {
                    sumX += p.x;
                    sumY += p.y;
                    count++;
                    minX = Math.min(minX, p.x);
                    maxX = Math.max(maxX, p.x);
                    minY = Math.min(minY, p.y);
                    maxY = Math.max(maxY, p.y);
                });
                
                if (count > 0) {
                    ballX = Math.round(sumX / count);
                    ballY = Math.round(sumY / count);
                    ballRadius = Math.max((maxX - minX) / 2, (maxY - minY) / 2);
                    
                    // Only consider if it's roughly circular and reasonable size (more lenient)
                    const aspectRatio = (maxX - minX) / (Math.max(maxY - minY, 1));
                    if (ballRadius > 3 && ballRadius < 150 && aspectRatio > 0.3 && aspectRatio < 3) {
                        ballDetected = true;
                        
                        // Track ball position
                        const currentTime = Date.now();
                        clientSideTrackerState.ballPositions.push({
                            pos: [ballX, ballY],
                            time: currentTime
                        });
                        
                        // Keep only recent positions (last 2 seconds)
                        clientSideTrackerState.ballPositions = clientSideTrackerState.ballPositions.filter(
                            p => currentTime - p.time < 2000
                        );
                    }
                }
            }
            
            // Find rim: cluster bright pixels in upper portion of frame (lower threshold)
            if (rimCandidates.length > 50) {
                // Look for rim in upper 70% of frame
                const upperRimCandidates = rimCandidates.filter(p => p.y < height * 0.7);
                
                if (upperRimCandidates.length > 20) {
                    let sumX = 0, sumY = 0, count = 0;
                    let minX = width, maxX = 0, minY = height, maxY = 0;
                    
                    upperRimCandidates.forEach(p => {
                        sumX += p.x;
                        sumY += p.y;
                        count++;
                        minX = Math.min(minX, p.x);
                        maxX = Math.max(maxX, p.x);
                        minY = Math.min(minY, p.y);
                        maxY = Math.max(maxY, p.y);
                    });
                    
                    if (count > 0) {
                        rimX = Math.round(sumX / count);
                        rimY = Math.round(sumY / count);
                        rimRadius = Math.max((maxX - minX) / 2, (maxY - minY) / 2);
                        
                        if (rimRadius > 15 && rimRadius < 200) {
                            rimDetected = true;
                            // Store rim position (it doesn't move)
                            if (!clientSideTrackerState.rimPosition) {
                                clientSideTrackerState.rimPosition = [rimX, rimY];
                                clientSideTrackerState.rimRadius = rimRadius;
                            } else {
                                // Use stored position if detection is inconsistent
                                rimX = clientSideTrackerState.rimPosition[0];
                                rimY = clientSideTrackerState.rimPosition[1];
                                rimRadius = clientSideTrackerState.rimRadius;
                            }
                        }
                    }
                }
            } else if (clientSideTrackerState.rimPosition) {
                // Use stored rim position if not detected this frame
                rimX = clientSideTrackerState.rimPosition[0];
                rimY = clientSideTrackerState.rimPosition[1];
                rimRadius = clientSideTrackerState.rimRadius;
                rimDetected = true;
            }
            
            // Analyze trajectory for shot result (MUCH more conservative - only trigger on clear shots)
            let shotResult = null;
            
            // Only analyze if we have:
            // 1. Enough ball positions (at least 8 frames = ball was tracked for a while)
            // 2. Rim is detected and stored
            // 3. Ball was clearly moving (not just stationary)
            if (clientSideTrackerState.ballPositions.length >= 8 && clientSideTrackerState.rimPosition) {
                const rimPos = clientSideTrackerState.rimPosition;
                const rimRad = clientSideTrackerState.rimRadius || 30;
                const ballPositions = clientSideTrackerState.ballPositions.map(p => p.pos);
                
                // Check if ball actually moved (not just stationary detection)
                const firstPos = ballPositions[0];
                const lastPos = ballPositions[ballPositions.length - 1];
                const totalMovement = Math.sqrt(
                    Math.pow(lastPos[0] - firstPos[0], 2) + 
                    Math.pow(lastPos[1] - firstPos[1], 2)
                );
                
                // Ball must have moved at least 30 pixels (actual shot motion)
                if (totalMovement < 30) {
                    return {
                        algorithm: 'contourBased',
                        ball_detected: ballDetected,
                        ball_x: ballX,
                        ball_y: ballY,
                        ball_radius: ballRadius,
                        rim_detected: rimDetected,
                        rim_x: rimX,
                        rim_y: rimY,
                        rim_radius: rimRadius,
                        shot_result: null,
                        confidence: (ballDetected ? 0.8 : 0) + (rimDetected ? 0.2 : 0)
                    };
                }
                
                // Check if ball passed through rim area (strict criteria)
                let ballAboveRim = false;
                let ballBelowRim = false;
                let ballNearRimHorizontally = false;
                let minDistToRim = Infinity;
                
                for (let pos of ballPositions) {
                    const distToRim = Math.sqrt(
                        Math.pow(pos[0] - rimPos[0], 2) + 
                        Math.pow(pos[1] - rimPos[1], 2)
                    );
                    minDistToRim = Math.min(minDistToRim, distToRim);
                    
                    // Check vertical position relative to rim
                    if (pos[1] < rimPos[1] - rimRad * 0.3) {
                        ballAboveRim = true;
                    }
                    if (pos[1] > rimPos[1] + rimRad * 0.3) {
                        ballBelowRim = true;
                    }
                    
                    // Check horizontal proximity (ball must be close horizontally)
                    const horizontalDist = Math.abs(pos[0] - rimPos[0]);
                    if (horizontalDist < rimRad * 1.2) {
                        ballNearRimHorizontally = true;
                    }
                }
                
                // Only call it a make if:
                // 1. Ball was above AND below rim (went through)
                // 2. Ball was close horizontally to rim
                // 3. Ball got very close to rim center
                if (ballAboveRim && ballBelowRim && ballNearRimHorizontally && minDistToRim < rimRad * 1.5) {
                    const currentTime = Date.now();
                    if (currentTime - clientSideTrackerState.lastShotTime > 3000) { // 3 second cooldown
                        shotResult = 'make';
                        clientSideTrackerState.lastShotTime = currentTime;
                        clientSideTrackerState.ballPositions = [];
                    }
                }
                // Don't call misses automatically - too many false positives
                // Only call miss if user explicitly marks it or we're very certain
            }
            
            // Debug logging (can be removed later)
            if (ballDetected || rimDetected) {
                console.log('Detection:', {
                    ball: ballDetected,
                    ballPos: ballDetected ? [ballX, ballY] : null,
                    rim: rimDetected,
                    rimPos: rimDetected ? [rimX, rimY] : null,
                    shotResult: shotResult,
                    ballTrajectoryLength: clientSideTrackerState.ballPositions.length
                });
            }
            
            return {
                algorithm: 'colorBased',
                ball_detected: ballDetected,
                ball_x: ballX,
                ball_y: ballY,
                ball_radius: ballRadius,
                rim_detected: rimDetected,
                rim_x: rimX,
                rim_y: rimY,
                rim_radius: rimRadius,
                shot_result: shotResult,
                confidence: ballDetected ? (ballCandidates.length / 100) : 0
            };
        }
        
        // Algorithm 2: Motion-based detection (browlm13 style - trajectory analysis)
        function detectBallAndRimMotionBased(ctx, width, height, prevFrame) {
            const imageData = ctx.getImageData(0, 0, width, height);
            const data = imageData.data;
            
            let ballDetected = false;
            let ballX = 0, ballY = 0, ballRadius = 0;
            
            if (prevFrame && prevFrame.length === data.length) {
                // Detect moving objects (ball should be moving)
                const motionThreshold = 30;
                const movingPixels = [];
                
                for (let i = 0; i < data.length; i += 16) { // Sample every 4th pixel
                    const idx = Math.floor(i / 4) * 4;
                    if (idx + 3 < data.length && idx + 3 < prevFrame.length) {
                        const currBrightness = (data[idx] + data[idx + 1] + data[idx + 2]) / 3;
                        const prevBrightness = (prevFrame[idx] + prevFrame[idx + 1] + prevFrame[idx + 2]) / 3;
                        const motion = Math.abs(currBrightness - prevBrightness);
                        
                        if (motion > motionThreshold) {
                            const x = (idx / 4) % width;
                            const y = Math.floor((idx / 4) / width);
                            movingPixels.push({x, y, motion});
                        }
                    }
                }
                
                // Cluster moving pixels to find ball
                if (movingPixels.length > 30) {
                    let sumX = 0, sumY = 0;
                    movingPixels.forEach(p => {
                        sumX += p.x;
                        sumY += p.y;
                    });
                    ballX = Math.round(sumX / movingPixels.length);
                    ballY = Math.round(sumY / movingPixels.length);
                    ballRadius = 20; // Default radius
                    ballDetected = true;
                }
            }
            
            // Store current frame for next comparison
            if (!window.prevFrameData) {
                window.prevFrameData = new Uint8Array(data.length);
            }
            window.prevFrameData.set(data);
            
            return {
                algorithm: 'motionBased',
                ball_detected: ballDetected,
                ball_x: ballX,
                ball_y: ballY,
                ball_radius: ballRadius,
                rim_detected: false, // Motion-based doesn't detect rim well
                rim_x: 0,
                rim_y: 0,
                rim_radius: 0,
                shot_result: null,
                confidence: ballDetected ? 0.6 : 0
            };
        }
        
        // Algorithm 3: Improved HSV-based detection (much more accurate than RGB)
        // Based on OpenCV HSV ranges used in professional basketball detection systems
        function detectBallAndRimContourBased(ctx, width, height) {
            const imageData = ctx.getImageData(0, 0, width, height);
            const data = imageData.data;
            
            let ballDetected = false;
            let ballX = 0, ballY = 0, ballRadius = 0;
            let rimDetected = false;
            let rimX = 0, rimY = 0, rimRadius = 0;
            
            const ballCandidates = [];
            const rimCandidates = [];
            
            // Focus on court area (avoid sky/trees)
            const courtStartY = Math.floor(height * 0.15);
            const courtEndY = Math.floor(height * 0.9);
            const step = 2; // Denser sampling for better detection
            
            for (let y = courtStartY; y < courtEndY; y += step) {
                for (let x = Math.floor(width * 0.1); x < Math.floor(width * 0.9); x += step) {
                    const idx = (y * width + x) * 4;
                    if (idx + 2 >= data.length) continue;
                    
                    const r = data[idx] / 255.0;
                    const g = data[idx + 1] / 255.0;
                    const b = data[idx + 2] / 255.0;
                    
                    // Convert RGB to HSV (more robust to lighting)
                    const max = Math.max(r, g, b);
                    const min = Math.min(r, g, b);
                    const delta = max - min;
                    
                    let h = 0, s = 0, v = max;
                    
                    if (delta !== 0) {
                        s = delta / (max + 0.001);
                        if (max === r) {
                            h = 60 * (((g - b) / delta) % 6);
                        } else if (max === g) {
                            h = 60 * (((b - r) / delta) + 2);
                        } else {
                            h = 60 * (((r - g) / delta) + 4);
                        }
                        if (h < 0) h += 360;
                    }
                    
                    // Basketball detection: Orange (10-30) or Red (0-10 or 350-360)
                    // Based on OpenCV HSV ranges: [0,100,100] to [10,255,255] and [160,100,100] to [180,255,255]
                    const hDegrees = h;
                    const sPercent = s * 100;
                    const vPercent = v * 100;
                    
                    // Orange range: Hue 10-30, Saturation > 40%, Value > 40%
                    const isOrange = (hDegrees >= 10 && hDegrees <= 30 && sPercent > 40 && vPercent > 40);
                    // Red range: Hue 0-10 or 350-360, Saturation > 50%, Value > 50%
                    const isRed = ((hDegrees >= 0 && hDegrees <= 10) || (hDegrees >= 350 && hDegrees <= 360)) && 
                                  sPercent > 50 && vPercent > 50;
                    
                    if (isOrange || isRed) {
                        // Additional check: must be in reasonable size range and court area
                        if (y > height * 0.2 && y < height * 0.85) {
                            ballCandidates.push({x, y, h: hDegrees, s: sPercent, v: vPercent});
                        }
                    }
                    
                    // Rim detection: High brightness (Value > 70%), low saturation (< 30%), white/metallic
                    // Must be in upper portion of frame
                    if (y < height * 0.6 && vPercent > 70 && sPercent < 30) {
                        // Additional check: RGB values should be similar (white/gray)
                        const rgbDiff = Math.max(Math.abs(r - g), Math.abs(g - b), Math.abs(r - b));
                        if (rgbDiff < 0.15) { // Very low color variation
                            rimCandidates.push({x, y, v: vPercent});
                        }
                    }
                }
            }
            
            // Cluster ball candidates using DBSCAN-like approach
            if (ballCandidates.length > 20) {
                // Group nearby candidates
                const clusters = [];
                const used = new Set();
                
                for (let i = 0; i < ballCandidates.length; i++) {
                    if (used.has(i)) continue;
                    
                    const cluster = [i];
                    used.add(i);
                    const center = ballCandidates[i];
                    
                    // Find nearby points
                    for (let j = i + 1; j < ballCandidates.length; j++) {
                        if (used.has(j)) continue;
                        const dist = Math.sqrt(
                            Math.pow(ballCandidates[j].x - center.x, 2) + 
                            Math.pow(ballCandidates[j].y - center.y, 2)
                        );
                        if (dist < 30) { // Within 30 pixels
                            cluster.push(j);
                            used.add(j);
                        }
                    }
                    
                    if (cluster.length > 15) { // Need at least 15 points for a valid ball
                        clusters.push(cluster);
                    }
                }
                
                // Find largest cluster (most likely the ball)
                if (clusters.length > 0) {
                    clusters.sort((a, b) => b.length - a.length);
                    const bestCluster = clusters[0];
                    
                    let sumX = 0, sumY = 0;
                    let minX = width, maxX = 0, minY = height, maxY = 0;
                    
                    bestCluster.forEach(idx => {
                        const p = ballCandidates[idx];
                        sumX += p.x;
                        sumY += p.y;
                        minX = Math.min(minX, p.x);
                        maxX = Math.max(maxX, p.x);
                        minY = Math.min(minY, p.y);
                        maxY = Math.max(maxY, p.y);
                    });
                    
                    ballX = Math.round(sumX / bestCluster.length);
                    ballY = Math.round(sumY / bestCluster.length);
                    const width_ball = maxX - minX;
                    const height_ball = maxY - minY;
                    ballRadius = Math.max(width_ball, height_ball) / 2;
                    
                    // Validate size
                    if (ballRadius >= 8 && ballRadius <= 50) {
                        ballDetected = true;
                    }
                }
            }
            
            // Cluster rim candidates
            if (rimCandidates.length > 30) {
                // Rim is typically larger and more spread out
                let sumX = 0, sumY = 0, count = 0;
                let minX = width, maxX = 0, minY = height, maxY = 0;
                
                rimCandidates.forEach(p => {
                    sumX += p.x;
                    sumY += p.y;
                    count++;
                    minX = Math.min(minX, p.x);
                    maxX = Math.max(maxX, p.x);
                    minY = Math.min(minY, p.y);
                    maxY = Math.max(maxY, p.y);
                });
                
                rimX = Math.round(sumX / count);
                rimY = Math.round(sumY / count);
                const rimWidth = maxX - minX;
                const rimHeight = maxY - minY;
                rimRadius = Math.max(rimWidth, rimHeight) / 2;
                
                // Rim should be larger than ball
                if (rimRadius >= 15 && rimRadius <= 80) {
                    rimDetected = true;
                }
            }
            
            return {
                algorithm: 'hsvBased',
                ball_detected: ballDetected,
                ball_x: ballX,
                ball_y: ballY,
                ball_radius: ballRadius,
                rim_detected: rimDetected,
                rim_x: rimX,
                rim_y: rimY,
                rim_radius: rimRadius,
                shot_result: null,
                confidence: (ballDetected ? 0.85 : 0) + (rimDetected ? 0.15 : 0)
            };
        }
        
        // Algorithm 4: Trajectory-based (point-slope analysis)
        function detectBallAndRimTrajectoryBased(ctx, width, height) {
            // This uses the trajectory data we already have
            const ballPositions = clientSideTrackerState.ballPositions.map(p => p.pos);
            const rimPos = clientSideTrackerState.rimPosition;
            
            let ballDetected = false;
            let ballX = 0, ballY = 0, ballRadius = 0;
            let shotResult = null;
            
            if (ballPositions.length > 0) {
                const lastPos = ballPositions[ballPositions.length - 1];
                ballDetected = true;
                ballX = lastPos[0];
                ballY = lastPos[1];
                ballRadius = 15;
                
                // Point-slope analysis for make/miss
                if (ballPositions.length >= 5 && rimPos) {
                    const rimRad = clientSideTrackerState.rimRadius || 30;
                    
                    // Calculate trajectory line
                    const firstPos = ballPositions[0];
                    const slope = (lastPos[1] - firstPos[1]) / (lastPos[0] - firstPos[0] + 0.001);
                    const intercept = firstPos[1] - slope * firstPos[0];
                    
                    // Find intersection with rim height
                    const rimY = rimPos[1];
                    const intersectionX = (rimY - intercept) / (slope + 0.001);
                    const distToRim = Math.abs(intersectionX - rimPos[0]);
                    
                    if (distToRim < rimRad * 1.5) {
                        const currentTime = Date.now();
                        if (currentTime - clientSideTrackerState.lastShotTime > 2000) {
                            shotResult = 'make';
                            clientSideTrackerState.lastShotTime = currentTime;
                        }
                    } else if (ballPositions.length > 10) {
                        const currentTime = Date.now();
                        if (currentTime - clientSideTrackerState.lastShotTime > 2000) {
                            shotResult = 'miss';
                            clientSideTrackerState.lastShotTime = currentTime;
                        }
                    }
                }
            }
            
            return {
                algorithm: 'trajectoryBased',
                ball_detected: ballDetected,
                ball_x: ballX,
                ball_y: ballY,
                ball_radius: ballRadius,
                rim_detected: rimPos !== null,
                rim_x: rimPos ? rimPos[0] : 0,
                rim_y: rimPos ? rimPos[1] : 0,
                rim_radius: clientSideTrackerState.rimRadius || 0,
                shot_result: shotResult,
                confidence: ballDetected ? 0.8 : 0
            };
        }
        
        // Algorithm 5: HSV-based detection (more accurate color space - Hoopify style)
        function detectBallAndRimHSVBased(ctx, width, height) {
            const imageData = ctx.getImageData(0, 0, width, height);
            const data = imageData.data;
            
            let ballDetected = false;
            let ballX = 0, ballY = 0, ballRadius = 0;
            let rimDetected = false;
            let rimX = 0, rimY = 0, rimRadius = 0;
            
            const ballCandidates = [];
            const rimCandidates = [];
            
            // Convert RGB to HSV and detect
            for (let y = 0; y < height; y += 3) {
                for (let x = 0; x < width; x += 3) {
                    const idx = (y * width + x) * 4;
                    if (idx + 2 >= data.length) continue;
                    
                    const r = data[idx] / 255;
                    const g = data[idx + 1] / 255;
                    const b = data[idx + 2] / 255;
                    
                    const max = Math.max(r, g, b);
                    const min = Math.min(r, g, b);
                    const delta = max - min;
                    
                    let h = 0, s = 0, v = max;
                    
                    if (delta !== 0) {
                        s = delta / max;
                        if (max === r) {
                            h = 60 * (((g - b) / delta) % 6);
                        } else if (max === g) {
                            h = 60 * (((b - r) / delta) + 2);
                        } else {
                            h = 60 * (((r - g) / delta) + 4);
                        }
                        if (h < 0) h += 360;
                    }
                    
                    // Basketball: Orange (10-30 degrees) or Red (0-10 or 350-360)
                    const isOrange = (h >= 10 && h <= 30 && s > 0.5 && v > 0.4);
                    const isRed = ((h >= 0 && h <= 10) || (h >= 350 && h <= 360)) && s > 0.6 && v > 0.5;
                    
                    if (isOrange || isRed) {
                        ballCandidates.push({x, y, h, s, v});
                    }
                    
                    // Rim: High brightness, low saturation (white/metallic)
                    if (v > 0.7 && s < 0.3 && y < height * 0.6) {
                        rimCandidates.push({x, y, v});
                    }
                }
            }
            
            // Cluster ball candidates
            if (ballCandidates.length > 30) {
                let sumX = 0, sumY = 0, count = 0;
                let minX = width, maxX = 0, minY = height, maxY = 0;
                
                ballCandidates.forEach(p => {
                    sumX += p.x;
                    sumY += p.y;
                    count++;
                    minX = Math.min(minX, p.x);
                    maxX = Math.max(maxX, p.x);
                    minY = Math.min(minY, p.y);
                    maxY = Math.max(maxY, p.y);
                });
                
                ballX = Math.round(sumX / count);
                ballY = Math.round(sumY / count);
                ballRadius = Math.max((maxX - minX) / 2, (maxY - minY) / 2);
                
                if (ballRadius > 5 && ballRadius < 120) {
                    ballDetected = true;
                }
            }
            
            // Cluster rim candidates
            if (rimCandidates.length > 40) {
                let sumX = 0, sumY = 0, count = 0;
                rimCandidates.forEach(p => {
                    sumX += p.x;
                    sumY += p.y;
                    count++;
                });
                
                rimX = Math.round(sumX / count);
                rimY = Math.round(sumY / count);
                rimRadius = 25; // Default rim radius
                rimDetected = true;
            }
            
            return {
                algorithm: 'hsvBased',
                ball_detected: ballDetected,
                ball_x: ballX,
                ball_y: ballY,
                ball_radius: ballRadius,
                rim_detected: rimDetected,
                rim_x: rimX,
                rim_y: rimY,
                rim_radius: rimRadius,
                shot_result: null,
                confidence: (ballDetected ? 0.75 : 0) + (rimDetected ? 0.25 : 0)
            };
        }
        
        // Algorithm 6: Edge-based detection (Canny-like approach)
        function detectBallAndRimEdgeBased(ctx, width, height) {
            const imageData = ctx.getImageData(0, 0, width, height);
            const data = imageData.data;
            
            // Simple edge detection
            const edges = [];
            const step = 2;
            
            for (let y = step; y < height - step; y += step) {
                for (let x = step; x < width - step; x += step) {
                    const idx = (y * width + x) * 4;
                    if (idx + 2 >= data.length) continue;
                    
                    const center = (data[idx] + data[idx + 1] + data[idx + 2]) / 3;
                    const right = (data[idx + 4] + data[idx + 5] + data[idx + 6]) / 3;
                    const bottom = (data[((y + step) * width + x) * 4] + 
                                   data[((y + step) * width + x) * 4 + 1] + 
                                   data[((y + step) * width + x) * 4 + 2]) / 3;
                    
                    const edgeStrength = Math.abs(center - right) + Math.abs(center - bottom);
                    
                    if (edgeStrength > 40) {
                        edges.push({x, y, strength: edgeStrength});
                    }
                }
            }
            
            // Find circular edges (ball/rim)
            let ballDetected = false;
            let ballX = 0, ballY = 0, ballRadius = 0;
            
            // Look for circular patterns in edges
            for (let i = 0; i < Math.min(edges.length, 100); i++) {
                const center = edges[i];
                let circleScore = 0;
                const testRadius = 15;
                
                for (let angle = 0; angle < 360; angle += 30) {
                    const checkX = Math.round(center.x + testRadius * Math.cos(angle * Math.PI / 180));
                    const checkY = Math.round(center.y + testRadius * Math.sin(angle * Math.PI / 180));
                    
                    if (checkX >= 0 && checkX < width && checkY >= 0 && checkY < height) {
                        const checkIdx = (checkY * width + checkX) * 4;
                        if (checkIdx + 2 < data.length) {
                            const r = data[checkIdx];
                            const g = data[checkIdx + 1];
                            const b = data[checkIdx + 2];
                            // Check if it's orange/red (ball)
                            if ((r > 150 && r > g * 1.2 && b < g * 0.8) || (r > 200 && g < 120)) {
                                circleScore++;
                            }
                        }
                    }
                }
                
                if (circleScore >= 6) {
                    ballDetected = true;
                    ballX = center.x;
                    ballY = center.y;
                    ballRadius = testRadius;
                    break;
                }
            }
            
            return {
                algorithm: 'edgeBased',
                ball_detected: ballDetected,
                ball_x: ballX,
                ball_y: ballY,
                ball_radius: ballRadius,
                rim_detected: false,
                rim_x: 0,
                rim_y: 0,
                rim_radius: 0,
                shot_result: null,
                confidence: ballDetected ? 0.65 : 0
            };
        }
        
        // Algorithm 7: Region-of-Interest based (focus on court area - AI Field Goal Tracker style)
        function detectBallAndRimROIBased(ctx, width, height) {
            // Focus detection on the court area (lower 2/3 of frame, center region)
            const roiX = width * 0.2;
            const roiY = height * 0.2;
            const roiWidth = width * 0.6;
            const roiHeight = height * 0.6;
            
            const imageData = ctx.getImageData(roiX, roiY, roiWidth, roiHeight);
            const data = imageData.data;
            
            let ballDetected = false;
            let ballX = 0, ballY = 0, ballRadius = 0;
            let rimDetected = false;
            let rimX = 0, rimY = 0, rimRadius = 0;
            
            const ballCandidates = [];
            const rimCandidates = [];
            
            // Detect in ROI only
            for (let y = 0; y < roiHeight; y += 4) {
                for (let x = 0; x < roiWidth; x += 4) {
                    const idx = (y * roiWidth + x) * 4;
                    if (idx + 2 >= data.length) continue;
                    
                    const r = data[idx];
                    const g = data[idx + 1];
                    const b = data[idx + 2];
                    
                    // Ball: orange/red
                    const isBall = (r > 130 && r > g * 1.15 && b < g * 0.85) || 
                                  (r > 170 && g < 110 && b < 110);
                    
                    // Rim: bright white
                    const brightness = (r + g + b) / 3;
                    const isRim = brightness > 190 && Math.abs(r - g) < 20 && Math.abs(g - b) < 20;
                    
                    if (isBall) {
                        ballCandidates.push({x: x + roiX, y: y + roiY});
                    }
                    if (isRim && y < roiHeight * 0.5) { // Rim in upper part of ROI
                        rimCandidates.push({x: x + roiX, y: y + roiY});
                    }
                }
            }
            
            // Cluster ball
            if (ballCandidates.length > 25) {
                let sumX = 0, sumY = 0;
                ballCandidates.forEach(p => {
                    sumX += p.x;
                    sumY += p.y;
                });
                ballX = Math.round(sumX / ballCandidates.length);
                ballY = Math.round(sumY / ballCandidates.length);
                ballRadius = 18;
                ballDetected = true;
            }
            
            // Cluster rim
            if (rimCandidates.length > 30) {
                let sumX = 0, sumY = 0;
                rimCandidates.forEach(p => {
                    sumX += p.x;
                    sumY += p.y;
                });
                rimX = Math.round(sumX / rimCandidates.length);
                rimY = Math.round(sumY / rimCandidates.length);
                rimRadius = 28;
                rimDetected = true;
            }
            
            return {
                algorithm: 'roiBased',
                ball_detected: ballDetected,
                ball_x: ballX,
                ball_y: ballY,
                ball_radius: ballRadius,
                rim_detected: rimDetected,
                rim_x: rimX,
                rim_y: rimY,
                rim_radius: rimRadius,
                shot_result: null,
                confidence: (ballDetected ? 0.8 : 0) + (rimDetected ? 0.2 : 0)
            };
        }
        
        // Client-side fallback detection (used when backend unavailable)
        function detectBallAndRimClientSide(ctx, width, height) {
            // Fallback to HSV-based detection
            const contourResult = detectBallAndRimContourBased(ctx, width, height);
            
            // Track ball position for trajectory analysis
            if (contourResult.ball_detected) {
                const currentTime = Date.now();
                clientSideTrackerState.ballPositions.push({
                    pos: [contourResult.ball_x, contourResult.ball_y],
                    time: currentTime
                });
                
                // Keep only recent positions (last 2 seconds)
                clientSideTrackerState.ballPositions = clientSideTrackerState.ballPositions.filter(
                    p => currentTime - p.time < 2000
                );
            }
            
            // Store rim position
            if (contourResult.rim_detected && !clientSideTrackerState.rimPosition) {
                clientSideTrackerState.rimPosition = [contourResult.rim_x, contourResult.rim_y];
                clientSideTrackerState.rimRadius = contourResult.rim_radius;
            } else if (clientSideTrackerState.rimPosition && !contourResult.rim_detected) {
                // Use stored rim position if not detected this frame
                contourResult.rim_x = clientSideTrackerState.rimPosition[0];
                contourResult.rim_y = clientSideTrackerState.rimPosition[1];
                contourResult.rim_radius = clientSideTrackerState.rimRadius;
                contourResult.rim_detected = true;
            }
            
            // Analyze trajectory for shot result (VERY conservative - only makes, no automatic misses)
            if (clientSideTrackerState.ballPositions.length >= 10 && clientSideTrackerState.rimPosition) {
                const rimPos = clientSideTrackerState.rimPosition;
                const rimRad = clientSideTrackerState.rimRadius || 30;
                const ballPositions = clientSideTrackerState.ballPositions.map(p => p.pos);
                
                // Check if ball actually moved significantly (real shot motion)
                const firstPos = ballPositions[0];
                const lastPos = ballPositions[ballPositions.length - 1];
                const totalMovement = Math.sqrt(
                    Math.pow(lastPos[0] - firstPos[0], 2) + 
                    Math.pow(lastPos[1] - firstPos[1], 2)
                );
                
                // Ball must have moved at least 40 pixels (actual shot motion, not false detection)
                if (totalMovement < 40) {
                    // Not enough movement - don't analyze
                    return contourResult;
                }
                
                let ballAboveRim = false;
                let ballBelowRim = false;
                let ballNearRimHorizontally = false;
                let minDistToRim = Infinity;
                
                for (let pos of ballPositions) {
                    const distToRim = Math.sqrt(
                        Math.pow(pos[0] - rimPos[0], 2) + 
                        Math.pow(pos[1] - rimPos[1], 2)
                    );
                    minDistToRim = Math.min(minDistToRim, distToRim);
                    
                    // Check vertical position relative to rim
                    if (pos[1] < rimPos[1] - rimRad * 0.4) {
                        ballAboveRim = true;
                    }
                    if (pos[1] > rimPos[1] + rimRad * 0.4) {
                        ballBelowRim = true;
                    }
                    
                    // Check horizontal proximity
                    const horizontalDist = Math.abs(pos[0] - rimPos[0]);
                    if (horizontalDist < rimRad * 1.3) {
                        ballNearRimHorizontally = true;
                    }
                }
                
                // Only call it a make if ALL conditions are met:
                // 1. Ball was clearly above AND below rim (went through)
                // 2. Ball was close horizontally to rim
                // 3. Ball got very close to rim center (within 1.3x radius)
                if (ballAboveRim && ballBelowRim && ballNearRimHorizontally && minDistToRim < rimRad * 1.3) {
                    const currentTime = Date.now();
                    if (currentTime - clientSideTrackerState.lastShotTime > 4000) { // 4 second cooldown
                        contourResult.shot_result = 'make';
                        clientSideTrackerState.lastShotTime = currentTime;
                        clientSideTrackerState.ballPositions = [];
                    }
                }
                // REMOVED automatic miss detection - too many false positives
                // Only detect makes, not misses automatically
            }
            
            // Log detection
            if (contourResult.ball_detected || contourResult.rim_detected) {
                console.log('Client-side Algorithm:', {
                    ball: contourResult.ball_detected,
                    ballPos: contourResult.ball_detected ? [contourResult.ball_x, contourResult.ball_y] : null,
                    rim: contourResult.rim_detected,
                    rimPos: contourResult.rim_detected ? [contourResult.rim_x, contourResult.rim_y] : null,
                    shotResult: contourResult.shot_result
                });
            }
            
            return contourResult;
        }
        
        // Store latest detection result for indicator
        let latestDetectionResult = null;
        
        function updateAlgorithmIndicator() {
            const indicator = document.getElementById('algorithmIndicator');
            const stats = document.getElementById('algorithmStats');
            
            if (!indicator || !stats) return;
            
            // Always show the indicator when shot tracker is active
            indicator.style.display = 'block';
            
            // Use latest detection result (from backend or client-side)
            const result = latestDetectionResult;
            if (result) {
                const ballDet = result.ball_detected ? '' : '';
                const rimDet = result.rim_detected ? '' : '';
                const conf = (result.confidence * 100).toFixed(0);
                const ballColor = result.ball_detected ? '#4ade80' : '#ef4444';
                const rimColor = result.rim_detected ? '#4ade80' : '#ef4444';
                // Get tracker name from result, default to AI-Basketball-Shot-Detection-Tracker
                const algoName = result.tracker || (result.algorithm === 'yolo8' ? 'AI-Basketball-Shot-Detection-Tracker (YOLOv8)' : 'Client-side');
                
                // Update the model name display
                const modelNameDiv = indicator.querySelector('div[style*="font-weight: 700"]');
                if (modelNameDiv) {
                    modelNameDiv.textContent = ` Model: ${algoName}`;
                }
                
                stats.innerHTML = `
                    <div style="margin-top: 4px;">
                        <div style="color: ${ballColor}; margin-bottom: 2px;">Ball: ${ballDet} ${result.ball_detected ? `(${result.ball_x}, ${result.ball_y})` : ''}</div>
                        <div style="color: ${rimColor}; margin-bottom: 2px;">Rim: ${rimDet} ${result.rim_detected ? `(${result.rim_x}, ${result.rim_y})` : ''}</div>
                        <div style="color: #94a3b8; font-size: 9px; margin-top: 4px;">Confidence: ${conf}%</div>
                        ${result.shot_result ? `<div style="color: #fbbf24; margin-top: 4px; font-weight: 600;">Shot: ${result.shot_result.toUpperCase()}</div>` : ''}
                    </div>
                `;
            } else {
                // Show model info even when no detections yet
                stats.innerHTML = '<div style="color: #94a3b8; font-size: 9px;">Waiting for detection...</div>';
            }
        }
        
        let lastShotTime = 0;
        const SHOT_COOLDOWN = 2000; // 2 seconds between shots
        
        function handleShotResult(result) {
            const now = Date.now();
            if (now - lastShotTime < SHOT_COOLDOWN) {
                return; // Prevent duplicate detections
            }
            
            lastShotTime = now;
            
            shotTrackerStats.total++;
            if (result === 'make') {
                shotTrackerStats.makes++;
            } else {
                shotTrackerStats.misses++;
            }
            
            shotHistory.push({
                result: result,
                timestamp: now
            });
            
            // Keep only last 50 shots in history
            if (shotHistory.length > 50) {
                shotHistory.shift();
            }
            
            updateShotTrackerDisplay();
            updateShotHistory();
            saveShotTrackerStats();
            
            // Show notification
            showShotNotification(result);
        }
        
        function showShotNotification(result) {
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                padding: 20px 30px;
                background: ${result === 'make' ? '#11998e' : '#f5576c'};
                color: white;
                border-radius: 12px;
                font-size: 24px;
                font-weight: 700;
                z-index: 10000;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                animation: slideIn 0.3s ease;
            `;
            notification.textContent = result === 'make' ? ' MAKE!' : ' MISS';
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.style.animation = 'slideOut 0.3s ease';
                setTimeout(() => notification.remove(), 300);
            }, 1500);
        }
        
        // Add CSS animations
        if (!document.getElementById('shotTrackerStyles')) {
            const style = document.createElement('style');
            style.id = 'shotTrackerStyles';
            style.textContent = `
                @keyframes slideIn {
                    from { transform: translateX(400px); opacity: 0; }
                    to { transform: translateX(0); opacity: 1; }
                }
                @keyframes slideOut {
                    from { transform: translateX(0); opacity: 1; }
                    to { transform: translateX(400px); opacity: 0; }
                }
            `;
            document.head.appendChild(style);
        }
        
        // Mode toggle functions
        function switchShotTrackerMode(mode) {
            shotTrackerMode = mode;
            
            const liveBtn = document.getElementById('shotTrackerLiveModeBtn');
            const uploadBtn = document.getElementById('shotTrackerUploadModeBtn');
            const liveControls = document.getElementById('shotTrackerLiveControls');
            const videoControls = document.getElementById('shotTrackerVideoControls');
            const uploadControls = document.getElementById('shotTrackerUploadControls');
            const video = document.getElementById('shotTrackerVideo');
            const outputCanvas = document.getElementById('shotTrackerOutput');
            
            if (mode === 'live') {
                liveBtn.classList.add('active');
                uploadBtn.classList.remove('active');
                liveControls.style.display = 'flex';
                videoControls.style.display = 'none';
                uploadControls.style.display = 'none';
                video.controls = false;
                video.autoplay = true;
                
                // Stop any video analysis
                if (videoAnalysisActive) {
                    stopVideoAnalysis();
                }
                
                // Clear video source if it was from upload
                if (video.src && video.src.startsWith('blob:')) {
                    URL.revokeObjectURL(video.src);
                    video.src = '';
                }
                
                // Clear overlay
                const ctx = outputCanvas.getContext('2d');
                ctx.clearRect(0, 0, outputCanvas.width, outputCanvas.height);
            } else {
                liveBtn.classList.remove('active');
                uploadBtn.classList.add('active');
                liveControls.style.display = 'none';
                videoControls.style.display = 'flex';
                uploadControls.style.display = 'block';
                video.controls = true;
                video.autoplay = false;
                
                // Stop live tracking if active
                if (shotTrackerActive) {
                    stopShotTracker();
                }
                
                // Clear overlay
                const ctx = outputCanvas.getContext('2d');
                ctx.clearRect(0, 0, outputCanvas.width, outputCanvas.height);
            }
        }
        
        // Handle video file upload
        function handleVideoUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            if (!file.type.startsWith('video/')) {
                alert('Please select a valid video file.');
                return;
            }
            
            uploadedVideoFile = file;
            const fileName = file.name;
            document.getElementById('shotTrackerUploadedFileName').textContent = `Selected: ${fileName}`;
            
            const video = document.getElementById('shotTrackerVideo');
            const url = URL.createObjectURL(file);
            video.src = url;
            video.load();
            
            // Reset stats when new video is loaded
            shotTrackerStats = { total: 0, makes: 0, misses: 0 };
            shotHistory = [];
            updateShotTrackerDisplay();
            updateShotHistory();
            
            // Reset client-side tracker state
            clientSideTrackerState = {
                ballPositions: [],
                rimPosition: null,
                rimRadius: null,
                lastShotTime: 0,
                useBackend: false
            };
            
            // Try to reset backend if available (completely silent, no errors)
            if (API_BASE_URL) {
                fetch(`${API_BASE_URL}/api/reset_shot_tracker`, { 
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                }).catch(() => {
                    // Silently ignore - backend not available, client-side will work
                });
            }
        }
        
        // Analyze uploaded video frame by frame
        async function analyzeUploadedVideo() {
            const video = document.getElementById('shotTrackerVideo');
            if (!uploadedVideoFile || !video.src) {
                alert('Please upload a video file first.');
                return;
            }
            
            videoAnalysisActive = true;
            videoAnalysisPaused = false;
            
            const analyzeBtn = document.getElementById('analyzeUploadedVideo');
            const pauseBtn = document.getElementById('pauseVideoAnalysis');
            const statusDiv = document.getElementById('videoAnalysisStatus');
            const statusText = document.getElementById('analysisStatusText');
            
            analyzeBtn.style.display = 'none';
            pauseBtn.style.display = 'inline-block';
            statusDiv.style.display = 'block';
            statusText.textContent = 'Analyzing video...';
            
            // Show analysis indicator
            const indicator = document.getElementById('analysisIndicator');
            if (indicator) indicator.style.display = 'block';
            
            // Show algorithm indicator
            const algoIndicator = document.getElementById('algorithmIndicator');
            if (algoIndicator) algoIndicator.style.display = 'block';
            
            // Reset stats for this analysis
            shotTrackerStats = { total: 0, makes: 0, misses: 0 };
            shotHistory = [];
            updateShotTrackerDisplay();
            updateShotHistory();
            
            // Reset client-side tracker state
            clientSideTrackerState = {
                ballPositions: [],
                rimPosition: null,
                rimRadius: null,
                lastShotTime: 0,
                useBackend: false
            };
            
            // Try to reset backend if available (completely silent, no errors)
            if (API_BASE_URL) {
                fetch(`${API_BASE_URL}/api/reset_shot_tracker`, { 
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                }).then(() => {
                    clientSideTrackerState.useBackend = true;
                }).catch(() => {
                    // Silently ignore - backend not available, client-side will work
                    clientSideTrackerState.useBackend = false;
                });
            }
            
            // Wait for video metadata to load
            if (video.readyState < video.HAVE_METADATA) {
                video.addEventListener('loadedmetadata', () => {
                    video.currentTime = 0;
                    lastProcessedTime = 0;
                    video.play().then(() => {
                        processUploadedVideoFrames();
                    }).catch(err => {
                        console.error('Error playing video:', err);
                        alert('Error playing video. Please try again.');
                    });
                }, { once: true });
            } else {
                video.currentTime = 0;
                lastProcessedTime = 0;
                video.play().then(() => {
                    processUploadedVideoFrames();
                }).catch(err => {
                    console.error('Error playing video:', err);
                    alert('Error playing video. Please try again.');
                });
            }
        }
        
        let lastProcessedTime = 0;
        const FRAME_PROCESS_INTERVAL = 100; // Process every 100ms (10 fps for analysis)
        
        async function processUploadedVideoFrames() {
            if (!videoAnalysisActive) return;
            
            if (videoAnalysisPaused) {
                // Check again after a short delay
                setTimeout(processUploadedVideoFrames, 100);
                return;
            }
            
            const video = document.getElementById('shotTrackerVideo');
            const canvas = document.getElementById('shotTrackerCanvas');
            const outputCanvas = document.getElementById('shotTrackerOutput');
            
            // Check if video is ready and playing
            if (!video || video.readyState < video.HAVE_CURRENT_DATA || video.paused || video.ended) {
                // If video ended, stop analysis
                if (video && video.ended && videoAnalysisActive) {
                    const statusText = document.getElementById('analysisStatusText');
                    statusText.textContent = 'Analysis complete!';
                    setTimeout(() => {
                        stopVideoAnalysis();
                    }, 2000);
                    return;
                }
                // Continue checking
                setTimeout(processUploadedVideoFrames, 100);
                return;
            }
            
            // Only process frames at intervals to avoid overwhelming the backend
            const currentTime = Date.now();
            if (currentTime - lastProcessedTime < FRAME_PROCESS_INTERVAL) {
                requestAnimationFrame(processUploadedVideoFrames);
                return;
            }
            lastProcessedTime = currentTime;
            
            try {
                const ctx = canvas.getContext('2d');
                const outputCtx = outputCanvas.getContext('2d');
                
                // Set canvas dimensions to match video
                if (canvas.width !== video.videoWidth || canvas.height !== video.videoHeight) {
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                }
                if (outputCanvas.width !== video.videoWidth || outputCanvas.height !== video.videoHeight) {
                    outputCanvas.width = video.videoWidth;
                    outputCanvas.height = video.videoHeight;
                }
                
                // Draw current video frame to canvas
                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                
                // Try backend first (YOLOv8), fallback to client-side detection
                let result = null;
                
                // Try backend first if available (uses AI-Basketball-Shot-Detection-Tracker YOLOv8)
                if (API_BASE_URL) {
                    try {
                        const response = await fetch(`${API_BASE_URL}/api/detect_shot`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ frame: canvas.toDataURL('image/jpeg', 0.7) })
                        });
                        
                        if (response.ok) {
                            const backendResult = await response.json();
                            if (backendResult.success) {
                                // Use backend result (AI-Basketball-Shot-Detection-Tracker YOLOv8 detection)
                                console.log(' Using YOLOv8 backend detection:', backendResult.tracker || 'AI-Basketball-Shot-Detection-Tracker (YOLOv8)');
                                result = {
                                    algorithm: 'yolo8',
                                    tracker: backendResult.tracker || 'AI-Basketball-Shot-Detection-Tracker (YOLOv8)',
                                    ball_detected: backendResult.ball_detected,
                                    ball_x: backendResult.ball_x,
                                    ball_y: backendResult.ball_y,
                                    ball_radius: backendResult.ball_radius,
                                    ball_box: backendResult.ball_box,  // Bounding box from YOLOv8
                                    rim_detected: backendResult.rim_detected,
                                    rim_x: backendResult.rim_x,
                                    rim_y: backendResult.rim_y,
                                    rim_radius: backendResult.rim_radius,
                                    rim_box: backendResult.rim_box,  // Bounding box from YOLOv8
                                    shot_result: backendResult.shot_result,
                                    makes: backendResult.makes || 0,
                                    attempts: backendResult.attempts || 0,
                                    confidence: (backendResult.ball_detected ? 0.9 : 0) + (backendResult.rim_detected ? 0.1 : 0),
                                    processed_frame: backendResult.processed_frame  // Frame with yellow lines, corner rectangles, shot counter
                                };
                                
                                // Update stats from backend (YOLOv8 tracker counts)
                                if (backendResult.makes !== undefined && backendResult.attempts !== undefined) {
                                    shotTrackerStats.makes = backendResult.makes;
                                    shotTrackerStats.total = backendResult.attempts;
                                    shotTrackerStats.misses = backendResult.attempts - backendResult.makes;
                                    updateShotTrackerDisplay();
                                }
                                
                                clientSideTrackerState.useBackend = true;
                            }
                        }
                    } catch (error) {
                        // Backend not available - log error and disable backend
                        console.error('Backend detection error:', error);
                        clientSideTrackerState.useBackend = false;
                    }
                }
                
                // Only use client-side if backend is completely unavailable
                // Do NOT fallback if backend exists but just didn't detect anything this frame
                if (!result && !API_BASE_URL) {
                    console.warn(' Using client-side detection (backend not configured)');
                    result = detectBallAndRimClientSide(ctx, canvas.width, canvas.height);
                    if (result) {
                        result.tracker = 'Client-side (fallback)';
                    }
                } else if (!result && API_BASE_URL) {
                    // Backend is available but didn't detect anything - that's OK, don't fallback
                    console.log('Backend active but no detection this frame (normal)');
                }
                
                // Store result for algorithm indicator
                if (result) {
                    latestDetectionResult = result;
                    updateAlgorithmIndicator();
                }
                
                if (result) {
                    // Use processed frame from ShotDetectorWeb if available (has yellow lines, corner rectangles, shot counter)
                    if (result.processed_frame) {
                        // Display the processed frame with all ShotDetectorWeb visualizations
                        const img = new Image();
                        img.onload = function() {
                            outputCtx.clearRect(0, 0, outputCanvas.width, outputCanvas.height);
                            outputCtx.drawImage(img, 0, 0, outputCanvas.width, outputCanvas.height);
                        };
                        img.src = 'data:image/jpeg;base64,' + result.processed_frame;
                    } else {
                        // Fallback: Draw detection results manually if processed_frame not available
                    outputCtx.clearRect(0, 0, outputCanvas.width, outputCanvas.height);
                    
                        // Draw ball bounding box if available (YOLOv8)
                        if (result.ball_box && result.ball_box.length === 4) {
                            const [x1, y1, x2, y2] = result.ball_box;
                            outputCtx.strokeStyle = '#00ff00';
                            outputCtx.lineWidth = 3;
                            outputCtx.strokeRect(x1, y1, x2 - x1, y2 - y1);
                            
                            // Draw label
                            outputCtx.fillStyle = '#00ff00';
                            outputCtx.font = '14px Arial';
                            outputCtx.fillText('Basketball', x1, y1 - 5);
                        } else if (result.ball_detected && result.ball_x > 0 && result.ball_y > 0) {
                            // Fallback to circle if no bounding box
                        outputCtx.strokeStyle = '#00ff00';
                        outputCtx.lineWidth = 3;
                        outputCtx.beginPath();
                        outputCtx.arc(result.ball_x, result.ball_y, Math.max(result.ball_radius, 10), 0, 2 * Math.PI);
                        outputCtx.stroke();
                        
                        // Draw ball center
                        outputCtx.fillStyle = '#00ff00';
                        outputCtx.beginPath();
                        outputCtx.arc(result.ball_x, result.ball_y, 5, 0, 2 * Math.PI);
                        outputCtx.fill();
                    }
                    
                        // Draw rim bounding box if available (YOLOv8)
                        if (result.rim_box && result.rim_box.length === 4) {
                            const [x1, y1, x2, y2] = result.rim_box;
                            outputCtx.strokeStyle = '#ff0000';
                            outputCtx.lineWidth = 3;
                            outputCtx.strokeRect(x1, y1, x2 - x1, y2 - y1);
                            
                            // Draw label
                            outputCtx.fillStyle = '#ff0000';
                            outputCtx.font = '14px Arial';
                            outputCtx.fillText('Basketball Hoop', x1, y1 - 5);
                        } else if ((result.rim_detected || result.rim_x > 0) && result.rim_y > 0) {
                            // Fallback to circle if no bounding box
                        outputCtx.strokeStyle = '#ff0000';
                        outputCtx.lineWidth = 3;
                        outputCtx.beginPath();
                        outputCtx.arc(result.rim_x, result.rim_y, Math.max(result.rim_radius, 20), 0, 2 * Math.PI);
                        outputCtx.stroke();
                        }
                    }
                    
                    // Handle shot result
                    if (result.shot_result) {
                        handleShotResult(result.shot_result);
                    }
                }
            } catch (error) {
                console.error('Error processing frame:', error);
            }
            
            // Update status with video progress
            if (videoAnalysisActive && !videoAnalysisPaused && video.duration) {
                const statusText = document.getElementById('analysisStatusText');
                const progress = ((video.currentTime / video.duration) * 100).toFixed(0);
                statusText.textContent = `Analyzing video... ${progress}%`;
            }
            
            // Continue processing
            if (videoAnalysisActive && !video.paused && !video.ended) {
                requestAnimationFrame(processUploadedVideoFrames);
            }
        }
        
        function pauseVideoAnalysis() {
            const video = document.getElementById('shotTrackerVideo');
            const pauseBtn = document.getElementById('pauseVideoAnalysis');
            const statusText = document.getElementById('analysisStatusText');
            
            if (videoAnalysisPaused) {
                videoAnalysisPaused = false;
                video.play();
                pauseBtn.textContent = 'Pause';
                statusText.textContent = 'Analyzing video...';
                processUploadedVideoFrames();
            } else {
                videoAnalysisPaused = true;
                video.pause();
                pauseBtn.textContent = 'Resume';
                statusText.textContent = 'Paused';
            }
        }
        
        function stopVideoAnalysis() {
            videoAnalysisActive = false;
            videoAnalysisPaused = false;
            
            const video = document.getElementById('shotTrackerVideo');
            const analyzeBtn = document.getElementById('analyzeUploadedVideo');
            const pauseBtn = document.getElementById('pauseVideoAnalysis');
            const statusDiv = document.getElementById('videoAnalysisStatus');
            const statusText = document.getElementById('analysisStatusText');
            
            video.pause();
            analyzeBtn.style.display = 'inline-block';
            pauseBtn.style.display = 'none';
            statusDiv.style.display = 'none';
            statusText.textContent = '';
            
            // Hide analysis indicator
            const indicator = document.getElementById('analysisIndicator');
            if (indicator) indicator.style.display = 'none';
            
            // Hide algorithm indicator
            const algoIndicator = document.getElementById('algorithmIndicator');
            if (algoIndicator) algoIndicator.style.display = 'none';
        }
        
        // Event listeners
        document.addEventListener('DOMContentLoaded', function() {
            const startBtn = document.getElementById('startShotTracker');
            const stopBtn = document.getElementById('stopShotTracker');
            const resetBtn = document.getElementById('resetShotTracker');
            const backBtn = document.getElementById('backToShotSyncFromTracker');
            const liveModeBtn = document.getElementById('shotTrackerLiveModeBtn');
            const uploadModeBtn = document.getElementById('shotTrackerUploadModeBtn');
            const videoUploadInput = document.getElementById('shotTrackerVideoUpload');
            const analyzeBtn = document.getElementById('analyzeUploadedVideo');
            const pauseBtn = document.getElementById('pauseVideoAnalysis');
            
            if (startBtn) startBtn.addEventListener('click', startShotTracker);
            if (stopBtn) stopBtn.addEventListener('click', stopShotTracker);
            if (resetBtn) resetBtn.addEventListener('click', resetShotTracker);
            if (backBtn) backBtn.addEventListener('click', () => {
                stopShotTracker();
                stopVideoAnalysis();
                showShotSync();
            });
            
            if (liveModeBtn) liveModeBtn.addEventListener('click', () => switchShotTrackerMode('live'));
            if (uploadModeBtn) uploadModeBtn.addEventListener('click', () => switchShotTrackerMode('upload'));
            
            // Handle video file upload - setup will be done in setupShotTrackerEventListeners
            // This ensures it works even when section is shown later
            
            if (analyzeBtn) analyzeBtn.addEventListener('click', analyzeUploadedVideo);
            if (pauseBtn) pauseBtn.addEventListener('click', pauseVideoAnalysis);
            
            // Handle video ended event
            const video = document.getElementById('shotTrackerVideo');
            if (video) {
                video.addEventListener('ended', () => {
                    if (videoAnalysisActive) {
                        stopVideoAnalysis();
                    }
                });
                
                video.addEventListener('play', () => {
                    if (videoAnalysisActive && !videoAnalysisPaused) {
                        lastProcessedTime = 0;
                        processUploadedVideoFrames();
                    }
                });
                
                // Also process on timeupdate for more reliable frame capture
                video.addEventListener('timeupdate', () => {
                    if (videoAnalysisActive && !videoAnalysisPaused && !video.ended) {
                        // This ensures we process frames even if requestAnimationFrame misses some
                        const now = Date.now();
                        if (now - lastProcessedTime >= FRAME_PROCESS_INTERVAL) {
                            // Trigger frame processing
                            requestAnimationFrame(processUploadedVideoFrames);
                        }
                    }
                });
            }
        });
        
        window.showShotTracker = showShotTracker;
        
        // ====================== PROGRESS PICS FUNCTIONALITY ======================
        
        // Storage key for progress pics
        const PROGRESS_PICS_STORAGE_KEY = 'shotSync_progressPics';
        
        // Escape HTML to prevent XSS
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // Load progress pics from localStorage
        function loadProgressPics() {
            const gallery = document.getElementById('progressPicsGallery');
            if (!gallery) return;
            
            const progressPics = getProgressPics();
            
            if (progressPics.length === 0) {
                gallery.innerHTML = '<p style="grid-column: 1 / -1; text-align: center; color: var(--text-gray); padding: 40px;">No progress pics yet. Upload your first photo to get started!</p>';
                return;
            }
            
            // Sort by date (newest first)
            progressPics.sort((a, b) => new Date(b.date) - new Date(a.date));
            
            gallery.innerHTML = progressPics.map((pic, index) => {
                const date = new Date(pic.date);
                const formattedDate = date.toLocaleDateString('en-US', { 
                    year: 'numeric', 
                    month: 'long', 
                    day: 'numeric' 
                });
                const formattedTime = date.toLocaleTimeString('en-US', { 
                    hour: '2-digit', 
                    minute: '2-digit' 
                });
                
                const captionDisplay = pic.caption && pic.caption.trim() ? 
                    `<div style="font-family: 'Bebas Neue', sans-serif; color: var(--text-dark); font-size: 14px; margin-top: 8px; padding-top: 8px; border-top: 1px solid #e2e8f0; font-weight: 500;">${escapeHtml(pic.caption.trim())}</div>` : '';
                
                return `
                    <div class="progress-pic-card" style="background: var(--bg-surface-light); border-radius: 12px; overflow: hidden; box-shadow: 0 2px 8px rgba(0,0,0,0.1); position: relative;">
                        <img src="${pic.dataUrl}" alt="Progress pic from ${formattedDate}" style="width: 100%; height: 250px; object-fit: cover; display: block;">
                        <div style="padding: 15px;">
                            <div style="font-weight: 600; color: var(--text-dark); margin-bottom: 5px;">${formattedDate}</div>
                            <div style="font-size: 12px; color: var(--text-gray);">${formattedTime}</div>
                            ${captionDisplay}
                        </div>
                        <button onclick="deleteProgressPic(${index})" style="position: absolute; top: 10px; right: 10px; background: rgba(255, 0, 0, 0.8); color: white; border: none; border-radius: 50%; width: 32px; height: 32px; cursor: pointer; font-size: 18px; display: flex; align-items: center; justify-content: center; transition: all 0.2s;" onmouseover="this.style.background='rgba(255, 0, 0, 1)'" onmouseout="this.style.background='rgba(255, 0, 0, 0.8)'" title="Delete photo"></button>
                    </div>
                `;
            }).join('');
        }
        
        // Get all progress pics from localStorage
        function getProgressPics() {
            try {
                const stored = localStorage.getItem(PROGRESS_PICS_STORAGE_KEY);
                return stored ? JSON.parse(stored) : [];
            } catch (e) {
                console.error('Error loading progress pics:', e);
                return [];
            }
        }
        
        // Save progress pics to localStorage
        function saveProgressPics(pics) {
            try {
                // Limit to last 100 pics to avoid localStorage size issues
                const limitedPics = pics.slice(-100);
                localStorage.setItem(PROGRESS_PICS_STORAGE_KEY, JSON.stringify(limitedPics));
            } catch (e) {
                console.error('Error saving progress pics:', e);
                if (e.name === 'QuotaExceededError') {
                    alert('Storage limit reached. Please delete some old photos to add new ones.');
                }
            }
        }
        
        // Add a new progress pic
        function addProgressPic(dataUrl, caption = '') {
            const progressPics = getProgressPics();
            progressPics.push({
                dataUrl: dataUrl,
                date: new Date().toISOString(),
                caption: caption || null
            });
            saveProgressPics(progressPics);
            loadProgressPics();
        }
        
        // Delete a progress pic
        function deleteProgressPic(index) {
            if (!confirm('Are you sure you want to delete this progress pic?')) {
                return;
            }
            
            const progressPics = getProgressPics();
            // Sort to match display order (newest first)
            progressPics.sort((a, b) => new Date(b.date) - new Date(a.date));
            progressPics.splice(index, 1);
            saveProgressPics(progressPics);
            loadProgressPics();
        }
        
        // Make deleteProgressPic available globally
        window.deleteProgressPic = deleteProgressPic;
        
        // Initialize progress pics upload handlers
        document.addEventListener('DOMContentLoaded', function() {
            const uploadInput = document.getElementById('progressPicUpload');
            const selectBtn = document.getElementById('selectProgressPicBtn');
            const previewDiv = document.getElementById('progressPicPreview');
            const previewImg = document.getElementById('previewImage');
            const saveBtn = document.getElementById('saveProgressPicBtn');
            const cancelBtn = document.getElementById('cancelProgressPicBtn');
            
            if (selectBtn && uploadInput) {
                selectBtn.addEventListener('click', () => {
                    uploadInput.click();
                });
            }
            
            if (uploadInput) {
                uploadInput.addEventListener('change', function(e) {
                    const file = e.target.files[0];
                    if (!file) return;
                    
                    // Validate file type
                    if (!file.type.startsWith('image/')) {
                        alert('Please select an image file.');
                        return;
                    }
                    
                    // Validate file size (max 5MB)
                    if (file.size > 5 * 1024 * 1024) {
                        alert('Image size must be less than 5MB. Please compress the image and try again.');
                        return;
                    }
                    
                    // Read file as data URL
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        if (previewImg) {
                            previewImg.src = e.target.result;
                        }
                        if (previewDiv) {
                            previewDiv.style.display = 'block';
                        }
                    };
                    reader.readAsDataURL(file);
                });
            }
            
            if (saveBtn) {
                saveBtn.addEventListener('click', function() {
                    const dataUrl = previewImg?.src;
                    if (dataUrl && dataUrl.startsWith('data:image/')) {
                        const captionInput = document.getElementById('progressPicCaption');
                        const caption = captionInput ? captionInput.value.trim() : '';
                        addProgressPic(dataUrl, caption);
                        // Reset form
                        if (uploadInput) uploadInput.value = '';
                        if (captionInput) captionInput.value = '';
                        if (previewDiv) previewDiv.style.display = 'none';
                        alert('Progress pic saved successfully! ');
                    }
                });
            }
            
            if (cancelBtn) {
                cancelBtn.addEventListener('click', function() {
                    if (uploadInput) uploadInput.value = '';
                    const captionInput = document.getElementById('progressPicCaption');
                    if (captionInput) captionInput.value = '';
                    if (previewDiv) previewDiv.style.display = 'none';
                });
            }
        });
        window.goToHome = goToHome;
        window.handleGoogleSignInClick = handleGoogleSignInClick;
        window.handlePlayerPageSignInClick = handlePlayerPageSignInClick;
        
        // Nutrition page variables
        let nutritionChart = null;
        let currentChartType = 'calories';
        let currentTimePeriod = 7; // Default to 7 days
        let selectedDate = null; // Currently selected date from chart click
        
        // Load nutrition data
        async function loadNutrition() {
            const user = window.firebaseAuth?.currentUser;
            if (!user) {
                alert('Please sign in to use the nutrition tracker');
                return;
            }
            
            const userId = user.uid;
            
            // Load goals
            const goals = await window.getNutritionGoals(userId);
            document.getElementById('calorieGoal').value = goals.calorieGoal || 2000;
            document.getElementById('idealWeight').value = goals.idealWeight || 150;
            document.getElementById('proteinGoal').value = goals.proteinGoal || 150;
            
            // Load favorites
            await loadFavorites(userId);
            
            // Load daily log
            await loadDailyLog(userId);
            
            // Load and render chart
            await renderNutritionChart(userId);
        }
        
        // Save nutrition goals (local function for button click)
        async function saveNutritionGoalsLocal() {
            const user = window.firebaseAuth?.currentUser;
            if (!user) {
                alert('Please sign in to save goals');
                return;
            }
            
            const calorieGoal = parseFloat(document.getElementById('calorieGoal').value);
            const idealWeight = parseFloat(document.getElementById('idealWeight').value);
            const proteinGoal = parseFloat(document.getElementById('proteinGoal').value);
            
            if (!calorieGoal || !idealWeight || !proteinGoal) {
                alert('Please enter calorie goal, ideal weight, and protein goal');
                return;
            }
            
            const success = await window.saveNutritionGoals(user.uid, calorieGoal, idealWeight, proteinGoal);
            if (success) {
                alert('Goals saved successfully!');
                await renderNutritionChart(user.uid);
            } else {
                alert('Error saving goals');
            }
        }
        
        window.saveNutritionGoalsLocal = saveNutritionGoalsLocal;
        
        // Switch nutrition chart
        async function switchNutritionChart(type) {
            currentChartType = type;
            
            // Update tab styles
            document.querySelectorAll('.chart-tab').forEach(tab => tab.classList.remove('active'));
            if (type === 'calories') {
                document.getElementById('calorieChartTab').classList.add('active');
                document.getElementById('weightEntryForm').style.display = 'none';
            } else {
                document.getElementById('weightChartTab').classList.add('active');
                document.getElementById('weightEntryForm').style.display = 'block';
            }
            
            const user = window.firebaseAuth?.currentUser;
            if (user) {
                await renderNutritionChart(user.uid);
            }
        }
        
        // Add weight entry
        async function addWeightEntry() {
            const user = window.firebaseAuth?.currentUser;
            if (!user) {
                alert('Please sign in to add weight entry');
                return;
            }
            
            const weight = parseFloat(document.getElementById('weightInput').value);
            if (!weight || weight <= 0) {
                alert('Please enter a valid weight');
                return;
            }
            
            const success = await window.saveWeightEntry(user.uid, weight);
            if (success) {
                document.getElementById('weightInput').value = '';
                await renderNutritionChart(user.uid);
            } else {
                alert('Error adding weight entry');
            }
        }
        
        window.addWeightEntry = addWeightEntry;
        
        // Switch nutrition tab (tracker vs diet plans)
        function switchNutritionTab(tab) {
            const trackerTab = document.getElementById('nutritionTrackerTab');
            const dietPlansTab = document.getElementById('customDietPlansTab');
            
            if (tab === 'tracker') {
                document.getElementById('nutritionTrackerSection').style.display = 'block';
                document.getElementById('customDietPlansSection').style.display = 'none';
                
                // Update tab styles
                trackerTab.classList.add('active');
                trackerTab.style.borderBottom = '3px solid var(--primary-color)';
                trackerTab.style.color = 'var(--primary-color)';
                trackerTab.style.fontWeight = '600';
                
                dietPlansTab.classList.remove('active');
                dietPlansTab.style.borderBottom = '3px solid transparent';
                dietPlansTab.style.color = '#666';
                dietPlansTab.style.fontWeight = 'normal';
            } else if (tab === 'dietPlans') {
                document.getElementById('nutritionTrackerSection').style.display = 'none';
                document.getElementById('customDietPlansSection').style.display = 'block';
                
                // Update tab styles
                trackerTab.classList.remove('active');
                trackerTab.style.borderBottom = '3px solid transparent';
                trackerTab.style.color = '#666';
                trackerTab.style.fontWeight = 'normal';
                
                dietPlansTab.classList.add('active');
                dietPlansTab.style.borderBottom = '3px solid var(--primary-color)';
                dietPlansTab.style.color = 'var(--primary-color)';
                dietPlansTab.style.fontWeight = '600';
                
                // Load diet plans when switching to this tab
                const user = window.firebaseAuth?.currentUser;
                if (user) {
                    loadCustomDietPlans(user.uid);
                }
            }
        }
        
        window.switchNutritionTab = switchNutritionTab;
        
        // Custom Diet Plan Functions
        let editingDietPlanId = null;
        
        async function loadCustomDietPlans(userId) {
            try {
                const dietPlans = await window.getCustomDietPlans(userId);
                const container = document.getElementById('customDietPlansList');
                
                if (!container) {
                    console.error('customDietPlansList container not found');
                    return;
                }
                
                container.innerHTML = '';
                
                if (!dietPlans || dietPlans.length === 0) {
                    container.innerHTML = '<p style="text-align: center; color: #666; padding: 40px;">No custom diet plans yet. Create one to get started!</p>';
                    return;
                }
                
                console.log('Loading diet plans:', dietPlans);
                dietPlans.forEach((plan, idx) => {
                    console.log(`Plan ${idx}:`, {
                        id: plan.id,
                        name: plan.name,
                        mealsCount: plan.meals ? plan.meals.length : 0,
                        firstMeal: plan.meals && plan.meals[0] ? {
                            name: plan.meals[0].name,
                            food: plan.meals[0].food,
                            calories: plan.meals[0].calories
                        } : null
                    });
                });
                
                dietPlans.forEach(plan => {
                // Sort meals chronologically
                const sortedMeals = sortMealsChronologically(plan.meals || []);
                
                // Calculate totals
                const totals = calculateMealsTotals(plan.meals || []);
                
                const planDiv = document.createElement('div');
                planDiv.style.cssText = 'background: #f8f9fa; padding: 20px; border-radius: 8px; margin-bottom: 15px;';
                
                // Ensure plan name is displayed correctly
                const planName = (plan.name && plan.name.trim()) ? plan.name.trim() : 'Unnamed Diet Plan';
                const planDays = plan.days && Array.isArray(plan.days) && plan.days.length > 0 ? plan.days : [];
                const daysDisplay = planDays.length > 0 ? planDays.join(', ') : 'No days selected';
                console.log(`Displaying plan: "${planName}" with ${sortedMeals.length} meals on days: ${daysDisplay}`);
                
                planDiv.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 15px;">
                        <div>
                            <h3 style="font-family: \'Courier Prime\', monospace; margin: 0 0 10px 0; color: #1a1a1a; font-weight: 700; font-size: 20px;">${planName}</h3>
                            <div style="font-family: \'Courier Prime\', monospace; color: #666; font-size: 14px; margin-bottom: 5px;">
                                <strong>Total Calories:</strong> ${Math.round(totals.calories)} | <strong>Total Protein:</strong> ${Math.round(totals.protein * 10) / 10}g
                            </div>
                            <div style="font-family: \'Courier Prime\', monospace; color: #888; font-size: 13px;">
                                <strong>Days:</strong> ${daysDisplay}
                            </div>
                        </div>
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <label style="display: flex; align-items: center; cursor: pointer; font-family: 'Bebas Neue', sans-serif; font-size: 13px; color: #666;">
                                <input type="checkbox" id="dietPlanToggle-${plan.id}" ${planDays.length > 0 ? 'checked' : ''} onchange="toggleDietPlan('${plan.id}')" style="margin-right: 6px; width: 18px; height: 18px; cursor: pointer;">
                                <span id="dietPlanToggleLabel-${plan.id}">${planDays.length > 0 ? 'ON' : 'OFF'}</span>
                            </label>
                            <button onclick="editDietPlan('${plan.id}')" class="btn btn-secondary" style="padding: 5px 15px; margin-right: 5px;">Edit</button>
                            <button onclick="deleteDietPlan('${plan.id}')" class="btn" style="padding: 5px 15px; background: #ef4444; color: white;">Delete</button>
                        </div>
                    </div>
                    <div>
                        ${sortedMeals.length > 0 ? sortedMeals.map((meal, mealIdx) => {
                            // Explicitly get name and food - don't rely on field order
                            const mealName = (meal.name && typeof meal.name === 'string') ? meal.name.trim() : 'Unnamed Meal';
                            const mealFood = (meal.food && typeof meal.food === 'string' && meal.food.trim() && meal.food !== 'null' && meal.food !== mealName) ? meal.food.trim() : '';
                            
                            console.log(`Displaying meal ${mealIdx} in plan "${planName}":`, {
                                name: mealName,
                                food: mealFood,
                                hasName: !!meal.name,
                                hasFood: !!meal.food,
                                rawMeal: meal
                            });
                            
                            const timeDisplay = meal.time ? `<span style="color: var(--primary-color); font-weight: 600;">${formatTime(meal.time)}</span> - ` : '';
                            const foodDisplay = mealFood ? `<div style="color: #666; font-size: 13px; margin-top: 6px; font-style: italic; padding-left: 4px;">${mealFood}</div>` : '';
                            
                            return `
                                <div style="padding: 12px; background: white; border-radius: 4px; margin-bottom: 8px; font-family: \'Courier Prime\', monospace; border-left: 3px solid var(--primary-color);">
                                    <div style="display: flex; justify-content: space-between; align-items: flex-start;">
                                        <div style="flex: 1;">
                                            <div style="color: var(--text-dark); font-weight: 600;">
                                                ${timeDisplay}${mealName}
                                            </div>
                                            ${foodDisplay}
                                        </div>
                                        <div style="color: #666; font-size: 14px; margin-left: 15px; white-space: nowrap;">
                                            ${Math.round(meal.calories || 0)} cal | ${Math.round((meal.protein || 0) * 10) / 10}g protein
                                        </div>
                                    </div>
                                </div>
                            `;
                        }).join('') : '<p style="text-align: center; color: #666; padding: 20px;">No meals in this plan.</p>'}
                    </div>
                `;
                container.appendChild(planDiv);
            });
            } catch (error) {
                console.error('Error loading custom diet plans:', error);
                const container = document.getElementById('customDietPlansList');
                if (container) {
                    container.innerHTML = '<p style="text-align: center; color: #ef4444; padding: 40px;">Error loading diet plans. Please try again.</p>';
                }
            }
        }
        
        function sortMealsChronologically(meals) {
            return [...meals].sort((a, b) => {
                // If both have times, sort by time
                if (a.time && b.time) {
                    return a.time.localeCompare(b.time);
                }
                // If only one has time, put it first
                if (a.time && !b.time) return -1;
                if (!a.time && b.time) return 1;
                // If neither has time, maintain original order
                return 0;
            });
        }
        
        function calculateMealsTotals(meals) {
            return meals.reduce((totals, meal) => {
                totals.calories += (meal.calories || 0);
                totals.protein += (meal.protein || 0);
                return totals;
            }, { calories: 0, protein: 0 });
        }
        
        function formatTime(timeString) {
            // Convert "HH:MM" to "HH:MM AM/PM" format
            if (!timeString) return '';
            const [hours, minutes] = timeString.split(':');
            const hour = parseInt(hours);
            const ampm = hour >= 12 ? 'PM' : 'AM';
            const displayHour = hour % 12 || 12;
            return `${displayHour}:${minutes} ${ampm}`;
        }
        
        function showCreateDietPlanForm() {
            editingDietPlanId = null;
            document.getElementById('dietPlanFormTitle').textContent = 'Create Custom Diet Plan';
            document.getElementById('dietPlanName').value = '';
            document.getElementById('dietPlanMealsList').innerHTML = '';
            // Clear all day checkboxes
            const days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
            days.forEach(day => {
                const checkbox = document.getElementById(`dietPlanDay-${day}`);
                if (checkbox) checkbox.checked = false;
            });
            document.getElementById('createDietPlanForm').style.display = 'block';
            updateDietPlanTotals();
        }
        
        // Helper functions for time conversion
        function convert12to24(hour, minute, ampm) {
            if (!hour || !minute || !ampm) return null;
            let h24 = parseInt(hour);
            if (ampm === 'PM' && h24 !== 12) {
                h24 += 12;
            } else if (ampm === 'AM' && h24 === 12) {
                h24 = 0;
            }
            return `${String(h24).padStart(2, '0')}:${String(minute).padStart(2, '0')}`;
        }
        
        function convert24to12(time24) {
            if (!time24) return { hour: '', minute: '', ampm: 'AM' };
            const [hours, minutes] = time24.split(':');
            const hour = parseInt(hours);
            const ampm = hour >= 12 ? 'PM' : 'AM';
            const hour12 = hour % 12 || 12;
            return { hour: String(hour12), minute: minutes || '00', ampm: ampm };
        }
        
        // Make helper functions available globally
        window.convert12to24 = convert12to24;
        window.convert24to12 = convert24to12;
        
        function addMealToDietPlan() {
            const container = document.getElementById('dietPlanMealsList');
            const mealId = 'meal-' + Date.now();
            const mealDiv = document.createElement('div');
            mealDiv.style.cssText = 'padding: 15px; background: #f8f9fa; border-radius: 4px; margin-bottom: 15px;';
            mealDiv.innerHTML = `
                <div style="display: grid; grid-template-columns: 2fr 0.8fr 0.8fr 0.6fr 1fr 1fr 1fr auto; gap: 10px; align-items: end; margin-bottom: 10px;">
                    <input type="text" id="${mealId}-name" placeholder="Meal name (e.g., Breakfast)" style="padding: 8px; border: 2px solid #ddd; border-radius: 4px; font-family: \'Courier Prime\', monospace;" onchange="updateDietPlanTotals()">
                    <input type="number" id="${mealId}-hour" placeholder="Hour" min="1" max="12" style="padding: 8px; border: 2px solid #ddd; border-radius: 4px; font-family: \'Courier Prime\', monospace;" onchange="updateDietPlanTotals()">
                    <input type="number" id="${mealId}-minute" placeholder="Min" min="0" max="59" step="1" style="padding: 8px; border: 2px solid #ddd; border-radius: 4px; font-family: \'Courier Prime\', monospace;" onchange="updateDietPlanTotals()">
                    <select id="${mealId}-ampm" style="padding: 8px; border: 2px solid #ddd; border-radius: 4px; font-family: \'Courier Prime\', monospace;" onchange="updateDietPlanTotals()">
                        <option value="AM">AM</option>
                        <option value="PM">PM</option>
                    </select>
                    <input type="number" id="${mealId}-calories" placeholder="Calories" min="0" style="padding: 8px; border: 2px solid #ddd; border-radius: 4px; font-family: \'Courier Prime\', monospace;" onchange="updateDietPlanTotals()" oninput="updateDietPlanTotals()">
                    <input type="number" id="${mealId}-protein" placeholder="Protein (g)" min="0" step="0.1" style="padding: 8px; border: 2px solid #ddd; border-radius: 4px; font-family: \'Courier Prime\', monospace;" onchange="updateDietPlanTotals()" oninput="updateDietPlanTotals()">
                    <input type="number" id="${mealId}-servings" placeholder="Servings" min="0.1" step="0.1" value="1" style="padding: 8px; border: 2px solid #ddd; border-radius: 4px; font-family: \'Courier Prime\', monospace;" onchange="updateDietPlanTotals()" oninput="updateDietPlanTotals()">
                    <button onclick="this.parentElement.parentElement.remove(); updateDietPlanTotals();" class="btn" style="padding: 8px 12px; background: #ef4444; color: white;">Remove</button>
                </div>
                <input type="text" id="${mealId}-food" placeholder="Food items (e.g., 2 eggs, 1 cup rice, chicken breast)" style="width: 100%; padding: 8px; border: 2px solid #ddd; border-radius: 4px; font-family: \'Courier Prime\', monospace; font-size: 13px;">
            `;
            container.appendChild(mealDiv);
        }
        
        function updateDietPlanTotals() {
            const mealDivs = document.querySelectorAll('#dietPlanMealsList > div');
            let totalCalories = 0;
            let totalProtein = 0;
            
            mealDivs.forEach(div => {
                // Extract mealId from name input
                const nameInput = div.querySelector('input[id$="-name"]');
                const mealId = nameInput ? nameInput.id.replace('-name', '') : '';
                if (!mealId) return;
                
                const caloriesInput = document.getElementById(`${mealId}-calories`);
                const proteinInput = document.getElementById(`${mealId}-protein`);
                const servingsInput = document.getElementById(`${mealId}-servings`);
                
                const calories = caloriesInput ? parseFloat(caloriesInput.value) || 0 : 0;
                const protein = proteinInput ? parseFloat(proteinInput.value) || 0 : 0;
                const servings = servingsInput ? parseFloat(servingsInput.value) || 1 : 1;
                
                totalCalories += calories * servings;
                totalProtein += protein * servings;
            });
            
            document.getElementById('dietPlanTotalCalories').textContent = Math.round(totalCalories);
            document.getElementById('dietPlanTotalProtein').textContent = Math.round(totalProtein * 10) / 10;
        }
        
        async function saveDietPlan() {
            const user = window.firebaseAuth?.currentUser;
            if (!user) {
                alert('Please sign in to save diet plan');
                return;
            }
            
            const name = document.getElementById('dietPlanName').value.trim();
            if (!name) {
                alert('Please enter a diet plan name');
                return;
            }
            
            const meals = [];
            const mealDivs = document.querySelectorAll('#dietPlanMealsList > div');
            mealDivs.forEach((div, index) => {
                // The structure is:
                // div (meal container)
                //   - div (grid row) with: name, hour, minute, ampm, calories, protein, servings, remove button
                //   - input (food field) outside the grid
                
                // Find the grid row div first
                const gridRow = div.querySelector('div[style*="grid-template-columns"]');
                if (!gridRow) {
                    console.error(`Meal ${index} - No grid row found`);
                    return;
                }
                
                // Get the name input from the grid row - it's the ONLY text input in the grid row
                // The food input is outside the grid row, so we can safely get the first text input
                const allTextInputs = gridRow.querySelectorAll('input[type="text"]');
                let nameInput = null;
                
                // Find the input that ends with "-name" (should be the only one)
                for (let input of allTextInputs) {
                    if (input.id && input.id.endsWith('-name')) {
                        nameInput = input;
                        break;
                    }
                }
                
                // Fallback: if no input with "-name" found, get the first text input (should be name)
                if (!nameInput && allTextInputs.length > 0) {
                    nameInput = allTextInputs[0];
                    console.warn(`Meal ${index} - Using first text input as name (ID doesn't end with "-name"):`, nameInput.id);
                }
                
                if (!nameInput || !nameInput.id) {
                    console.error(`Meal ${index} - Name input not found in grid row`);
                    console.error('Grid row inputs:', Array.from(gridRow.querySelectorAll('input')).map(i => ({id: i.id, type: i.type, placeholder: i.placeholder})));
                    return;
                }
                
                // Verify it's not the food field (food field ID ends with "-food")
                if (nameInput.id.endsWith('-food')) {
                    console.error(`Meal ${index} - ERROR: Found food input instead of name input! ID:`, nameInput.id);
                    return;
                }
                
                const mealId = nameInput.id.replace('-name', '');
                
                if (!mealId) {
                    console.error(`Meal ${index} - Invalid mealId from name input:`, nameInput.id);
                    return;
                }
                
                console.log(`Meal ${index} - Found name input:`, {
                    id: nameInput.id,
                    value: nameInput.value,
                    placeholder: nameInput.placeholder,
                    mealId: mealId
                });
                
                const hourInput = document.getElementById(`${mealId}-hour`);
                const minuteInput = document.getElementById(`${mealId}-minute`);
                const ampmSelect = document.getElementById(`${mealId}-ampm`);
                const caloriesInput = document.getElementById(`${mealId}-calories`);
                const proteinInput = document.getElementById(`${mealId}-protein`);
                const servingsInput = document.getElementById(`${mealId}-servings`);
                const foodInput = document.getElementById(`${mealId}-food`);
                
                if (!caloriesInput || !proteinInput) {
                    console.error(`Meal ${index} is missing required fields. mealId: ${mealId}`);
                    console.error('Found inputs:', {
                        hour: !!hourInput,
                        minute: !!minuteInput,
                        calories: !!caloriesInput,
                        protein: !!proteinInput,
                        servings: !!servingsInput,
                        food: !!foodInput
                    });
                    return;
                }
                
                let mealName = nameInput.value.trim();
                const hour = hourInput ? hourInput.value.trim() : '';
                const minute = minuteInput ? minuteInput.value.trim() : '';
                const ampm = ampmSelect ? ampmSelect.value : 'AM';
                const calories = parseFloat(caloriesInput.value);
                const protein = parseFloat(proteinInput.value);
                const servings = servingsInput ? parseFloat(servingsInput.value) || 1 : 1;
                const food = foodInput ? foodInput.value.trim() : '';
                
                // CRITICAL: Double-check that we didn't accidentally read the food field
                // If mealName matches the food value and food is not empty, something is wrong
                if (food && mealName === food && nameInput.id.endsWith('-name')) {
                    console.error(`CRITICAL ERROR: Meal ${index} - Meal name appears to be the food value!`);
                    console.error('Name input ID:', nameInput.id);
                    console.error('Name input value:', mealName);
                    console.error('Food input value:', food);
                    // Don't use the food as name - set mealName to empty or a default
                    mealName = '';
                }
                
                // Convert 12-hour to 24-hour format
                const time24 = (hour && minute && ampm) ? convert12to24(hour, minute, ampm) : null;
                
                // Debug logging
                console.log(`Meal ${index}:`, {
                    mealId: mealId,
                    nameInputId: nameInput.id,
                    nameInputValue: nameInput.value,
                    mealName: mealName,
                    foodInputId: foodInput ? foodInput.id : 'not found',
                    foodValue: food,
                    calories: calories,
                    protein: protein,
                    nameEndsWithName: nameInput.id.endsWith('-name'),
                    nameEndsWithFood: nameInput.id.endsWith('-food')
                });
                
                // Validate that mealName is not the same as food (to catch mix-ups)
                if (mealName === food && mealName) {
                    console.warn(`WARNING: Meal ${index} name and food are the same! This might indicate a bug.`);
                    console.warn('This could mean the wrong input field was read. Check the IDs above.');
                }
                
                if (mealName && !isNaN(calories) && !isNaN(protein)) {
                    const mealData = {
                        name: mealName,
                        time: time24,
                        food: food || null,
                        calories: calories * servings,
                        protein: protein * servings
                    };
                    console.log('Saving meal:', mealData);
                    meals.push(mealData);
                } else {
                    console.warn(`Skipping meal ${index} - missing required fields:`, { mealName, calories, protein });
                }
            });
            
            console.log('Total meals to save:', meals.length);
            console.log('Diet plan name:', name);
            
            if (meals.length === 0) {
                alert('Please add at least one meal');
                return;
            }
            
            // Validate the data before saving
            console.log('Validating diet plan data before save:');
            console.log('Plan name:', name);
            console.log('Number of meals:', meals.length);
            meals.forEach((meal, idx) => {
                console.log(`  Meal ${idx}:`, {
                    name: meal.name,
                    food: meal.food,
                    hasName: !!meal.name,
                    hasFood: !!meal.food,
                    nameLength: meal.name ? meal.name.length : 0,
                    foodLength: meal.food ? meal.food.length : 0
                });
            });
            
            // Get selected days
            const selectedDays = [];
            const days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
            days.forEach(day => {
                const checkbox = document.getElementById(`dietPlanDay-${day}`);
                if (checkbox && checkbox.checked) {
                    selectedDays.push(day);
                }
            });
            
            const dietPlanData = { name: name.trim(), meals, days: selectedDays };
            console.log('Full diet plan data to save:', JSON.stringify(dietPlanData, null, 2));
            
            try {
                let success = false;
                if (editingDietPlanId) {
                    console.log('Updating existing diet plan:', editingDietPlanId);
                    success = await window.updateCustomDietPlan(editingDietPlanId, dietPlanData);
                } else {
                    console.log('Creating new diet plan');
                    success = await window.saveCustomDietPlan(user.uid, dietPlanData);
                }
                
                if (success) {
                    console.log('Diet plan saved successfully!');
                    document.getElementById('createDietPlanForm').style.display = 'none';
                    // Clear the form
                    document.getElementById('dietPlanName').value = '';
                    document.getElementById('dietPlanMealsList').innerHTML = '';
                    await loadCustomDietPlans(user.uid);
                } else {
                    alert('Error saving diet plan. Please check the console for details.');
                }
            } catch (error) {
                console.error('Error saving diet plan:', error);
                alert('Error saving diet plan: ' + (error.message || 'Unknown error'));
            }
        }
        
        async function editDietPlan(dietPlanId) {
            const user = window.firebaseAuth?.currentUser;
            if (!user) return;
            
            const dietPlans = await window.getCustomDietPlans(user.uid);
            const dietPlan = dietPlans.find(p => p.id === dietPlanId);
            if (!dietPlan) return;
            
            editingDietPlanId = dietPlanId;
            document.getElementById('dietPlanFormTitle').textContent = 'Edit Custom Diet Plan';
            document.getElementById('dietPlanName').value = dietPlan.name || '';
            document.getElementById('dietPlanMealsList').innerHTML = '';
            
            // Set day checkboxes
            const days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
            const planDays = dietPlan.days && Array.isArray(dietPlan.days) ? dietPlan.days : [];
            days.forEach(day => {
                const checkbox = document.getElementById(`dietPlanDay-${day}`);
                if (checkbox) {
                    checkbox.checked = planDays.includes(day);
                }
            });
            
            dietPlan.meals.forEach(meal => {
                const mealId = 'meal-' + Date.now() + '-' + Math.random();
                const mealDiv = document.createElement('div');
                mealDiv.style.cssText = 'padding: 15px; background: #f8f9fa; border-radius: 4px; margin-bottom: 15px;';
                
                // Calculate per-serving values (default to 1 serving if not stored)
                const servings = meal.servings || 1;
                const caloriesPerServing = meal.calories / servings;
                const proteinPerServing = meal.protein / servings;
                
                // Convert 24-hour time to 12-hour format for display
                const time12 = convert24to12(meal.time || '');
                
                mealDiv.innerHTML = `
                    <div style="display: grid; grid-template-columns: 2fr 0.8fr 0.8fr 0.6fr 1fr 1fr 1fr auto; gap: 10px; align-items: end; margin-bottom: 10px;">
                        <input type="text" id="${mealId}-name" value="${meal.name || ''}" style="padding: 8px; border: 2px solid #ddd; border-radius: 4px; font-family: \'Courier Prime\', monospace;" onchange="updateDietPlanTotals()">
                        <input type="number" id="${mealId}-hour" value="${time12.hour}" placeholder="Hour" min="1" max="12" style="padding: 8px; border: 2px solid #ddd; border-radius: 4px; font-family: \'Courier Prime\', monospace;" onchange="updateDietPlanTotals()">
                        <input type="number" id="${mealId}-minute" value="${time12.minute}" placeholder="Min" min="0" max="59" step="1" style="padding: 8px; border: 2px solid #ddd; border-radius: 4px; font-family: \'Courier Prime\', monospace;" onchange="updateDietPlanTotals()">
                        <select id="${mealId}-ampm" style="padding: 8px; border: 2px solid #ddd; border-radius: 4px; font-family: \'Courier Prime\', monospace;" onchange="updateDietPlanTotals()">
                            <option value="AM" ${time12.ampm === 'AM' ? 'selected' : ''}>AM</option>
                            <option value="PM" ${time12.ampm === 'PM' ? 'selected' : ''}>PM</option>
                        </select>
                        <input type="number" id="${mealId}-calories" value="${caloriesPerServing}" placeholder="Calories" min="0" style="padding: 8px; border: 2px solid #ddd; border-radius: 4px; font-family: \'Courier Prime\', monospace;" onchange="updateDietPlanTotals()" oninput="updateDietPlanTotals()">
                        <input type="number" id="${mealId}-protein" value="${proteinPerServing}" placeholder="Protein (g)" min="0" step="0.1" style="padding: 8px; border: 2px solid #ddd; border-radius: 4px; font-family: \'Courier Prime\', monospace;" onchange="updateDietPlanTotals()" oninput="updateDietPlanTotals()">
                        <input type="number" id="${mealId}-servings" value="${servings}" placeholder="Servings" min="0.1" step="0.1" style="padding: 8px; border: 2px solid #ddd; border-radius: 4px; font-family: \'Courier Prime\', monospace;" onchange="updateDietPlanTotals()" oninput="updateDietPlanTotals()">
                        <button onclick="this.parentElement.parentElement.remove(); updateDietPlanTotals();" class="btn" style="padding: 8px 12px; background: #ef4444; color: white;">Remove</button>
                    </div>
                    <input type="text" id="${mealId}-food" value="${meal.food || ''}" placeholder="Food items (e.g., 2 eggs, 1 cup rice, chicken breast)" style="width: 100%; padding: 8px; border: 2px solid #ddd; border-radius: 4px; font-family: \'Courier Prime\', monospace; font-size: 13px;">
                `;
                document.getElementById('dietPlanMealsList').appendChild(mealDiv);
            });
            
            document.getElementById('createDietPlanForm').style.display = 'block';
            updateDietPlanTotals();
        }
        
        async function deleteDietPlan(dietPlanId) {
            if (!confirm('Are you sure you want to delete this diet plan?')) return;
            
            const success = await window.deleteCustomDietPlan(dietPlanId);
            if (success) {
                const user = window.firebaseAuth?.currentUser;
                if (user) await loadCustomDietPlans(user.uid);
            } else {
                alert('Error deleting diet plan');
            }
        }
        
        window.showCreateDietPlanForm = showCreateDietPlanForm;
        window.addMealToDietPlan = addMealToDietPlan;
        window.updateDietPlanTotals = updateDietPlanTotals;
        window.saveDietPlan = saveDietPlan;
        window.editDietPlan = editDietPlan;
        window.deleteDietPlan = deleteDietPlan;
        
        // Toggle diet plan on/off
        async function toggleDietPlan(planId) {
            const user = window.firebaseAuth?.currentUser;
            if (!user) return;
            
            const dietPlans = await window.getCustomDietPlans(user.uid);
            const plan = dietPlans.find(p => p.id === planId);
            if (!plan) return;
            
            const checkbox = document.getElementById(`dietPlanToggle-${planId}`);
            const label = document.getElementById(`dietPlanToggleLabel-${planId}`);
            
            let newDays = [];
            if (checkbox.checked) {
                // Turning ON: if no days were set, default to all days
                if (!plan.days || plan.days.length === 0) {
                    newDays = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
                } else {
                    newDays = plan.days; // Keep existing days
                }
                label.textContent = 'ON';
            } else {
                // Turning OFF: clear days (store previous days in a hidden field for potential restore)
                newDays = [];
                label.textContent = 'OFF';
            }
            
            // Update only the days field
            const success = await window.updateCustomDietPlan(planId, {
                name: plan.name,
                meals: plan.meals,
                days: newDays
            });
            
            if (success) {
                await loadCustomDietPlans(user.uid);
                // Reload schedule if we're on that tab
                const user2 = window.firebaseAuth?.currentUser;
                if (user2) await loadWeeklySchedule(user2.uid);
            }
        }
        
        window.toggleDietPlan = toggleDietPlan;
        
        // Switch time period
        async function switchTimePeriod(days, buttonElement) {
            currentTimePeriod = days;
            
            // Update tab styles
            document.querySelectorAll('.period-tab').forEach(tab => tab.classList.remove('active'));
            if (buttonElement) {
                buttonElement.classList.add('active');
            } else {
                // Fallback: find button by data-days attribute
                const button = document.querySelector(`.period-tab[data-days="${days}"]`);
                if (button) button.classList.add('active');
            }
            
            const user = window.firebaseAuth?.currentUser;
            if (user) {
                await renderNutritionChart(user.uid);
            }
        }
        
        // Render nutrition chart
        async function renderNutritionChart(userId) {
            const ctx = document.getElementById('nutritionChart').getContext('2d');
            
            if (nutritionChart) {
                nutritionChart.destroy();
            }
            
            // Calculate date range based on current time period
            const endDate = new Date();
            endDate.setHours(23, 59, 59, 999); // End of today
            const startDate = new Date();
            startDate.setDate(startDate.getDate() - currentTimePeriod);
            startDate.setHours(0, 0, 0, 0); // Start of day
            
            if (currentChartType === 'calories') {
                // Load calorie data
                const entries = await window.getAllNutritionEntries(userId);
                const goals = await window.getNutritionGoals(userId);
                const calorieGoal = goals.calorieGoal || 2000;
                
                // Group by date and sum calories, filtering by time period
                // Calculate total calories: servings  calories per serving
                const dailyCalories = {};
                entries.forEach(entry => {
                    const entryDate = entry.createdAt?.toDate ? entry.createdAt.toDate() : new Date();
                    // Filter by time period
                    if (entryDate >= startDate && entryDate <= endDate) {
                        const date = entryDate.toDateString();
                        if (!dailyCalories[date]) {
                            dailyCalories[date] = 0;
                        }
                        // Calculate total: multiply servings  calories per serving
                        const caloriesPerServing = entry.caloriesPerServing !== undefined 
                            ? entry.caloriesPerServing 
                            : (entry.servings > 0 ? entry.calories / entry.servings : entry.calories);
                        const totalCalories = caloriesPerServing * (entry.servings || 1);
                        dailyCalories[date] += totalCalories;
                    }
                });
                
                // Sort dates chronologically (oldest to newest)
                const dates = Object.keys(dailyCalories).sort((a, b) => {
                    return new Date(a) - new Date(b);
                });
                const calories = dates.map(date => dailyCalories[date]);
                
                // Store date mapping for onClick handler
                const dateLabels = dates.map(d => new Date(d).toLocaleDateString('en-US', { month: 'short', day: 'numeric' }));
                
                nutritionChart = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: dateLabels,
                        datasets: [{
                            label: 'Daily Calories',
                            data: calories,
                            borderColor: '#3b82f6',
                            backgroundColor: 'rgba(59, 130, 246, 0.7)',
                            borderWidth: 0,
                            borderRadius: 4,
                            borderSkipped: false,
                            categoryPercentage: 0.6,
                            barPercentage: 0.8
                        }, {
                            label: 'Calorie Goal',
                            data: dates.map(() => calorieGoal),
                            borderColor: '#ef4444',
                            backgroundColor: 'transparent',
                            borderDash: [8, 4],
                            borderWidth: 2.5,
                            type: 'line',
                            spanGaps: true,
                            pointRadius: 0,
                            pointHoverRadius: 0,
                            pointBorderWidth: 0,
                            fill: false,
                            tension: 0,
                            order: 0
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: true,
                        layout: {
                            padding: {
                                top: 10,
                                bottom: 10,
                                left: 10,
                                right: 10
                            }
                        },
                        plugins: {
                            legend: {
                                display: true,
                                position: 'top',
                                labels: {
                                    usePointStyle: true,
                                    padding: 15,
                                    font: {
                                        size: 12,
                                        family: "'Inter', sans-serif"
                                    }
                                }
                            },
                            title: {
                                display: true,
                                text: 'Daily Calorie Intake',
                                font: {
                                    family: "'Inter', sans-serif",
                                    size: 18,
                                    weight: '600'
                                },
                                padding: {
                                    bottom: 20
                                },
                                color: '#1f2937'
                            },
                            tooltip: {
                                backgroundColor: 'rgba(0, 0, 0, 0.8)',
                                padding: 12,
                                cornerRadius: 8,
                                titleFont: {
                                    size: 13,
                                    weight: '600'
                                },
                                bodyFont: {
                                    size: 12
                                },
                                displayColors: true
                            }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                max: Math.max(calorieGoal * 1.3, Math.max(...calories, calorieGoal) * 1.2),
                                title: {
                                    display: true,
                                    text: 'Calories',
                                    font: {
                                        size: 12,
                                        weight: '600',
                                        family: "'Inter', sans-serif"
                                    },
                                    color: '#4b5563',
                                    padding: {
                                        top: 10,
                                        bottom: 0
                                    }
                                },
                                grid: {
                                    color: 'rgba(0, 0, 0, 0.05)',
                                    drawBorder: false
                                },
                                ticks: {
                                    font: {
                                        size: 11,
                                        family: "'Inter', sans-serif"
                                    },
                                    color: '#6b7280',
                                    padding: 8
                                }
                            },
                            x: {
                                offset: false,
                                grid: {
                                    display: false,
                                    drawBorder: false
                                },
                                ticks: {
                                    font: {
                                        size: 11,
                                        family: "'Inter', sans-serif"
                                    },
                                    color: '#6b7280',
                                    padding: 10
                                }
                            }
                        },
                        interaction: {
                            intersect: false,
                            mode: 'index'
                        },
                        onClick: (event, elements) => {
                            if (elements.length > 0) {
                                const element = elements[0];
                                const datasetIndex = element.datasetIndex;
                                const index = element.index;
                                
                                // Only handle clicks on the bar dataset (not the goal line)
                                if (datasetIndex === 0 && dates[index]) {
                                    const clickedDateString = dates[index];
                                    selectedDate = clickedDateString;
                                    const user = window.firebaseAuth?.currentUser;
                                    if (user) {
                                        loadDailyLog(user.uid, clickedDateString);
                                        // Scroll to food log section
                                        const foodLogSection = document.querySelector('#dailyFoodLog').closest('div');
                                        if (foodLogSection) {
                                            foodLogSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
                                            // Highlight briefly
                                            foodLogSection.style.transition = 'box-shadow 0.3s ease';
                                            foodLogSection.style.boxShadow = '0 4px 16px rgba(239, 68, 68, 0.3)';
                                            setTimeout(() => {
                                                foodLogSection.style.boxShadow = '0 2px 8px rgba(0,0,0,0.1)';
                                            }, 2000);
                                        }
                                    }
                                }
                            }
                        }
                    }
                });
            } else {
                // Load weight data
                const entries = await window.getWeightEntries(userId);
                const goals = await window.getNutritionGoals(userId);
                const idealWeight = goals.idealWeight || 150;
                
                // Filter entries by time period and sort by date (oldest to newest)
                const filteredEntries = entries.filter(entry => {
                    const entryDate = entry.createdAt?.toDate ? entry.createdAt.toDate() : new Date();
                    return entryDate >= startDate && entryDate <= endDate;
                });
                
                const sortedEntries = filteredEntries.sort((a, b) => {
                    const dateA = a.createdAt?.toDate ? a.createdAt.toDate() : new Date();
                    const dateB = b.createdAt?.toDate ? b.createdAt.toDate() : new Date();
                    return dateA - dateB;
                });
                
                const dates = sortedEntries.map(e => {
                    const date = e.createdAt?.toDate ? e.createdAt.toDate() : new Date();
                    return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                });
                const weights = sortedEntries.map(e => e.weight);
                
                nutritionChart = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: dates,
                        datasets: [{
                            label: 'Weight (lbs)',
                            data: weights,
                            borderColor: '#10b981',
                            backgroundColor: 'rgba(16, 185, 129, 0.7)',
                            borderWidth: 0,
                            borderRadius: 4,
                            borderSkipped: false,
                            categoryPercentage: 0.6,
                            barPercentage: 0.8
                        }, {
                            label: 'Ideal Weight',
                            data: dates.map(() => idealWeight),
                            borderColor: '#ef4444',
                            backgroundColor: 'transparent',
                            borderDash: [8, 4],
                            borderWidth: 2.5,
                            type: 'line',
                            spanGaps: true,
                            pointRadius: 0,
                            pointHoverRadius: 0,
                            pointBorderWidth: 0,
                            fill: false,
                            tension: 0,
                            order: 0
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: true,
                        layout: {
                            padding: {
                                top: 10,
                                bottom: 10,
                                left: 10,
                                right: 10
                            }
                        },
                        plugins: {
                            legend: {
                                display: true,
                                position: 'top',
                                labels: {
                                    usePointStyle: true,
                                    padding: 15,
                                    font: {
                                        size: 12,
                                        family: "'Inter', sans-serif"
                                    }
                                }
                            },
                            title: {
                                display: true,
                                text: 'Weight Tracking',
                                font: {
                                    family: "'Inter', sans-serif",
                                    size: 18,
                                    weight: '600'
                                },
                                padding: {
                                    bottom: 20
                                },
                                color: '#1f2937'
                            },
                            tooltip: {
                                backgroundColor: 'rgba(0, 0, 0, 0.8)',
                                padding: 12,
                                cornerRadius: 8,
                                titleFont: {
                                    size: 13,
                                    weight: '600'
                                },
                                bodyFont: {
                                    size: 12
                                },
                                displayColors: true
                            }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                max: Math.max(idealWeight * 1.3, Math.max(...weights, idealWeight) * 1.2),
                                title: {
                                    display: true,
                                    text: 'Weight (lbs)',
                                    font: {
                                        size: 12,
                                        weight: '600',
                                        family: "'Inter', sans-serif"
                                    },
                                    color: '#4b5563',
                                    padding: {
                                        top: 10,
                                        bottom: 0
                                    }
                                },
                                grid: {
                                    color: 'rgba(0, 0, 0, 0.05)',
                                    drawBorder: false
                                },
                                ticks: {
                                    font: {
                                        size: 11,
                                        family: "'Inter', sans-serif"
                                    },
                                    color: '#6b7280',
                                    padding: 8
                                }
                            },
                            x: {
                                offset: false,
                                grid: {
                                    display: false,
                                    drawBorder: false
                                },
                                ticks: {
                                    font: {
                                        size: 11,
                                        family: "'Inter', sans-serif"
                                    },
                                    color: '#6b7280',
                                    padding: 10
                                }
                            }
                        },
                        interaction: {
                            intersect: false,
                            mode: 'index'
                        }
                    }
                });
            }
        }
        
        // Add food entry
        async function addFood() {
            const user = window.firebaseAuth?.currentUser;
            if (!user) {
                alert('Please sign in to add food');
                return;
            }
            
            const name = document.getElementById('foodName').value.trim();
            const servings = parseFloat(document.getElementById('foodServings').value);
            const calories = parseFloat(document.getElementById('foodCalories').value);
            const protein = parseFloat(document.getElementById('foodProtein').value);
            
            if (!name || !servings || !calories || protein === undefined) {
                alert('Please fill in all fields');
                return;
            }
            
            // Store per-serving values in database
            // We'll multiply by servings when calculating daily totals
            const foodData = {
                foodName: name,
                servings: servings,
                caloriesPerServing: calories,  // Calories per serving (not multiplied)
                proteinPerServing: protein,     // Protein per serving (not multiplied)
                // Also store totals for chart calculations
                calories: calories * servings,  // Total calories (for chart)
                protein: protein * servings     // Total protein (for chart)
            };
            
            const success = await window.saveFoodEntry(user.uid, foodData);
            if (success) {
                // Clear form
                document.getElementById('foodName').value = '';
                document.getElementById('foodServings').value = '';
                document.getElementById('foodCalories').value = '';
                document.getElementById('foodProtein').value = '';
                
                // Reload log and chart
                await loadDailyLog(user.uid);
                await renderNutritionChart(user.uid);
            } else {
                alert('Error adding food');
            }
        }
        
        // Add favorite food
        async function addFavorite() {
            const user = window.firebaseAuth?.currentUser;
            if (!user) {
                alert('Please sign in to add favorites');
                return;
            }
            
            const name = document.getElementById('favoriteFoodName').value.trim();
            const calories = parseFloat(document.getElementById('favoriteCalories').value);
            const protein = parseFloat(document.getElementById('favoriteProtein').value);
            
            if (!name || !calories || protein === undefined) {
                alert('Please fill in all fields');
                return;
            }
            
            const favoriteData = {
                name: name,
                caloriesPerServing: calories,
                proteinPerServing: protein
            };
            
            const success = await window.saveFavoriteFood(user.uid, favoriteData);
            if (success) {
                // Clear form
                document.getElementById('favoriteFoodName').value = '';
                document.getElementById('favoriteCalories').value = '';
                document.getElementById('favoriteProtein').value = '';
                
                // Reload favorites
                await loadFavorites(user.uid);
            } else {
                alert('Error saving favorite');
            }
        }
        
        // Load favorites
        async function loadFavorites(userId) {
            const favorites = await window.getFavoriteFoods(userId);
            const container = document.getElementById('favoritesList');
            container.innerHTML = '';
            
            if (favorites.length === 0) {
                container.innerHTML = '<p style="text-align: center; color: #666; padding: 20px;">No favorites yet. Add some above!</p>';
                return;
            }
            
            favorites.forEach((favorite, index) => {
                // Use index to create unique ID to avoid issues with special characters in food names
                const favoriteId = `fav-${index}`;
                const favoriteEntry = document.createElement('div');
                favoriteEntry.className = 'food-log-entry';
                favoriteEntry.style.background = '#f8f9fa';
                favoriteEntry.innerHTML = `
                    <div><strong>${favorite.name}</strong></div>
                    <div>
                        Servings: <input type="number" id="${favoriteId}" value="1" step="0.25" min="0" style="width: 80px; padding: 5px; border: 2px solid #ddd; border-radius: 4px; font-family: 'Bebas Neue', sans-serif;">
                    </div>
                    <div>Calories per serving: ${favorite.caloriesPerServing}</div>
                    <div>Protein per serving: ${favorite.proteinPerServing}g</div>
                    <div>
                        <button onclick="addFavoriteFoodById('${favoriteId}', '${favorite.name.replace(/'/g, "\\'")}', ${favorite.caloriesPerServing}, ${favorite.proteinPerServing})" class="btn" style="padding: 5px 15px; margin-right: 5px; background: #6b7280; color: white;">Add</button>
                        <button onclick="deleteFavoriteFoodById('${favorite.name.replace(/'/g, "\\'")}')" class="btn" style="padding: 5px 15px; background: #ef4444; color: white;">Delete</button>
                    </div>
                `;
                container.appendChild(favoriteEntry);
            });
        }
        
        // Delete favorite food (local function for button click)
        async function deleteFavoriteFoodById(favoriteName) {
            const user = window.firebaseAuth?.currentUser;
            if (!user) {
                alert('Please sign in to delete favorites');
                return;
            }
            
            if (!confirm(`Are you sure you want to delete "${favoriteName}" from favorites?`)) {
                return;
            }
            
            const success = await window.deleteFavoriteFood(user.uid, favoriteName);
            if (success) {
                await loadFavorites(user.uid);
            } else {
                alert('Error deleting favorite');
            }
        }
        
        window.deleteFavoriteFoodById = deleteFavoriteFoodById;
        
        // Add favorite food with servings (by ID)
        async function addFavoriteFoodById(favoriteId, name, caloriesPerServing, proteinPerServing) {
            const user = window.firebaseAuth?.currentUser;
            if (!user) return;
            
            const servingsInput = document.getElementById(favoriteId);
            const servings = parseFloat(servingsInput.value) || 1;
            
            // Store per-serving values, and also calculate totals for chart
            const totalCalories = caloriesPerServing * servings;
            const totalProtein = proteinPerServing * servings;
            
            const foodData = {
                foodName: name,
                servings: servings,
                caloriesPerServing: caloriesPerServing,  // Store per-serving values
                proteinPerServing: proteinPerServing,    // Store per-serving values
                calories: totalCalories,  // Total calories (for chart calculations)
                protein: totalProtein      // Total protein (for chart calculations)
            };
            
            const success = await window.saveFoodEntry(user.uid, foodData);
            if (success) {
                servingsInput.value = '1';  // Reset to 1 instead of empty
                await loadDailyLog(user.uid);
                await renderNutritionChart(user.uid);
            }
        }
        
        // Legacy function for backwards compatibility
        async function addFavoriteFood(name, caloriesPerServing, proteinPerServing) {
            // Try to find the input by searching for it
            const inputs = document.querySelectorAll('input[type="number"]');
            for (const input of inputs) {
                if (input.id && input.id.startsWith('fav-')) {
                    const entry = input.closest('.food-log-entry');
                    if (entry && entry.querySelector('strong').textContent === name) {
                        await addFavoriteFoodById(input.id, name, caloriesPerServing, proteinPerServing);
                        return;
                    }
                }
            }
        }
        
        // Load daily food log
        async function loadDailyLog(userId, targetDate = null) {
            const container = document.getElementById('dailyFoodLog');
            const titleEl = document.getElementById('foodLogTitle');
            container.innerHTML = '';
            
            // Use targetDate if provided, otherwise use today or selectedDate
            const dateToLoad = targetDate || selectedDate || new Date().toDateString();
            
            // Update title based on date
            if (titleEl) {
                const dateObj = new Date(dateToLoad);
                const today = new Date().toDateString();
                const yesterday = new Date();
                yesterday.setDate(yesterday.getDate() - 1);
                
                if (dateToLoad === today) {
                    titleEl.textContent = "Today's Food Log";
                } else if (dateToLoad === yesterday.toDateString()) {
                    titleEl.textContent = "Yesterday's Food Log";
                } else {
                    titleEl.textContent = dateObj.toLocaleDateString('en-US', { weekday: 'long', month: 'long', day: 'numeric', year: 'numeric' }) + " Food Log";
                }
            }
            
            // Get entries for the specific date
            const entries = await window.getNutritionEntries(userId, dateToLoad);
            
            if (entries.length === 0) {
                const dateObj = new Date(dateToLoad);
                const today = new Date().toDateString();
                if (dateToLoad === today) {
                    container.innerHTML = '<p style="text-align: center; color: #666; padding: 20px;">No food entries for today</p>';
                } else {
                    container.innerHTML = `<p style="text-align: center; color: #666; padding: 20px;">No food entries for ${dateObj.toLocaleDateString('en-US', { month: 'long', day: 'numeric', year: 'numeric' })}</p>`;
                }
            } else {
                entries.forEach(entry => {
                    const entryDiv = document.createElement('div');
                    entryDiv.className = 'food-log-entry';
                    entryDiv.id = `entry-${entry.id}`;
                    
                    // Display per-serving values in the log (not multiplied)
                    // Calculate per-serving from stored data
                    const caloriesPerServing = entry.caloriesPerServing !== undefined 
                        ? entry.caloriesPerServing 
                        : (entry.servings > 0 ? entry.calories / entry.servings : entry.calories);
                    const proteinPerServing = entry.proteinPerServing !== undefined 
                        ? entry.proteinPerServing 
                        : (entry.servings > 0 ? entry.protein / entry.servings : entry.protein);
                    
                    entryDiv.innerHTML = `
                        <div><strong>${entry.foodName}</strong></div>
                        <div>Servings: <span id="servings-${entry.id}">${entry.servings}</span></div>
                        <div>Calories: <span id="calories-${entry.id}">${caloriesPerServing.toFixed(0)}</span></div>
                        <div>Protein: <span id="protein-${entry.id}">${proteinPerServing.toFixed(1)}g</span></div>
                        <div>
                            <button onclick="editFoodEntry('${entry.id}')" class="btn btn-secondary" style="padding: 5px 15px; margin-right: 5px;">Edit</button>
                            <button onclick="deleteFoodEntry('${entry.id}')" class="btn" style="padding: 5px 15px; background: #ef4444; color: white;">Delete</button>
                        </div>
                    `;
                    container.appendChild(entryDiv);
                });
            }
            
            // Calculate and display totals
            // Multiply servings  calories per serving and servings  protein per serving for daily totals
            const totalCalories = entries.reduce((sum, e) => {
                const caloriesPerServing = e.caloriesPerServing !== undefined 
                    ? e.caloriesPerServing 
                    : (e.servings > 0 ? e.calories / e.servings : e.calories);
                return sum + (caloriesPerServing * (e.servings || 1));
            }, 0);
            
            const totalProtein = entries.reduce((sum, e) => {
                const proteinPerServing = e.proteinPerServing !== undefined 
                    ? e.proteinPerServing 
                    : (e.servings > 0 ? e.protein / e.servings : e.protein);
                return sum + (proteinPerServing * (e.servings || 1));
            }, 0);
            
            const goals = await window.getNutritionGoals(userId);
            const calorieGoal = goals.calorieGoal || 2000;
            const proteinGoal = goals.proteinGoal || 150;
            
            const totalsContainer = document.getElementById('dailyTotals');
            totalsContainer.innerHTML = `
                <div style="text-align: center;">
                    <div style="font-size: 24px; font-weight: 700; color: #333; font-family: 'Bebas Neue', sans-serif;">${totalCalories.toFixed(0)}</div>
                    <div style="color: #666; font-size: 14px;">Calories</div>
                    <div style="color: ${totalCalories > calorieGoal ? '#ef4444' : '#10b981'}; font-size: 12px; margin-top: 5px;">
                        ${totalCalories > calorieGoal ? `+${(totalCalories - calorieGoal).toFixed(0)} over goal` : `${(calorieGoal - totalCalories).toFixed(0)} remaining`}
                    </div>
                </div>
                <div style="text-align: center;">
                    <div style="font-size: 24px; font-weight: 700; color: #333; font-family: 'Bebas Neue', sans-serif;">${totalProtein.toFixed(1)}g</div>
                    <div style="color: #666; font-size: 14px;">Protein</div>
                    <div style="color: ${totalProtein > proteinGoal ? '#ef4444' : '#10b981'}; font-size: 12px; margin-top: 5px;">
                        ${totalProtein > proteinGoal ? `+${(totalProtein - proteinGoal).toFixed(1)}g over goal` : `${(proteinGoal - totalProtein).toFixed(1)}g remaining`}
                    </div>
                </div>
            `;
        }
        
        // Edit food entry
        function editFoodEntry(entryId) {
            const entryDiv = document.getElementById(`entry-${entryId}`);
            entryDiv.classList.add('editing');
            
            const servings = parseFloat(document.getElementById(`servings-${entryId}`).textContent);
            // These are already per-serving values in the display
            const caloriesPerServing = parseFloat(document.getElementById(`calories-${entryId}`).textContent);
            const proteinPerServing = parseFloat(document.getElementById(`protein-${entryId}`).textContent.replace('g', ''));
            const foodName = entryDiv.querySelector('strong').textContent;
            
            entryDiv.innerHTML = `
                <div><strong>${foodName}</strong></div>
                <div>
                    Servings: <input type="number" id="edit-servings-${entryId}" value="${servings}" step="0.25" min="0" style="width: 80px; padding: 5px; border: 2px solid #ddd; border-radius: 4px;">
                </div>
                <div>
                    Calories per serving: <input type="number" id="edit-calories-${entryId}" value="${caloriesPerServing.toFixed(0)}" min="0" style="width: 80px; padding: 5px; border: 2px solid #ddd; border-radius: 4px;">
                </div>
                <div>
                    Protein per serving (g): <input type="number" id="edit-protein-${entryId}" value="${proteinPerServing.toFixed(1)}" min="0" step="0.1" style="width: 80px; padding: 5px; border: 2px solid #ddd; border-radius: 4px;">
                </div>
                <div>
                    <button onclick="saveFoodEdit('${entryId}')" class="btn btn-primary" style="padding: 5px 15px; margin-right: 5px;">Save</button>
                    <button onclick="cancelFoodEdit('${entryId}')" class="btn btn-secondary" style="padding: 5px 15px;">Cancel</button>
                </div>
            `;
        }
        
        // Save food edit
        async function saveFoodEdit(entryId) {
            const user = window.firebaseAuth?.currentUser;
            if (!user) return;
            
            const servings = parseFloat(document.getElementById(`edit-servings-${entryId}`).value);
            const caloriesPerServing = parseFloat(document.getElementById(`edit-calories-${entryId}`).value);
            const proteinPerServing = parseFloat(document.getElementById(`edit-protein-${entryId}`).value);
            
            if (!servings || !caloriesPerServing || proteinPerServing === undefined) {
                alert('Please fill in all fields');
                return;
            }
            
            // Store per-serving values, and also calculate totals for chart
            const totalCalories = caloriesPerServing * servings;
            const totalProtein = proteinPerServing * servings;
            
            const foodData = {
                servings: servings,
                caloriesPerServing: caloriesPerServing,  // Store per-serving values
                proteinPerServing: proteinPerServing,    // Store per-serving values
                calories: totalCalories,  // Total calories (for chart calculations)
                protein: totalProtein      // Total protein (for chart calculations)
            };
            
            const success = await window.updateFoodEntry(entryId, foodData);
            if (success) {
                await loadDailyLog(user.uid);
                await renderNutritionChart(user.uid);
            } else {
                alert('Error updating food entry');
            }
        }
        
        // Cancel food edit
        async function cancelFoodEdit(entryId) {
            const user = window.firebaseAuth?.currentUser;
            if (!user) return;
            await loadDailyLog(user.uid);
        }
        
        // Delete food entry
        async function deleteFoodEntry(entryId) {
            if (!confirm('Are you sure you want to delete this food entry?')) {
                return;
            }
            
            const user = window.firebaseAuth?.currentUser;
            if (!user) return;
            
            const success = await window.deleteFoodEntryFromDB(entryId);
            if (success) {
                await loadDailyLog(user.uid);
                await renderNutritionChart(user.uid);
            } else {
                alert('Error deleting food entry');
            }
        }
        
        // Make functions globally available
        window.addFood = addFood;
        window.addFavorite = addFavorite;
        window.addFavoriteFood = addFavoriteFood;
        window.addFavoriteFoodById = addFavoriteFoodById;
        window.switchNutritionChart = switchNutritionChart;
        window.switchTimePeriod = switchTimePeriod;
        window.editFoodEntry = editFoodEntry;
        window.saveFoodEdit = saveFoodEdit;
        window.cancelFoodEdit = cancelFoodEdit;
        window.deleteFoodEntry = deleteFoodEntry;
        
        // Workouts functions
        let currentWorkoutTab = 'schedule';
        let editingGymWorkoutId = null;
        let editingSportsWorkoutId = null;
        let selectedDayForSchedule = null;
        
        async function loadWorkouts() {
            const user = window.firebaseAuth?.currentUser;
            if (!user) {
                alert('Please sign in to use the workout tracker');
                return;
            }
            
            const userId = user.uid;
            switchWorkoutTab(currentWorkoutTab);
        }
        
        async function switchWorkoutTab(tab) {
            currentWorkoutTab = tab;
            
            // Hide all sections
            document.getElementById('weeklyScheduleSection').style.display = 'none';
            document.getElementById('customGymSection').style.display = 'none';
            document.getElementById('customSportsSection').style.display = 'none';
            
            // Reset all tab styles
            const scheduleTab = document.getElementById('weeklyScheduleTab');
            const gymTab = document.getElementById('customGymTab');
            const sportsTab = document.getElementById('customSportsTab');
            
            scheduleTab.style.borderBottom = '3px solid transparent';
            scheduleTab.style.color = '#666';
            scheduleTab.style.fontWeight = '400';
            
            gymTab.style.borderBottom = '3px solid transparent';
            gymTab.style.color = '#666';
            gymTab.style.fontWeight = '400';
            
            sportsTab.style.borderBottom = '3px solid transparent';
            sportsTab.style.color = '#666';
            sportsTab.style.fontWeight = '400';
            
            const user = window.firebaseAuth?.currentUser;
            if (!user) return;
            
            if (tab === 'schedule') {
                document.getElementById('weeklyScheduleSection').style.display = 'block';
                scheduleTab.style.borderBottom = '3px solid var(--primary-color)';
                scheduleTab.style.color = 'var(--primary-color)';
                scheduleTab.style.fontWeight = '600';
                checkGoogleCalendarStatus();
                await loadWeeklySchedule(user.uid);
            } else if (tab === 'gym') {
                document.getElementById('customGymSection').style.display = 'block';
                gymTab.style.borderBottom = '3px solid var(--primary-color)';
                gymTab.style.color = 'var(--primary-color)';
                gymTab.style.fontWeight = '600';
                await loadCustomGymWorkouts(user.uid);
            } else if (tab === 'sports') {
                document.getElementById('customSportsSection').style.display = 'block';
                sportsTab.style.borderBottom = '3px solid var(--primary-color)';
                sportsTab.style.color = 'var(--primary-color)';
                sportsTab.style.fontWeight = '600';
                await loadCustomSportsWorkouts(user.uid);
            }
        }
        
        // Google Calendar Integration
        let googleCalendarToken = null;
        // Google Calendar API credentials
        const GOOGLE_CALENDAR_CLIENT_ID = '686596339738-hcdm9e8tdtnt3a9v5fpl799733usub53.apps.googleusercontent.com';
        const GOOGLE_CALENDAR_API_KEY = 'AIzaSyAJDWJe1s1V19fwlyW1anwY3v57OHlKa5k';
        const GOOGLE_CALENDAR_SCOPES = 'https://www.googleapis.com/auth/calendar';
        
        // Check if Google Calendar is connected
        function checkGoogleCalendarStatus() {
            const token = localStorage.getItem('googleCalendarToken');
            const statusText = document.getElementById('calendarStatusText');
            
            if (token) {
                googleCalendarToken = token;
                if (statusText) statusText.textContent = ' Connected to Google Calendar';
            } else {
                if (statusText) statusText.textContent = 'Click "Sync to Google Calendar" to connect and sync your schedule';
            }
        }
        
        // Wait for Google API to load
        function waitForGapi() {
            return new Promise((resolve, reject) => {
                if (typeof gapi !== 'undefined' && gapi.load) {
                    resolve();
                } else {
                    let attempts = 0;
                    const checkGapi = setInterval(() => {
                        attempts++;
                        if (typeof gapi !== 'undefined' && gapi.load) {
                            clearInterval(checkGapi);
                            resolve();
                        } else if (attempts > 50) {
                            clearInterval(checkGapi);
                            reject(new Error('Google API failed to load. Please refresh the page.'));
                        }
                    }, 100);
                }
            });
        }
        
        // Connect to Google Calendar
        async function connectGoogleCalendar() {
            try {
                // Check if credentials are configured
                if (GOOGLE_CALENDAR_CLIENT_ID === 'YOUR_GOOGLE_CLIENT_ID' || GOOGLE_CALENDAR_API_KEY === 'YOUR_GOOGLE_API_KEY') {
                    alert('Google Calendar integration is not configured. Please set up your Google OAuth Client ID and API Key in the code.\n\nTo set up:\n1. Go to https://console.cloud.google.com/\n2. Create a project or select existing one\n3. Enable Google Calendar API\n4. Create OAuth 2.0 credentials\n5. Update GOOGLE_CALENDAR_CLIENT_ID and GOOGLE_CALENDAR_API_KEY in the code');
                    return;
                }
                
                // Wait for Google API to be available
                await waitForGapi();
                
                // Load the client library
                await new Promise((resolve, reject) => {
                    gapi.load('client:auth2', {
                        callback: resolve,
                        onerror: reject,
                        timeout: 10000,
                        ontimeout: () => reject(new Error('Google API load timeout'))
                    });
                });
                
                // Initialize the client
                await gapi.client.init({
                    apiKey: GOOGLE_CALENDAR_API_KEY,
                    clientId: GOOGLE_CALENDAR_CLIENT_ID,
                    discoveryDocs: ['https://www.googleapis.com/discovery/v1/apis/calendar/v3/rest'],
                    scope: GOOGLE_CALENDAR_SCOPES
                });
                
                // Sign in the user
                const authInstance = gapi.auth2.getAuthInstance();
                
                // Check if user is already signed in
                let user = authInstance.currentUser.get();
                if (!user || !user.isSignedIn()) {
                    user = await authInstance.signIn({
                        prompt: 'consent'
                    });
                }
                
                const token = user.getAuthResponse().access_token;
                
                localStorage.setItem('googleCalendarToken', token);
                googleCalendarToken = token;
                
                // Set the token for API calls
                gapi.client.setToken({ access_token: token });
                
                checkGoogleCalendarStatus();
                alert('Successfully connected to Google Calendar! You can now sync your schedule.');
            } catch (error) {
                console.error('Error connecting to Google Calendar:', error);
                let errorMsg = 'Failed to connect to Google Calendar.\n\n';
                
                // Handle specific error cases
                if (error.error === 'idpiframe_initialization_failed' || error.message?.includes('idpiframe')) {
                    errorMsg += 'This usually means:\n';
                    errorMsg += '1. Your OAuth client was just created - wait 5-10 minutes and try again\n';
                    errorMsg += '2. Check that "http://localhost:8080" is in your Authorized JavaScript origins\n';
                    errorMsg += '3. Make sure your OAuth consent screen is configured\n\n';
                    errorMsg += 'Go to: https://console.cloud.google.com/apis/credentials';
                } else if (error.message) {
                    errorMsg += error.message;
                } else if (error.error) {
                    errorMsg += error.error;
                } else {
                    errorMsg += 'Please check the console for details.';
                }
                
                alert(errorMsg);
            }
        }
        
        // Sync schedule to Google Calendar (automatically connects if needed)
        async function syncToGoogleCalendar() {
            const user = window.firebaseAuth?.currentUser;
            if (!user) {
                alert('Please sign in first');
                return;
            }
            
            // If not connected, connect first
            if (!googleCalendarToken) {
                const token = localStorage.getItem('googleCalendarToken');
                if (!token) {
                    // Need to connect first
                    try {
                        await connectGoogleCalendar();
                        // After connecting, continue with sync
                        if (!localStorage.getItem('googleCalendarToken')) {
                            return; // User cancelled or connection failed
                        }
                    } catch (error) {
                        console.error('Error connecting:', error);
                        return;
                    }
                } else {
                    googleCalendarToken = token;
                }
            }
            
            // Ensure gapi client is initialized
            if (!gapi.client || !gapi.client.calendar) {
                try {
                    await waitForGapi();
                    
                    await new Promise((resolve, reject) => {
                        gapi.load('client:auth2', {
                            callback: resolve,
                            onerror: reject,
                            timeout: 10000,
                            ontimeout: () => reject(new Error('Google API load timeout'))
                        });
                    });
                    
                    await gapi.client.init({
                        apiKey: GOOGLE_CALENDAR_API_KEY,
                        clientId: GOOGLE_CALENDAR_CLIENT_ID,
                        discoveryDocs: ['https://www.googleapis.com/discovery/v1/apis/calendar/v3/rest'],
                        scope: GOOGLE_CALENDAR_SCOPES
                    });
                    
                    gapi.client.setToken({ access_token: googleCalendarToken });
                } catch (error) {
                    console.error('Error initializing Google API:', error);
                    alert('Error initializing Google Calendar API. Please reconnect.');
                    return;
                }
            } else {
                // Set token if client is already initialized
                gapi.client.setToken({ access_token: googleCalendarToken });
            }
            
            try {
                // Load all data
                const dietPlans = await window.getCustomDietPlans(user.uid);
                const gymWorkouts = await window.getCustomGymWorkouts(user.uid);
                const sportsWorkouts = await window.getCustomSportsWorkouts(user.uid);
                
                // Get current date to calculate event dates
                const today = new Date();
                const currentDay = today.getDay(); // 0 = Sunday, 1 = Monday, etc.
                
                // Day name to day number mapping
                const dayToNumber = {
                    'Sunday': 0,
                    'Monday': 1,
                    'Tuesday': 2,
                    'Wednesday': 3,
                    'Thursday': 4,
                    'Friday': 5,
                    'Saturday': 6
                };
                
                // Day abbreviation for RRULE
                const dayToAbbr = {
                    'Sunday': 'SU',
                    'Monday': 'MO',
                    'Tuesday': 'TU',
                    'Wednesday': 'WE',
                    'Thursday': 'TH',
                    'Friday': 'FR',
                    'Saturday': 'SA'
                };
                
                let eventsCreated = 0;
                
                // Sync diet plans
                for (const plan of dietPlans) {
                    if (plan.days && plan.days.length > 0) {
                        for (const dayName of plan.days) {
                            const dayNumber = dayToNumber[dayName];
                            if (dayNumber !== undefined) {
                                // Calculate next occurrence of this day
                                const daysUntil = (dayNumber - currentDay + 7) % 7 || 7;
                                const eventDate = new Date(today);
                                eventDate.setDate(today.getDate() + daysUntil);
                                
                                // Create event for each meal
                                if (plan.meals && plan.meals.length > 0) {
                                    for (const meal of plan.meals) {
                                        const eventTime = meal.time ? meal.time.split(':') : ['12', '00'];
                                        const eventDateTime = new Date(eventDate);
                                        eventDateTime.setHours(parseInt(eventTime[0]), parseInt(eventTime[1]), 0);
                                        
                                        const event = {
                                            summary: ` ${plan.name}: ${meal.name}`,
                                            description: `Calories: ${Math.round(meal.calories)} | Protein: ${Math.round(meal.protein * 10) / 10}g${meal.food ? `\nFood: ${meal.food}` : ''}`,
                                            start: {
                                                dateTime: eventDateTime.toISOString(),
                                                timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone
                                            },
                                            end: {
                                                dateTime: new Date(eventDateTime.getTime() + 30 * 60000).toISOString(), // 30 min duration
                                                timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone
                                            },
                                            recurrence: ['RRULE:FREQ=WEEKLY;BYDAY=' + dayToAbbr[dayName]]
                                        };
                                        
                                        await gapi.client.calendar.events.insert({
                                            calendarId: 'primary',
                                            resource: event
                                        });
                                        eventsCreated++;
                                    }
                                }
                            }
                        }
                    }
                }
                
                // Sync gym workouts
                for (const workout of gymWorkouts) {
                    if (workout.days && workout.days.length > 0) {
                        for (const dayName of workout.days) {
                            const dayNumber = dayToNumber[dayName];
                            if (dayNumber !== undefined) {
                                const daysUntil = (dayNumber - currentDay + 7) % 7 || 7;
                                const eventDate = new Date(today);
                                eventDate.setDate(today.getDate() + daysUntil);
                                eventDate.setHours(18, 0, 0); // Default to 6 PM
                                
                                const event = {
                                    summary: ` ${workout.name}`,
                                    description: `Exercises: ${workout.exercises.map(e => e.name).join(', ')}`,
                                    start: {
                                        dateTime: eventDate.toISOString(),
                                        timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone
                                    },
                                    end: {
                                        dateTime: new Date(eventDate.getTime() + 60 * 60000).toISOString(), // 1 hour duration
                                        timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone
                                    },
                                    recurrence: ['RRULE:FREQ=WEEKLY;BYDAY=' + dayToAbbr[dayName]]
                                };
                                
                                await gapi.client.calendar.events.insert({
                                    calendarId: 'primary',
                                    resource: event
                                });
                                eventsCreated++;
                            }
                        }
                    }
                }
                
                // Sync sports workouts
                for (const workout of sportsWorkouts) {
                    if (workout.days && workout.days.length > 0) {
                        for (const dayName of workout.days) {
                            const dayNumber = dayToNumber[dayName];
                            if (dayNumber !== undefined) {
                                const daysUntil = (dayNumber - currentDay + 7) % 7 || 7;
                                const eventDate = new Date(today);
                                eventDate.setDate(today.getDate() + daysUntil);
                                eventDate.setHours(17, 0, 0); // Default to 5 PM
                                
                                const event = {
                                    summary: ` ${workout.name}`,
                                    description: workout.details || '',
                                    start: {
                                        dateTime: eventDate.toISOString(),
                                        timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone
                                    },
                                    end: {
                                        dateTime: new Date(eventDate.getTime() + 60 * 60000).toISOString(), // 1 hour duration
                                        timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone
                                    },
                                    recurrence: ['RRULE:FREQ=WEEKLY;BYDAY=' + dayToAbbr[dayName]]
                                };
                                
                                await gapi.client.calendar.events.insert({
                                    calendarId: 'primary',
                                    resource: event
                                });
                                eventsCreated++;
                            }
                        }
                    }
                }
                
                alert(`Successfully synced ${eventsCreated} events to Google Calendar!`);
            } catch (error) {
                console.error('Error syncing to Google Calendar:', error);
                alert('Error syncing to Google Calendar: ' + (error.message || 'Unknown error'));
            }
        }
        
        // Weekly Schedule Functions
        let scheduleEditMode = false;
        
        async function loadWeeklySchedule(userId) {
            const schedule = await window.getWeeklySchedule(userId);
            const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
            const container = document.getElementById('weeklyScheduleContainer');
            container.innerHTML = '';
            
            // Load diet plans and workouts with their selected days
            const dietPlans = await window.getCustomDietPlans(userId);
            const gymWorkouts = await window.getCustomGymWorkouts(userId);
            const sportsWorkouts = await window.getCustomSportsWorkouts(userId);
            
            // Build a comprehensive schedule that includes diet plans and workouts based on their days
            const fullSchedule = {};
            days.forEach(day => {
                fullSchedule[day.toLowerCase()] = [...(schedule[day.toLowerCase()] || [])];
            });
            
            // Add diet plans to schedule based on their selected days
            dietPlans.forEach(plan => {
                if (plan.days && Array.isArray(plan.days) && plan.days.length > 0) {
                    plan.days.forEach(planDay => {
                        const dayKey = planDay.toLowerCase();
                        if (fullSchedule[dayKey]) {
                            // Check if diet plan is already in schedule (from manual addition)
                            const exists = fullSchedule[dayKey].some(item => 
                                item.type === 'diet' && item.id === plan.id
                            );
                            if (!exists) {
                                fullSchedule[dayKey].push({
                                    type: 'diet',
                                    id: plan.id,
                                    name: plan.name
                                });
                            }
                        }
                    });
                }
            });
            
            // Add gym workouts to schedule based on their selected days
            gymWorkouts.forEach(workout => {
                if (workout.days && Array.isArray(workout.days) && workout.days.length > 0) {
                    workout.days.forEach(workoutDay => {
                        const dayKey = workoutDay.toLowerCase();
                        if (fullSchedule[dayKey]) {
                            // Check if workout is already in schedule (from manual addition)
                            const exists = fullSchedule[dayKey].some(item => 
                                item.type === 'gym' && item.id === workout.id
                            );
                            if (!exists) {
                                fullSchedule[dayKey].push({
                                    type: 'gym',
                                    id: workout.id,
                                    name: workout.name
                                });
                            }
                        }
                    });
                }
            });
            
            // Add sports workouts to schedule based on their selected days
            sportsWorkouts.forEach(workout => {
                if (workout.days && Array.isArray(workout.days) && workout.days.length > 0) {
                    workout.days.forEach(workoutDay => {
                        const dayKey = workoutDay.toLowerCase();
                        if (fullSchedule[dayKey]) {
                            // Check if workout is already in schedule (from manual addition)
                            const exists = fullSchedule[dayKey].some(item => 
                                item.type === 'sports' && item.id === workout.id
                            );
                            if (!exists) {
                                fullSchedule[dayKey].push({
                                    type: 'sports',
                                    id: workout.id,
                                    name: workout.name
                                });
                            }
                        }
                    });
                }
            });
            
            days.forEach(day => {
                const dayKey = day.toLowerCase();
                const items = fullSchedule[dayKey] || [];
                const dayColumn = document.createElement('div');
                dayColumn.style.cssText = 'display: flex; flex-direction: column; border: 1px solid #e2e8f0; border-radius: 8px; padding: 15px; background: #f8f9fa; min-height: 200px;';
                
                // Day header - make it more prominent
                const dayHeader = document.createElement('div');
                dayHeader.style.cssText = 'font-weight: 700; font-size: 18px; margin-bottom: 15px; text-align: center; padding-bottom: 12px; border-bottom: 2px solid #e2e8f0; color: #1a1a1a; font-family: \'Courier Prime\', monospace;';
                dayHeader.textContent = day;
                dayColumn.appendChild(dayHeader);
                
                // Items container (workouts and diet plans)
                const itemsContainer = document.createElement('div');
                itemsContainer.style.cssText = 'flex: 1; margin-bottom: 10px;';
                
                if (items.length === 0) {
                    itemsContainer.innerHTML = '<div style="color: #999; font-style: italic; text-align: center; font-size: 12px; padding: 10px;">No items</div>';
                } else {
                    items.forEach((item, index) => {
                        const itemDiv = document.createElement('div');
                        // Different colors for different types
                        let bgColor = '#f0f9ff'; // Default for workouts
                        let prefix = '';
                        if (item.type === 'diet') {
                            bgColor = '#fef3c7'; // Yellow for diet plans
                            prefix = ' ';
                        } else if (item.type === 'gym') {
                            bgColor = '#dbeafe'; // Blue for gym workouts
                            prefix = ' ';
                        } else if (item.type === 'sports') {
                            bgColor = '#d1fae5'; // Green for sports workouts
                            prefix = ' ';
                        }
                        
                        itemDiv.style.cssText = `background: ${bgColor}; padding: 10px; border-radius: 4px; margin-bottom: 8px; font-size: 14px; border: 1px solid rgba(0,0,0,0.1);`;
                        
                        // Show delete button only in edit mode
                        const deleteButtonHTML = scheduleEditMode 
                            ? `<button onclick="removeWorkoutFromDay('${dayKey}', ${index})" style="background: #ef4444; color: white; border: none; border-radius: 3px; padding: 2px 8px; cursor: pointer; font-size: 14px; margin-left: 8px; font-weight: bold;">-</button>`
                            : '';
                        
                        itemDiv.innerHTML = `
                            <div style="display: flex; align-items: center; justify-content: space-between;">
                                <div style="font-weight: 600; color: #1a1a1a;">${prefix}${item.name}</div>
                                ${deleteButtonHTML}
                            </div>
                        `;
                        itemsContainer.appendChild(itemDiv);
                    });
                }
                dayColumn.appendChild(itemsContainer);
                
                // Add button (only show when not in edit mode)
                if (!scheduleEditMode) {
                    const addButton = document.createElement('button');
                    addButton.className = 'btn btn-secondary';
                    addButton.style.cssText = 'padding: 8px 12px; width: 100%; margin-top: auto;';
                    addButton.textContent = 'Add';
                    addButton.onclick = () => showAddWorkoutToDay(dayKey, day);
                    dayColumn.appendChild(addButton);
                }
                
                container.appendChild(dayColumn);
            });
        }
        
        async function toggleScheduleEditMode() {
            scheduleEditMode = !scheduleEditMode;
            const editBtn = document.getElementById('editScheduleBtn');
            
            if (scheduleEditMode) {
                editBtn.textContent = 'Cancel';
                editBtn.style.background = '#ef4444';
                editBtn.style.color = 'white';
            } else {
                editBtn.textContent = 'Edit';
                editBtn.style.background = '';
                editBtn.style.color = '';
            }
            
            // Reload schedule to show/hide delete buttons
            const user = window.firebaseAuth?.currentUser;
            if (user) {
                await loadWeeklySchedule(user.uid);
            }
        }
        
        async function showAddWorkoutToDay(dayKey, dayName) {
            selectedDayForSchedule = dayKey;
            document.getElementById('selectedDayName').textContent = dayName;
            document.getElementById('addWorkoutToDayForm').style.display = 'block';
            
            const user = window.firebaseAuth?.currentUser;
            if (!user) return;
            
            // Load all custom workouts
            const gymWorkouts = await window.getCustomGymWorkouts(user.uid);
            const sportsWorkouts = await window.getCustomSportsWorkouts(user.uid);
            
            const select = document.getElementById('workoutSelect');
            select.innerHTML = '<option value="">-- Select a workout --</option>';
            
            gymWorkouts.forEach(workout => {
                const option = document.createElement('option');
                option.value = `gym-${workout.id}`;
                option.textContent = workout.name + ' (Gym)';
                select.appendChild(option);
            });
            
            sportsWorkouts.forEach(workout => {
                const option = document.createElement('option');
                option.value = `sports-${workout.id}`;
                option.textContent = workout.name + ' (Sports)';
                select.appendChild(option);
            });
        }
        
        async function addWorkoutToDay() {
            const user = window.firebaseAuth?.currentUser;
            if (!user) return;
            
            const workoutSelect = document.getElementById('workoutSelect').value;
            if (!workoutSelect || !selectedDayForSchedule) return;
            
            const [type, id] = workoutSelect.split('-');
            const schedule = await window.getWeeklySchedule(user.uid);
            const dayKey = selectedDayForSchedule;
            
            let workoutName = '';
            if (type === 'gym') {
                const gymWorkouts = await window.getCustomGymWorkouts(user.uid);
                const workout = gymWorkouts.find(w => w.id === id);
                if (workout) workoutName = workout.name;
            } else if (type === 'sports') {
                const sportsWorkouts = await window.getCustomSportsWorkouts(user.uid);
                const workout = sportsWorkouts.find(w => w.id === id);
                if (workout) workoutName = workout.name;
            }
            
            if (!schedule[dayKey]) schedule[dayKey] = [];
            schedule[dayKey].push({ type, id, name: workoutName });
            
            const success = await window.saveWeeklySchedule(user.uid, schedule);
            if (success) {
                document.getElementById('addWorkoutToDayForm').style.display = 'none';
                await loadWeeklySchedule(user.uid);
            }
        }
        
        function cancelAddWorkoutToDay() {
            document.getElementById('addWorkoutToDayForm').style.display = 'none';
            selectedDayForSchedule = null;
        }
        
        async function removeWorkoutFromDay(dayKey, index) {
            const user = window.firebaseAuth?.currentUser;
            if (!user) return;
            
            const schedule = await window.getWeeklySchedule(user.uid);
            if (schedule[dayKey]) {
                schedule[dayKey].splice(index, 1);
                await window.saveWeeklySchedule(user.uid, schedule);
                await loadWeeklySchedule(user.uid);
            }
        }
        
        // Custom Gym Workout Functions
        async function loadCustomGymWorkouts(userId) {
            const workouts = await window.getCustomGymWorkouts(userId);
            const container = document.getElementById('customGymWorkoutsList');
            container.innerHTML = '';
            
            if (workouts.length === 0) {
                container.innerHTML = '<p style="text-align: center; color: #666; padding: 40px;">No custom gym workouts yet. Create one to get started!</p>';
                return;
            }
            
            workouts.forEach(workout => {
                const workoutDays = workout.days && Array.isArray(workout.days) && workout.days.length > 0 ? workout.days : [];
                const daysDisplay = workoutDays.length > 0 ? workoutDays.join(', ') : 'No days selected';
                const workoutDiv = document.createElement('div');
                workoutDiv.style.cssText = 'background: #f8f9fa; padding: 20px; border-radius: 8px; margin-bottom: 15px;';
                workoutDiv.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 15px;">
                        <div>
                            <h4 style="font-family: \'Courier Prime\', monospace; margin: 0 0 5px 0;">${workout.name}</h4>
                            <div style="font-family: \'Courier Prime\', monospace; color: #888; font-size: 13px;">
                                <strong>Days:</strong> ${daysDisplay}
                            </div>
                        </div>
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <label style="display: flex; align-items: center; cursor: pointer; font-family: 'Bebas Neue', sans-serif; font-size: 13px; color: #666;">
                                <input type="checkbox" id="gymWorkoutToggle-${workout.id}" ${workoutDays.length > 0 ? 'checked' : ''} onchange="toggleGymWorkout('${workout.id}')" style="margin-right: 6px; width: 18px; height: 18px; cursor: pointer;">
                                <span id="gymWorkoutToggleLabel-${workout.id}">${workoutDays.length > 0 ? 'ON' : 'OFF'}</span>
                            </label>
                            <button onclick="editGymWorkout('${workout.id}')" class="btn btn-secondary" style="padding: 5px 15px; margin-right: 5px;">Edit</button>
                            <button onclick="deleteGymWorkout('${workout.id}')" class="btn" style="padding: 5px 15px; background: #ef4444; color: white;">Delete</button>
                        </div>
                    </div>
                    <div>
                        ${workout.exercises.map(ex => {
                            let details = [];
                            if (ex.sets && ex.reps && ex.weight) {
                                details.push(`${ex.sets} sets  ${ex.reps} reps @ ${ex.weight} lbs`);
                            } else if (ex.sets && ex.reps) {
                                details.push(`${ex.sets} sets  ${ex.reps} reps`);
                            } else if (ex.sets) {
                                details.push(`${ex.sets} sets`);
                            }
                            if (ex.notes) {
                                details.push(ex.notes);
                            }
                            const detailsText = details.length > 0 ? ' - ' + details.join(', ') : '';
                            return `
                                <div style="padding: 8px; background: white; border-radius: 4px; margin-bottom: 8px; font-family: \'Courier Prime\', monospace;">
                                    <strong>${ex.name}</strong>${detailsText}
                                </div>
                            `;
                        }).join('')}
                    </div>
                `;
                container.appendChild(workoutDiv);
            });
        }
        
        function showCreateGymWorkoutForm() {
            editingGymWorkoutId = null;
            document.getElementById('gymWorkoutFormTitle').textContent = 'Create Custom Gym Workout';
            document.getElementById('gymWorkoutName').value = '';
            document.getElementById('gymWorkoutExercisesList').innerHTML = '';
            // Clear all day checkboxes
            const days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
            days.forEach(day => {
                const checkbox = document.getElementById(`gymWorkoutDay-${day}`);
                if (checkbox) checkbox.checked = false;
            });
            document.getElementById('createGymWorkoutForm').style.display = 'block';
        }
        
        function addExerciseToGymWorkout() {
            const container = document.getElementById('gymWorkoutExercisesList');
            const exerciseId = 'exercise-' + Date.now();
            const exerciseDiv = document.createElement('div');
            exerciseDiv.style.cssText = 'padding: 15px; background: #f8f9fa; border-radius: 4px; margin-bottom: 15px;';
            exerciseDiv.innerHTML = `
                <div style="display: grid; grid-template-columns: 2fr 1fr 1fr 1fr auto; gap: 10px; align-items: end; margin-bottom: 10px;">
                    <input type="text" id="${exerciseId}-name" placeholder="Exercise name" style="padding: 8px; border: 2px solid #ddd; border-radius: 4px; font-family: \'Courier Prime\', monospace;">
                    <input type="number" id="${exerciseId}-sets" placeholder="Sets (optional)" min="0" style="padding: 8px; border: 2px solid #ddd; border-radius: 4px; font-family: \'Courier Prime\', monospace;">
                    <input type="number" id="${exerciseId}-reps" placeholder="Reps (optional)" min="0" style="padding: 8px; border: 2px solid #ddd; border-radius: 4px; font-family: \'Courier Prime\', monospace;">
                    <input type="number" id="${exerciseId}-weight" placeholder="Weight (optional)" min="0" step="0.5" style="padding: 8px; border: 2px solid #ddd; border-radius: 4px; font-family: \'Courier Prime\', monospace;">
                    <button onclick="this.parentElement.parentElement.remove()" class="btn" style="padding: 8px 12px; background: #ef4444; color: white;">Remove</button>
                </div>
                <input type="text" id="${exerciseId}-notes" placeholder="Custom notes (e.g., 10 minutes at 6 mph)" style="width: 100%; padding: 8px; border: 2px solid #ddd; border-radius: 4px; font-family: \'Courier Prime\', monospace;">
            `;
            container.appendChild(exerciseDiv);
        }
        
        async function saveGymWorkout() {
            const user = window.firebaseAuth?.currentUser;
            if (!user) return;
            
            const name = document.getElementById('gymWorkoutName').value.trim();
            if (!name) {
                alert('Please enter a workout name');
                return;
            }
            
            const exercises = [];
            const exerciseDivs = document.querySelectorAll('#gymWorkoutExercisesList > div');
            exerciseDivs.forEach(div => {
                const inputs = div.querySelectorAll('input');
                const name = inputs[0].value.trim();
                const setsValue = inputs[1].value.trim();
                const repsValue = inputs[2].value.trim();
                const weightValue = inputs[3].value.trim();
                const notes = inputs[4].value.trim();
                
                if (name) {
                    const exerciseData = { name };
                    
                    // Only add sets/reps/weight if they have values
                    if (setsValue) {
                        const sets = parseInt(setsValue);
                        if (!isNaN(sets)) exerciseData.sets = sets;
                    }
                    if (repsValue) {
                        const reps = parseInt(repsValue);
                        if (!isNaN(reps)) exerciseData.reps = reps;
                    }
                    if (weightValue) {
                        const weight = parseFloat(weightValue);
                        if (!isNaN(weight)) exerciseData.weight = weight;
                    }
                    if (notes) {
                        exerciseData.notes = notes;
                    }
                    
                    exercises.push(exerciseData);
                }
            });
            
            if (exercises.length === 0) {
                alert('Please add at least one exercise');
                return;
            }
            
            // Get selected days
            const selectedDays = [];
            const days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
            days.forEach(day => {
                const checkbox = document.getElementById(`gymWorkoutDay-${day}`);
                if (checkbox && checkbox.checked) {
                    selectedDays.push(day);
                }
            });
            
            const workoutData = { name, exercises, days: selectedDays };
            
            try {
                let success = false;
                if (editingGymWorkoutId) {
                    success = await window.updateCustomGymWorkout(editingGymWorkoutId, workoutData);
                } else {
                    success = await window.saveCustomGymWorkout(user.uid, workoutData);
                }
                
                if (success) {
                    document.getElementById('createGymWorkoutForm').style.display = 'none';
                    await loadCustomGymWorkouts(user.uid);
                } else {
                    alert('Error saving workout. Please check the console for details.');
                }
            } catch (error) {
                console.error('Error saving workout:', error);
                alert('Error saving workout: ' + (error.message || 'Unknown error'));
            }
        }
        
        async function editGymWorkout(workoutId) {
            const user = window.firebaseAuth?.currentUser;
            if (!user) return;
            
            const workouts = await window.getCustomGymWorkouts(user.uid);
            const workout = workouts.find(w => w.id === workoutId);
            if (!workout) return;
            
            editingGymWorkoutId = workoutId;
            document.getElementById('gymWorkoutFormTitle').textContent = 'Edit Custom Gym Workout';
            document.getElementById('gymWorkoutName').value = workout.name || '';
            document.getElementById('gymWorkoutExercisesList').innerHTML = '';
            
            // Set day checkboxes
            const days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
            const workoutDays = workout.days && Array.isArray(workout.days) ? workout.days : [];
            days.forEach(day => {
                const checkbox = document.getElementById(`gymWorkoutDay-${day}`);
                if (checkbox) {
                    checkbox.checked = workoutDays.includes(day);
                }
            });
            
            workout.exercises.forEach(ex => {
                const exerciseId = 'exercise-' + Date.now() + '-' + Math.random();
                const exerciseDiv = document.createElement('div');
                exerciseDiv.style.cssText = 'padding: 15px; background: #f8f9fa; border-radius: 4px; margin-bottom: 15px;';
                exerciseDiv.innerHTML = `
                    <div style="display: grid; grid-template-columns: 2fr 1fr 1fr 1fr auto; gap: 10px; align-items: end; margin-bottom: 10px;">
                        <input type="text" id="${exerciseId}-name" value="${ex.name || ''}" style="padding: 8px; border: 2px solid #ddd; border-radius: 4px; font-family: \'Courier Prime\', monospace;">
                        <input type="number" id="${exerciseId}-sets" value="${ex.sets || ''}" placeholder="Sets (optional)" min="0" style="padding: 8px; border: 2px solid #ddd; border-radius: 4px; font-family: \'Courier Prime\', monospace;">
                        <input type="number" id="${exerciseId}-reps" value="${ex.reps || ''}" placeholder="Reps (optional)" min="0" style="padding: 8px; border: 2px solid #ddd; border-radius: 4px; font-family: \'Courier Prime\', monospace;">
                        <input type="number" id="${exerciseId}-weight" value="${ex.weight || ''}" placeholder="Weight (optional)" min="0" step="0.5" style="padding: 8px; border: 2px solid #ddd; border-radius: 4px; font-family: \'Courier Prime\', monospace;">
                        <button onclick="this.parentElement.parentElement.remove()" class="btn" style="padding: 8px 12px; background: #ef4444; color: white;">Remove</button>
                    </div>
                    <input type="text" id="${exerciseId}-notes" value="${ex.notes || ''}" placeholder="Custom notes (e.g., 10 minutes at 6 mph)" style="width: 100%; padding: 8px; border: 2px solid #ddd; border-radius: 4px; font-family: \'Courier Prime\', monospace;">
                `;
                document.getElementById('gymWorkoutExercisesList').appendChild(exerciseDiv);
            });
            
            document.getElementById('createGymWorkoutForm').style.display = 'block';
        }
        
        async function deleteGymWorkout(workoutId) {
            if (!confirm('Are you sure you want to delete this workout?')) return;
            
            const success = await window.deleteCustomGymWorkout(workoutId);
            if (success) {
                const user = window.firebaseAuth?.currentUser;
                if (user) await loadCustomGymWorkouts(user.uid);
            } else {
                alert('Error deleting workout');
            }
        }
        
        function cancelGymWorkoutForm() {
            document.getElementById('createGymWorkoutForm').style.display = 'none';
            editingGymWorkoutId = null;
        }
        
        // Custom Sports Workout Functions
        async function loadCustomSportsWorkouts(userId) {
            const workouts = await window.getCustomSportsWorkouts(userId);
            const container = document.getElementById('customSportsWorkoutsList');
            container.innerHTML = '';
            
            if (workouts.length === 0) {
                container.innerHTML = '<p style="text-align: center; color: #666; padding: 40px;">No custom sports workouts yet. Create one to get started!</p>';
                return;
            }
            
            workouts.forEach(workout => {
                const workoutDays = workout.days && Array.isArray(workout.days) && workout.days.length > 0 ? workout.days : [];
                const daysDisplay = workoutDays.length > 0 ? workoutDays.join(', ') : 'No days selected';
                const workoutDiv = document.createElement('div');
                workoutDiv.style.cssText = 'background: #f8f9fa; padding: 20px; border-radius: 8px; margin-bottom: 15px;';
                workoutDiv.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 15px;">
                        <div>
                            <h4 style="font-family: \'Courier Prime\', monospace; margin: 0 0 5px 0;">${workout.name}</h4>
                            <div style="font-family: \'Courier Prime\', monospace; color: #888; font-size: 13px; margin-bottom: 10px;">
                                <strong>Days:</strong> ${daysDisplay}
                            </div>
                        </div>
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <label style="display: flex; align-items: center; cursor: pointer; font-family: 'Bebas Neue', sans-serif; font-size: 13px; color: #666;">
                                <input type="checkbox" id="sportsWorkoutToggle-${workout.id}" ${workoutDays.length > 0 ? 'checked' : ''} onchange="toggleSportsWorkout('${workout.id}')" style="margin-right: 6px; width: 18px; height: 18px; cursor: pointer;">
                                <span id="sportsWorkoutToggleLabel-${workout.id}">${workoutDays.length > 0 ? 'ON' : 'OFF'}</span>
                            </label>
                            <button onclick="editSportsWorkout('${workout.id}')" class="btn btn-secondary" style="padding: 5px 15px; margin-right: 5px;">Edit</button>
                            <button onclick="deleteSportsWorkout('${workout.id}')" class="btn" style="padding: 5px 15px; background: #ef4444; color: white;">Delete</button>
                        </div>
                    </div>
                    <div style="font-family: \'Courier Prime\', monospace; color: #666; white-space: pre-wrap;">${workout.details}</div>
                `;
                container.appendChild(workoutDiv);
            });
        }
        
        function showCreateSportsWorkoutForm() {
            editingSportsWorkoutId = null;
            document.getElementById('sportsWorkoutFormTitle').textContent = 'Create Custom Sports Workout';
            document.getElementById('sportsWorkoutName').value = '';
            document.getElementById('sportsWorkoutDetails').value = '';
            // Clear all day checkboxes
            const days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
            days.forEach(day => {
                const checkbox = document.getElementById(`sportsWorkoutDay-${day}`);
                if (checkbox) checkbox.checked = false;
            });
            document.getElementById('createSportsWorkoutForm').style.display = 'block';
        }
        
        async function saveSportsWorkout() {
            const user = window.firebaseAuth?.currentUser;
            if (!user) return;
            
            const name = document.getElementById('sportsWorkoutName').value.trim();
            const details = document.getElementById('sportsWorkoutDetails').value.trim();
            
            if (!name || !details) {
                alert('Please fill in all fields');
                return;
            }
            
            // Get selected days
            const selectedDays = [];
            const days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
            days.forEach(day => {
                const checkbox = document.getElementById(`sportsWorkoutDay-${day}`);
                if (checkbox && checkbox.checked) {
                    selectedDays.push(day);
                }
            });
            
            const workoutData = { name, details, days: selectedDays };
            
            let success = false;
            if (editingSportsWorkoutId) {
                success = await window.updateCustomSportsWorkout(editingSportsWorkoutId, workoutData);
            } else {
                success = await window.saveCustomSportsWorkout(user.uid, workoutData);
            }
            
            if (success) {
                document.getElementById('createSportsWorkoutForm').style.display = 'none';
                await loadCustomSportsWorkouts(user.uid);
            } else {
                alert('Error saving workout');
            }
        }
        
        async function editSportsWorkout(workoutId) {
            const user = window.firebaseAuth?.currentUser;
            if (!user) return;
            
            const workouts = await window.getCustomSportsWorkouts(user.uid);
            const workout = workouts.find(w => w.id === workoutId);
            if (!workout) return;
            
            editingSportsWorkoutId = workoutId;
            document.getElementById('sportsWorkoutFormTitle').textContent = 'Edit Custom Sports Workout';
            document.getElementById('sportsWorkoutName').value = workout.name || '';
            document.getElementById('sportsWorkoutDetails').value = workout.details || '';
            
            // Set day checkboxes
            const days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
            const workoutDays = workout.days && Array.isArray(workout.days) ? workout.days : [];
            days.forEach(day => {
                const checkbox = document.getElementById(`sportsWorkoutDay-${day}`);
                if (checkbox) {
                    checkbox.checked = workoutDays.includes(day);
                }
            });
            
            document.getElementById('createSportsWorkoutForm').style.display = 'block';
        }
        
        async function deleteSportsWorkout(workoutId) {
            if (!confirm('Are you sure you want to delete this workout?')) return;
            
            const success = await window.deleteCustomSportsWorkout(workoutId);
            if (success) {
                const user = window.firebaseAuth?.currentUser;
                if (user) await loadCustomSportsWorkouts(user.uid);
            } else {
                alert('Error deleting workout');
            }
        }
        
        function cancelSportsWorkoutForm() {
            document.getElementById('createSportsWorkoutForm').style.display = 'none';
            editingSportsWorkoutId = null;
        }
        
        // Make workout functions globally available
        window.switchWorkoutTab = switchWorkoutTab;
        window.showAddWorkoutToDay = showAddWorkoutToDay;
        window.addWorkoutToDay = addWorkoutToDay;
        window.cancelAddWorkoutToDay = cancelAddWorkoutToDay;
        window.removeWorkoutFromDay = removeWorkoutFromDay;
        window.toggleScheduleEditMode = toggleScheduleEditMode;
        window.showCreateGymWorkoutForm = showCreateGymWorkoutForm;
        window.addExerciseToGymWorkout = addExerciseToGymWorkout;
        window.saveGymWorkout = saveGymWorkout;
        window.editGymWorkout = editGymWorkout;
        window.deleteGymWorkout = deleteGymWorkout;
        
        // Toggle gym workout on/off
        async function toggleGymWorkout(workoutId) {
            const user = window.firebaseAuth?.currentUser;
            if (!user) return;
            
            const workouts = await window.getCustomGymWorkouts(user.uid);
            const workout = workouts.find(w => w.id === workoutId);
            if (!workout) return;
            
            const checkbox = document.getElementById(`gymWorkoutToggle-${workoutId}`);
            const label = document.getElementById(`gymWorkoutToggleLabel-${workoutId}`);
            
            let newDays = [];
            if (checkbox.checked) {
                // Turning ON: if no days were set, default to all days
                if (!workout.days || workout.days.length === 0) {
                    newDays = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
                } else {
                    newDays = workout.days; // Keep existing days
                }
                label.textContent = 'ON';
            } else {
                // Turning OFF: clear days
                newDays = [];
                label.textContent = 'OFF';
            }
            
            // Update only the days field
            const success = await window.updateCustomGymWorkout(workoutId, {
                name: workout.name,
                exercises: workout.exercises,
                days: newDays
            });
            
            if (success) {
                await loadCustomGymWorkouts(user.uid);
                // Reload schedule if we're on that tab
                const user2 = window.firebaseAuth?.currentUser;
                if (user2) await loadWeeklySchedule(user2.uid);
            }
        }
        
        window.toggleGymWorkout = toggleGymWorkout;
        window.cancelGymWorkoutForm = cancelGymWorkoutForm;
        window.showCreateSportsWorkoutForm = showCreateSportsWorkoutForm;
        window.saveSportsWorkout = saveSportsWorkout;
        window.editSportsWorkout = editSportsWorkout;
        window.deleteSportsWorkout = deleteSportsWorkout;
        
        // Toggle sports workout on/off
        async function toggleSportsWorkout(workoutId) {
            const user = window.firebaseAuth?.currentUser;
            if (!user) return;
            
            const workouts = await window.getCustomSportsWorkouts(user.uid);
            const workout = workouts.find(w => w.id === workoutId);
            if (!workout) return;
            
            const checkbox = document.getElementById(`sportsWorkoutToggle-${workoutId}`);
            const label = document.getElementById(`sportsWorkoutToggleLabel-${workoutId}`);
            
            let newDays = [];
            if (checkbox.checked) {
                // Turning ON: if no days were set, default to all days
                if (!workout.days || workout.days.length === 0) {
                    newDays = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
                } else {
                    newDays = workout.days; // Keep existing days
                }
                label.textContent = 'ON';
            } else {
                // Turning OFF: clear days
                newDays = [];
                label.textContent = 'OFF';
            }
            
            // Update only the days field
            const success = await window.updateCustomSportsWorkout(workoutId, {
                name: workout.name,
                details: workout.details,
                days: newDays
            });
            
            if (success) {
                await loadCustomSportsWorkouts(user.uid);
                // Reload schedule if we're on that tab
                const user2 = window.firebaseAuth?.currentUser;
                if (user2) await loadWeeklySchedule(user2.uid);
            }
        }
        
        window.toggleSportsWorkout = toggleSportsWorkout;
        window.cancelSportsWorkoutForm = cancelSportsWorkoutForm;
        window.loadWorkouts = loadWorkouts;
        window.connectGoogleCalendar = connectGoogleCalendar;
        window.syncToGoogleCalendar = syncToGoogleCalendar;
        window.checkGoogleCalendarStatus = checkGoogleCalendarStatus;
    </script>

    <!-- 3D Skeleton Viewer Logic -->
    <script>
        // Global variables for skeleton viewer
        let skeletonScene, skeletonCamera, skeletonRenderer;
        let skeletonObjects = [];
        let currentSkeletonFrameIndex = 0;
        let isSkeletonPlaying = true;
        let skeletonAnimationId = null;

        // Initialize Three.js scene
        function initSkeletonViewer(canvas) {
            const container = canvas.parentElement;
            const width = container ? container.clientWidth : 640;
            const height = 400;

            skeletonScene = new THREE.Scene();
            skeletonScene.background = new THREE.Color(0x1a1a1a);

            skeletonCamera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
            skeletonCamera.position.set(0, 0, 5);
            skeletonCamera.lookAt(0, 0, 0);

            skeletonRenderer = new THREE.WebGLRenderer({ canvas, antialias: true });
            skeletonRenderer.setSize(width, height);
            skeletonRenderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

            // Set canvas size explicitly
            canvas.width = width;
            canvas.height = height;

            // Add grid
            const grid = new THREE.GridHelper(10, 10, 0x444444, 0x222222);
            skeletonScene.add(grid);

            // Add lights
            const ambient = new THREE.AmbientLight(0xffffff, 0.6);
            skeletonScene.add(ambient);
            const directional = new THREE.DirectionalLight(0xffffff, 0.8);
            directional.position.set(5, 5, 5);
            skeletonScene.add(directional);

            // Render initial empty scene
            skeletonRenderer.render(skeletonScene, skeletonCamera);
        }

        // Get color based on shot stage
        function getSkeletonStageColor(stage) {
            const colors = {
                'neutral': 0x888888,
                'pre_shot': 0xFFD700,
                'follow_through': 0x00FF00
            };
            return colors[stage] || 0xFF6B7A; // Default to primary color
        }

        // Update skeleton for a frame
        function updateSkeletonFrame(landmarks, stage) {
            if (!skeletonScene || !skeletonRenderer) return;

            // Clear previous skeleton objects
            skeletonObjects.forEach(obj => skeletonScene.remove(obj));
            skeletonObjects = [];

            if (!landmarks || landmarks.length === 0) {
                skeletonRenderer.render(skeletonScene, skeletonCamera);
                return;
            }

            const color = getSkeletonStageColor(stage);

            // MediaPipe pose connections (main body)
            const connections = [
                [11, 12], [11, 23], [12, 24], [23, 24],  // Torso
                [11, 13], [13, 15],  // Left arm
                [12, 14], [14, 16],  // Right arm
                [23, 25], [25, 27],  // Left leg
                [24, 26], [26, 28]   // Right leg
            ];

            // Calculate center for normalization
            let centerX = 0, centerY = 0, centerZ = 0;
            let validCount = 0;

            landmarks.forEach(lm => {
                if (!lm) return;
                const vis = lm.visibility !== undefined ? lm.visibility : 1;
                if (vis >= 0.3) {
                    centerX += lm.x !== undefined ? lm.x : (lm[0] || 0);
                    centerY += lm.y !== undefined ? lm.y : (lm[1] || 0);
                    centerZ += lm.z !== undefined ? lm.z : (lm[2] || 0);
                    validCount++;
                }
            });

            if (validCount === 0) {
                skeletonRenderer.render(skeletonScene, skeletonCamera);
                return;
            }

            centerX /= validCount;
            centerY /= validCount;
            centerZ /= validCount;

            // Calculate scale based on shoulder width
            let scale = 4.0;
            if (landmarks[11] && landmarks[12]) {
                const lx = landmarks[11].x !== undefined ? landmarks[11].x : (landmarks[11][0] || 0);
                const rx = landmarks[12].x !== undefined ? landmarks[12].x : (landmarks[12][0] || 0);
                const shoulderWidth = Math.abs(lx - rx);
                scale = Math.max(3.0, Math.min(6.0, 1.0 / (shoulderWidth + 0.1)));
            }

            // Helper to get 3D position
            const getPos3D = (lm) => {
                if (!lm) return null;
                const x = (lm.x !== undefined ? lm.x : (lm[0] || 0)) - centerX;
                const y = -((lm.y !== undefined ? lm.y : (lm[1] || 0)) - centerY);  // Flip Y
                const z = ((lm.z !== undefined ? lm.z : (lm[2] || 0)) - centerZ) * 0.5;
                return { x: x * scale * 2, y: y * scale * 2, z: z * scale };
            };

            // Draw joints (spheres)
            landmarks.forEach((lm, i) => {
                if (!lm) return;
                const vis = lm.visibility !== undefined ? lm.visibility : 1;
                if (vis < 0.3) return;

                const pos = getPos3D(lm);
                if (!pos) return;

                const geo = new THREE.SphereGeometry(0.08, 16, 16);
                const mat = new THREE.MeshLambertMaterial({ color });
                const sphere = new THREE.Mesh(geo, mat);
                sphere.position.set(pos.x, pos.y, pos.z);
                skeletonScene.add(sphere);
                skeletonObjects.push(sphere);
            });

            // Draw bones (lines)
            connections.forEach(([i, j]) => {
                const a = landmarks[i], b = landmarks[j];
                if (!a || !b) return;

                const posA = getPos3D(a);
                const posB = getPos3D(b);
                if (!posA || !posB) return;

                const points = [
                    new THREE.Vector3(posA.x, posA.y, posA.z),
                    new THREE.Vector3(posB.x, posB.y, posB.z)
                ];
                const geo = new THREE.BufferGeometry().setFromPoints(points);
                const mat = new THREE.LineBasicMaterial({ color, linewidth: 2 });
                const line = new THREE.Line(geo, mat);
                skeletonScene.add(line);
                skeletonObjects.push(line);
            });

            skeletonRenderer.render(skeletonScene, skeletonCamera);
        }

        // Animation loop
        function animateSkeleton() {
            const poseData = window.userPoseData;
            if (!isSkeletonPlaying || !poseData || poseData.length === 0) return;

            const frame = poseData[currentSkeletonFrameIndex];
            if (frame && frame.landmarks) {
                updateSkeletonFrame(frame.landmarks, frame.state);
            }

            // Update slider and counter
            const slider = document.getElementById('frameSlider');
            const counter = document.getElementById('frameCounter');
            if (slider) slider.value = currentSkeletonFrameIndex;
            if (counter) counter.textContent = `${currentSkeletonFrameIndex + 1} / ${poseData.length}`;

            currentSkeletonFrameIndex = (currentSkeletonFrameIndex + 1) % poseData.length;

            if (isSkeletonPlaying) {
                skeletonAnimationId = setTimeout(() => {
                    requestAnimationFrame(animateSkeleton);
                }, 33); // ~30fps
            }
        }

        // Basketball sayings to shuffle during extraction
        const BASKETBALL_SAYINGS = [
            "Watching the ball...",
            "Reading the follow-through...",
            "Checking the elbow tuck...",
            "Analyzing the release point...",
            "Studying the footwork...",
            "Tracking the wrist snap...",
            "Measuring knee bend...",
            "Ball don't lie...",
            "Shooters shoot...",
            "Nothing but net...",
            "Checking your arc...",
            "Eyes on the rim...",
            "Feeling the rhythm...",
            "Swish incoming...",
            "Locking in the form..."
        ];
        let sayingInterval = null;

        function startSayingsShuffle() {
            const el = document.getElementById('processingSaying');
            if (!el) return;
            let idx = Math.floor(Math.random() * BASKETBALL_SAYINGS.length);
            el.textContent = BASKETBALL_SAYINGS[idx];
            sayingInterval = setInterval(() => {
                idx = (idx + 1 + Math.floor(Math.random() * (BASKETBALL_SAYINGS.length - 1))) % BASKETBALL_SAYINGS.length;
                el.style.opacity = '0';
                setTimeout(() => {
                    el.textContent = BASKETBALL_SAYINGS[idx];
                    el.style.opacity = '1';
                }, 200);
            }, 2200);
        }

        function stopSayingsShuffle() {
            if (sayingInterval) { clearInterval(sayingInterval); sayingInterval = null; }
            const el = document.getElementById('processingSaying');
            if (el) el.textContent = '';
        }

        // Process uploaded video through MediaPipe to extract skeleton
        async function processVideoForSkeleton() {
            const video = document.getElementById('userVideo');
            console.log('processVideoForSkeleton called, video:', video, 'src:', video?.src);

            if (!video || !video.src) {
                console.log('No video to process - video element or src missing');
                return false;
            }

            // Show processing overlay
            const processingOverlay = document.getElementById('skeletonProcessing');
            const statusEl = document.getElementById('processingStatus');
            console.log('Processing overlay:', processingOverlay);
            if (processingOverlay) processingOverlay.style.display = 'flex';
            startSayingsShuffle();

            try {
                // Wait for video to be ready
                await new Promise((resolve) => {
                    if (video.readyState >= 2) resolve();
                    else video.addEventListener('loadeddata', resolve, { once: true });
                });

                // Create hidden canvas for processing
                const processCanvas = document.createElement('canvas');
                processCanvas.width = 640;
                processCanvas.height = 480;
                const ctx = processCanvas.getContext('2d');

                // Check if MediaPipe Pose is available
                if (typeof Pose === 'undefined') {
                    console.error('MediaPipe Pose not loaded');
                    if (statusEl) statusEl.textContent = 'Loading pose detection...';
                    // MediaPipe should be loaded from tool/app.js or index.html
                    return false;
                }

                console.log('Initializing MediaPipe Pose...');

                // Initialize MediaPipe Pose
                const pose = new Pose({
                    locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`
                });

                pose.setOptions({
                    modelComplexity: 1,
                    smoothLandmarks: true,
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });

                const extractedFrames = [];
                let frameCount = 0;

                // Process frames
                pose.onResults((results) => {
                    if (results.poseLandmarks) {
                        // Convert landmarks to our format
                        const landmarks = results.poseLandmarks.map((lm, i) => ({
                            x: lm.x,
                            y: lm.y,
                            z: lm.z || 0,
                            visibility: lm.visibility || 1
                        }));

                        // Detect shot stage based on arm position
                        let state = 'neutral';
                        const rightWrist = landmarks[16];
                        const rightShoulder = landmarks[12];
                        if (rightWrist && rightShoulder) {
                            if (rightWrist.y < rightShoulder.y - 0.1) state = 'follow_through';
                            else if (rightWrist.y < rightShoulder.y + 0.05) state = 'pre_shot';
                        }

                        extractedFrames.push({
                            state: state,
                            time: frameCount / 30,
                            landmarks: landmarks
                        });
                    }
                    frameCount++;
                });

                await pose.initialize();

                // Sample frames from video
                const duration = video.duration;
                const fps = 15; // Sample at 15fps for smooth animation
                const totalFrames = Math.min(Math.floor(duration * fps), 90); // Max 90 frames (6 seconds)

                for (let i = 0; i < totalFrames; i++) {
                    const time = (i / totalFrames) * duration;
                    video.currentTime = time;

                    await new Promise(resolve => {
                        video.onseeked = resolve;
                    });

                    // Draw frame to canvas
                    ctx.drawImage(video, 0, 0, processCanvas.width, processCanvas.height);

                    // Process through MediaPipe
                    await pose.send({ image: processCanvas });

                    // Update status
                    if (statusEl) {
                        const percent = Math.round((i + 1) / totalFrames * 100);
                        statusEl.textContent = `Extracting skeleton... ${percent}%`;
                    }
                }

                // Close pose
                pose.close();

                // Store extracted data
                if (extractedFrames.length > 0) {
                    window.userPoseData = extractedFrames;
                    console.log(`Extracted ${extractedFrames.length} skeleton frames`);

                    // Hide processing overlay, stop sayings
                    stopSayingsShuffle();
                    if (processingOverlay) processingOverlay.style.display = 'none';

                    // Reset video to start
                    video.currentTime = 0;

                    return true;
                } else {
                    stopSayingsShuffle();
                    if (statusEl) statusEl.textContent = 'No pose detected in video';
                    setTimeout(() => {
                        if (processingOverlay) processingOverlay.style.display = 'none';
                    }, 2000);
                    return false;
                }

            } catch (error) {
                console.error('Error processing video:', error);
                stopSayingsShuffle();
                if (statusEl) statusEl.textContent = 'Error processing video';
                setTimeout(() => {
                    if (processingOverlay) processingOverlay.style.display = 'none';
                }, 2000);
                return false;
            }
        }

        // Start skeleton viewer with recorded data
        function startSkeletonViewer() {
            let poseData = window.userPoseData;

            // If no pose data, cannot start
            if (!poseData || poseData.length === 0) {
                console.log('No pose data available for skeleton viewer');
                return;
            }

            const canvas = document.getElementById('skeletonCanvas3d');
            if (!canvas) {
                console.log('Skeleton canvas not found');
                return;
            }

            // Initialize if needed
            if (!skeletonScene) {
                initSkeletonViewer(canvas);
            }

            // Setup slider
            const slider = document.getElementById('frameSlider');
            if (slider) {
                slider.max = poseData.length - 1;
                slider.value = 0;
            }

            // Update counter
            const counter = document.getElementById('frameCounter');
            if (counter) counter.textContent = `1 / ${poseData.length}`;

            currentSkeletonFrameIndex = 0;
            isSkeletonPlaying = true;

            // Update play button
            const playBtn = document.getElementById('playPauseLoop');
            if (playBtn) playBtn.textContent = '';

            animateSkeleton();
            console.log(`Skeleton viewer started with ${poseData.length} frames`);
        }

        // Stop skeleton viewer
        function stopSkeletonViewer() {
            isSkeletonPlaying = false;
            if (skeletonAnimationId) {
                clearTimeout(skeletonAnimationId);
                skeletonAnimationId = null;
            }
        }

        // Setup skeleton viewer controls on DOM load
        document.addEventListener('DOMContentLoaded', function() {
            // Slider event - scrub through frames
            const slider = document.getElementById('frameSlider');
            if (slider) {
                slider.addEventListener('input', function(e) {
                    isSkeletonPlaying = false;
                    const playBtn = document.getElementById('playPauseLoop');
                    if (playBtn) playBtn.textContent = '';

                    currentSkeletonFrameIndex = parseInt(e.target.value);
                    const poseData = window.userPoseData;
                    if (poseData && poseData[currentSkeletonFrameIndex]) {
                        const frame = poseData[currentSkeletonFrameIndex];
                        updateSkeletonFrame(frame.landmarks, frame.state);

                        const counter = document.getElementById('frameCounter');
                        if (counter) counter.textContent = `${currentSkeletonFrameIndex + 1} / ${poseData.length}`;
                    }
                });
            }

            // Play/Pause button
            const playBtn = document.getElementById('playPauseLoop');
            if (playBtn) {
                playBtn.addEventListener('click', function() {
                    isSkeletonPlaying = !isSkeletonPlaying;
                    this.textContent = isSkeletonPlaying ? '' : '';
                    if (isSkeletonPlaying) animateSkeleton();
                });
            }

            // Camera X position control (horizontal)
            const cameraXSlider = document.getElementById('cameraX');
            if (cameraXSlider) {
                cameraXSlider.addEventListener('input', function(e) {
                    if (skeletonCamera) {
                        skeletonCamera.position.x = parseFloat(e.target.value);
                        if (skeletonRenderer && skeletonScene) {
                            skeletonRenderer.render(skeletonScene, skeletonCamera);
                        }
                    }
                });
            }

            // Camera Y position control (vertical)
            const cameraYSlider = document.getElementById('cameraY');
            if (cameraYSlider) {
                cameraYSlider.addEventListener('input', function(e) {
                    if (skeletonCamera) {
                        skeletonCamera.position.y = parseFloat(e.target.value);
                        if (skeletonRenderer && skeletonScene) {
                            skeletonRenderer.render(skeletonScene, skeletonCamera);
                        }
                    }
                });
            }

            // Camera zoom control
            const cameraZoomSlider = document.getElementById('cameraZoom');
            if (cameraZoomSlider) {
                cameraZoomSlider.addEventListener('input', function(e) {
                    if (skeletonCamera) {
                        skeletonCamera.position.z = parseFloat(e.target.value);
                        if (skeletonRenderer && skeletonScene) {
                            skeletonRenderer.render(skeletonScene, skeletonCamera);
                        }
                    }
                });
            }
        });
    </script>

    <!-- Analysis Type Selection Logic -->
    <script>
        // Show analysis selection after video is ready
        function showAnalysisOptions() {
            const selection = document.getElementById('analysisTypeSelection');
            if (selection) {
                selection.style.display = 'block';
            }
            // Hide the control buttons
            const controlsDiv = document.getElementById('recordingControls');
            if (controlsDiv) controlsDiv.style.display = 'none';
            // Hide file name display
            const fileName = document.getElementById('uploadedFileName');
            if (fileName) fileName.style.display = 'none';
            // Hide the old "Analyze Video" button
            const processBtn = document.getElementById('processUserVideo');
            if (processBtn) {
                processBtn.style.display = 'none';
            }
            // Hide body warning overlay (pink)
            const bodyWarning = document.getElementById('userBodyWarning');
            if (bodyWarning) bodyWarning.style.display = 'none';
            // Hide user status
            const userStatus = document.getElementById('userStatus');
            if (userStatus) userStatus.style.display = 'none';
            // Show skeleton viewer overlay
            const readyOverlay = document.getElementById('videoReadyOverlay');
            if (readyOverlay) readyOverlay.style.display = 'flex';

            // Show processing overlay immediately
            const processingOverlay = document.getElementById('skeletonProcessing');
            if (processingOverlay) processingOverlay.style.display = 'flex';

            // Helper to show the "Video Ready" state instead of skeleton viewer
            function showVideoReadyState() {
                // Hide skeleton canvas and controls, show ready state
                const canvas = document.getElementById('skeletonCanvas3d');
                const controls = document.querySelector('.skeleton-controls');
                const readyState = document.getElementById('videoReadyState');
                if (canvas) canvas.style.display = 'none';
                if (controls) controls.style.display = 'none';
                if (readyState) readyState.style.display = 'flex';
            }

            // Note: Angle extraction is now handled in the video upload handler
            // to avoid duplicate calls

            // Process video and extract skeleton data (but don't show skeleton viewer)
            setTimeout(async () => {
                try {
                    if (window.userPoseData && window.userPoseData.length > 0) {
                        console.log('Using existing pose data');
                        stopSayingsShuffle();
                        if (processingOverlay) processingOverlay.style.display = 'none';
                        showVideoReadyState();
                    } else {
                        console.log('Processing video for skeleton...');
                        const success = await processVideoForSkeleton();
                        if (processingOverlay) processingOverlay.style.display = 'none';
                        if (success) {
                            console.log('Processing succeeded, video ready');
                            showVideoReadyState();
                        } else {
                            console.log('Processing failed, using demo data');
                            window.userPoseData = generateDemoSkeletonData();
                            showVideoReadyState();
                        }
                    }
                } catch (error) {
                    console.error('Error in skeleton processing:', error);
                    stopSayingsShuffle();
                    if (processingOverlay) processingOverlay.style.display = 'none';
                    window.userPoseData = generateDemoSkeletonData();
                    showVideoReadyState();
                }
            }, 200);
        }

        // Generate demo skeleton data for fallback
        function generateDemoSkeletonData() {
            const frames = [];
            const totalFrames = 60;

            for (let i = 0; i < totalFrames; i++) {
                const progress = i / totalFrames;
                let state = progress < 0.2 ? 'neutral' : progress < 0.7 ? 'pre_shot' : 'follow_through';

                const armRaise = Math.sin(progress * Math.PI) * 0.3;
                const landmarks = [];

                for (let j = 0; j < 33; j++) {
                    let x = 0.5, y = 0.5, z = 0;
                    switch(j) {
                        case 11: x = 0.35; y = 0.3; break;
                        case 12: x = 0.65; y = 0.3; break;
                        case 13: x = 0.25; y = 0.45; break;
                        case 14: x = 0.75; y = 0.3 - armRaise; break;
                        case 15: x = 0.2; y = 0.55; break;
                        case 16: x = 0.8; y = 0.2 - armRaise * 1.2; break;
                        case 23: x = 0.4; y = 0.55; break;
                        case 24: x = 0.6; y = 0.55; break;
                        case 25: x = 0.38; y = 0.72; break;
                        case 26: x = 0.62; y = 0.72; break;
                        case 27: x = 0.36; y = 0.9; break;
                        case 28: x = 0.64; y = 0.9; break;
                    }
                    landmarks.push({ x, y, z, visibility: 1.0 });
                }

                frames.push({ state, time: i / 30, landmarks });
            }
            return frames;
        }

        // Go back to recording/upload state
        function goBackToRecord() {
            // Hide analysis selection
            const selection = document.getElementById('analysisTypeSelection');
            if (selection) selection.style.display = 'none';
            // Show the control buttons
            const controlsDiv = document.getElementById('recordingControls');
            if (controlsDiv) controlsDiv.style.display = 'flex';
            // Show file name display
            const fileName = document.getElementById('uploadedFileName');
            if (fileName) {
                fileName.style.display = 'block';
                fileName.textContent = '';
            }
            // Hide overlays
            const readyOverlay = document.getElementById('videoReadyOverlay');
            if (readyOverlay) readyOverlay.style.display = 'none';
            const runningOverlay = document.getElementById('analysisRunningOverlay');
            if (runningOverlay) runningOverlay.style.display = 'none';
            // Reset video
            const video = document.getElementById('userVideo');
            if (video) {
                video.src = '';
                video.load();
            }
            // Clear file input
            const fileInput = document.getElementById('userVideoUpload');
            if (fileInput) fileInput.value = '';
            // Deselect analysis buttons
            document.querySelectorAll('.analysis-type-btn').forEach(b => b.classList.remove('selected'));
            // Clear recorded pose data
            window.recordedUserPoseData = null;
            window.userPoseData = null;
            if (typeof userPoseData !== 'undefined') {
                userPoseData = [];
            }
            // Stop skeleton viewer and reset ready state
            stopSkeletonViewer();
            const readyState = document.getElementById('videoReadyState');
            if (readyState) readyState.style.display = 'none';
            const canvas = document.getElementById('skeletonCanvas3d');
            const skeletonControls = document.querySelector('.skeleton-controls');
            if (canvas) canvas.style.display = '';
            if (skeletonControls) skeletonControls.style.display = '';
        }

        // Shot count modal handler and mode management
        let skipModalOnce = false; // Flag to bypass modal after confirmation

        (function() {
            let handlerAttached = false;

            function attachHandler() {
                if (handlerAttached) return;
                handlerAttached = true;

                const modal = document.getElementById('shotCountModal');
                const shotCountInput = document.getElementById('shotCountInput');
                const confirmBtn = document.getElementById('confirmRecordingBtn');
                const cancelBtn = document.getElementById('cancelRecordingBtn');
                const startUserBtn = document.getElementById('startUser');

                // Clamp input value on change
                if (shotCountInput) {
                    shotCountInput.addEventListener('change', function(e) {
                        let value = parseInt(e.target.value);
                        if (isNaN(value) || value < 1) value = 1;
                        if (value > 10) value = 10;
                        e.target.value = value;
                    });
                }

                // Intercept START RECORDING click to show modal first
                if (startUserBtn && modal) {
                    startUserBtn.addEventListener('click', function(e) {
                        // Skip modal if coming from confirm button
                        if (skipModalOnce) {
                            skipModalOnce = false;
                            return; // Let the click proceed to original handlers
                        }

                        // Show modal instead of starting recording
                        e.preventDefault();
                        e.stopPropagation();
                        e.stopImmediatePropagation();
                        modal.style.display = 'flex';
                        if (shotCountInput) shotCountInput.focus();
                    }, true); // Capture phase to intercept before other handlers
                }

                // Handle CONFIRM button - set shot count and trigger recording
                if (confirmBtn) {
                    confirmBtn.addEventListener('click', function() {
                        isUploadMode = false;
                        if (shotCountInput) {
                            let value = parseInt(shotCountInput.value);
                            if (isNaN(value) || value < 1) value = 1;
                            if (value > 10) value = 10;
                            selectedShotCount = value;
                        }
                        console.log('Recording mode: selectedShotCount =', selectedShotCount);

                        // Hide modal
                        if (modal) modal.style.display = 'none';
                        hideShotDetectionStatus();

                        // Set flag to skip modal on next click, then trigger recording
                        skipModalOnce = true;
                        const startBtn = document.getElementById('startUser');
                        if (startBtn) {
                            startBtn.click();
                        }
                    });
                }

                // Handle CANCEL button - just close modal
                if (cancelBtn) {
                    cancelBtn.addEventListener('click', function() {
                        if (modal) modal.style.display = 'none';
                    });
                }

                // Close modal on overlay click
                if (modal) {
                    modal.addEventListener('click', function(e) {
                        if (e.target === modal) {
                            modal.style.display = 'none';
                        }
                    });
                }
            }

            // Attach immediately if DOM is ready
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', attachHandler);
            } else {
                attachHandler();
            }
        })();

        // Function to show shot detection status message
        function showShotDetectionStatus(count, isError = false) {
            const statusDiv = document.getElementById('shotDetectionStatus');
            const messageDiv = document.getElementById('shotDetectionMessage');
            if (!statusDiv || !messageDiv) return;

            statusDiv.style.display = 'block';

            if (count === 0) {
                messageDiv.style.background = 'rgba(239, 68, 68, 0.2)';
                messageDiv.style.border = '1px solid #ef4444';
                messageDiv.style.color = '#ef4444';
                messageDiv.textContent = ' No shots detected. Please upload a video with clear shooting motion.';
            } else if (count > 10) {
                messageDiv.style.background = 'rgba(251, 191, 36, 0.2)';
                messageDiv.style.border = '1px solid #fbbf24';
                messageDiv.style.color = '#fbbf24';
                messageDiv.textContent = ` ${count} shots detected. Only the first 10 will be analyzed.`;
            } else {
                messageDiv.style.background = 'rgba(74, 222, 128, 0.2)';
                messageDiv.style.border = '1px solid #4ade80';
                messageDiv.style.color = '#4ade80';
                messageDiv.textContent = ` ${count} shot${count !== 1 ? 's' : ''} detected successfully!`;
            }
        }

        // Function to hide shot detection status
        function hideShotDetectionStatus() {
            const statusDiv = document.getElementById('shotDetectionStatus');
            if (statusDiv) statusDiv.style.display = 'none';
        }

        // Override the userVideoUpload change handler to show analysis options
        document.addEventListener('DOMContentLoaded', function() {
            const userVideoUpload = document.getElementById('userVideoUpload');
            if (userVideoUpload) {
                userVideoUpload.addEventListener('change', function(e) {
                    const file = e.target.files[0];
                    if (file) {
                        // Set upload mode - auto-detect shots (no limit)
                        isUploadMode = true;
                        selectedShotCount = 999; // High number to detect all shots
                        console.log('Upload mode: auto-detecting shots');

                        // Hide shot count selector and status for uploads
                        const shotCountSelector = document.getElementById('shotCountSelector');
                        if (shotCountSelector) shotCountSelector.style.display = 'none';
                        hideShotDetectionStatus();

                        // Set video src to uploaded file
                        const video = document.getElementById('userVideo');
                        if (video) {
                            // Revoke previous blob URL if it exists
                            if (video.src && video.src.startsWith('blob:')) {
                                URL.revokeObjectURL(video.src);
                            }

                            const url = URL.createObjectURL(file);
                            console.log('Setting video src to blob URL:', url.substring(0, 50));
                            video.src = url;
                            video.load();

                            // Store file reference for later use
                            video.uploadedFile = file;

                            // Wait for video to load, then show analysis options and extract angles
                            const onLoaded = async function() {
                                console.log('Video loaded:', {
                                    src: video.src.substring(0, 50),
                                    readyState: video.readyState,
                                    width: video.videoWidth,
                                    height: video.videoHeight,
                                    duration: video.duration
                                });

                                // Show analysis options
                                showAnalysisOptions();

                                // Display file name
                                const fileName = document.getElementById('uploadedFileName');
                                if (fileName) {
                                    fileName.textContent = `Selected: ${file.name}`;
                                    fileName.style.display = 'block';
                                }

                                // Automatically extract angles silently (for Ideal Form metrics)
                                try {
                                    console.log('Starting automatic angle extraction...');
                                    await generateLoop(true); // Extract angles silently
                                    console.log('Angles extracted automatically from video');

                                    // Show shot detection status for upload mode
                                    if (isUploadMode && detectedShots) {
                                        const shotCount = detectedShots.length;
                                        showShotDetectionStatus(shotCount);
                                        console.log(`Upload mode: detected ${shotCount} shots`);
                                    }
                                } catch (error) {
                                    console.error('Error extracting angles:', error);
                                    if (isUploadMode) {
                                        showShotDetectionStatus(0);
                                    }
                                }
                            };

                            // Wait for video to be ready
                            const waitForVideo = async () => {
                                // Wait for metadata
                                if (video.readyState < 2) {
                                    await new Promise((resolve) => {
                                        if (video.readyState >= 2) {
                                            resolve();
                                        } else {
                                            video.addEventListener('loadedmetadata', resolve, { once: true });
                                            setTimeout(resolve, 5000); // Timeout after 5 seconds
                                        }
                                    });
                                }

                                // Wait for data
                                if (video.readyState < 3) {
                                    await new Promise((resolve) => {
                                        if (video.readyState >= 3) {
                                            resolve();
                                        } else {
                                            video.addEventListener('loadeddata', resolve, { once: true });
                                            setTimeout(resolve, 5000); // Timeout after 5 seconds
                                        }
                                    });
                                }

                                // Now call onLoaded
                                onLoaded();
                            };

                            // Add error handler
                            video.addEventListener('error', function(e) {
                                console.error('Video load error:', e);
                                alert('Error loading video. Please try a different file.');
                            }, { once: true });

                            // Start waiting
                            waitForVideo();
                        }
                    }
                });
            }

            // Handle analysis type button clicks
            document.querySelectorAll('.analysis-type-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    // Skip if this is the back button
                    if (this.id === 'backToRecordBtn') return;

                    // Handle animation button separately
                    const analysisType = this.dataset.type;
                    if (analysisType === 'animation') {
                        // Show 3D loop animation (if already generated)
                        if (loop3DPoses.length > 0) {
                            // Show skeleton viewer and start animation
                            const readyOverlay = document.getElementById('videoReadyOverlay');
                            if (readyOverlay) readyOverlay.style.display = 'flex';
                            
                            // Initialize and start animation
                            if (!loopScene || !loopRenderer) {
                                initLoop3DViewer();
                            }
                            
                            // Update slider
                            const slider = document.getElementById('frameSlider');
                            if (slider) {
                                slider.max = loop3DPoses.length - 1;
                                slider.value = 0;
                            }
                            
                            // Start playing
                            isLoopPlaying = true;
                            currentLoopFrameIndex = 0;
                            const playBtn = document.getElementById('playPauseLoop');
                            const pauseBtn = document.getElementById('pauseLoopBtn');
                            if (playBtn) playBtn.style.display = 'none';
                            if (pauseBtn) pauseBtn.style.display = 'inline-block';
                            animateLoop();
                        } else {
                            // Generate animation if not already done
                            generateLoop().then(() => {
                                // After generation, start animation
                                if (loop3DPoses.length > 0) {
                                    isLoopPlaying = true;
                                    currentLoopFrameIndex = 0;
                                    const playBtn = document.getElementById('playPauseLoop');
                                    const pauseBtn = document.getElementById('pauseLoopBtn');
                                    if (playBtn) playBtn.style.display = 'none';
                                    if (pauseBtn) pauseBtn.style.display = 'inline-block';
                                    animateLoop();
                                }
                            });
                        }
                        return;
                    }

                    // Visual feedback - select this button
                    document.querySelectorAll('.analysis-type-btn').forEach(b => b.classList.remove('selected'));
                    this.classList.add('selected');

                    // Store the selected type
                    window.selectedAnalysisType = analysisType;

                    // Hide "Video Ready" overlay, show "Running Analysis" overlay
                    const readyOverlay = document.getElementById('videoReadyOverlay');
                    if (readyOverlay) readyOverlay.style.display = 'none';
                    const runningOverlay = document.getElementById('analysisRunningOverlay');
                    if (runningOverlay) runningOverlay.style.display = 'flex';

                    // Run the analysis based on type
                    if (analysisType === 'similarity') {
                        // Player Match - compare with all benchmarks
                        console.log('Player Match clicked. Checking if angles have been extracted...');
                        
                        // Sync with window variables (for webcam recording)
                        const poses = (loop3DPoses && loop3DPoses.length > 0) ? loop3DPoses : (window.loop3DPoses || []);
                        const angles = (loop3DAngles && loop3DAngles.length > 0) ? loop3DAngles : (window.loop3DAngles || []);
                        const anglesExtracted = window.anglesExtracted || (angles.length > 0);
                        
                        // Check if angles have been extracted, if not, extract them first
                        if (!angles || angles.length === 0 || !anglesExtracted) {
                            // Check if we have webcam data but no angles - this shouldn't happen, but handle it
                            if (poses.length > 0 && angles.length === 0) {
                                console.log(' Webcam data found but angles missing. Using poses directly...');
                                // For webcam, angles should already be in metrics, so proceed
                                runPlayerMatchComparison();
                                return;
                            }
                            
                            console.log(' Angles not extracted yet. Extracting angles from video first...');
                            if (runningOverlay) {
                                runningOverlay.style.display = 'flex';
                                const statusText = runningOverlay.querySelector('p');
                                if (statusText) {
                                    statusText.textContent = 'Extracting angles from video...';
                                }
                            }
                            
                            // Extract angles silently
                            generateLoop(true).then(() => {
                                console.log(' Angles extracted. Now comparing with benchmarks...');
                                // Continue with comparison below
                                runPlayerMatchComparison();
                            }).catch(error => {
                                console.error('Error extracting angles:', error);
                                alert('Error extracting angles from video: ' + error.message);
                                if (runningOverlay) runningOverlay.style.display = 'none';
                            });
                            return;
                        }
                        
                        // Angles already extracted, proceed with comparison
                        runPlayerMatchComparison();
                    }
                    
                    function runPlayerMatchComparison() {
                        // Player Match - compare with all benchmarks
                        console.log('Comparing with all benchmarks...');
                        
                        // Sync with window variables (for webcam recording)
                        const poses = (loop3DPoses && loop3DPoses.length > 0) ? loop3DPoses : (window.loop3DPoses || []);
                        const angles = (loop3DAngles && loop3DAngles.length > 0) ? loop3DAngles : (window.loop3DAngles || []);
                        const stages = (loop3DStages && loop3DStages.length > 0) ? loop3DStages : (window.loop3DStages || []);
                        
                        // Convert loop3DPoses and loop3DAngles to format expected by compareDetailedMetrics
                        const convertToUserData = () => {
                            console.log('convertToUserData called:', {
                                hasLoop3DPoses: !!poses,
                                posesLength: poses?.length || 0,
                                hasLoop3DAngles: !!angles,
                                anglesLength: angles?.length || 0,
                                hasLoop3DStages: !!stages,
                                stagesLength: stages?.length || 0
                            });
                            
                            if (!poses || poses.length === 0) {
                                console.error('No loop3DPoses data available');
                                alert('No video data found. Please record a shot or upload a video first.');
                                return null;
                            }
                            
                            if (!angles || angles.length === 0) {
                                console.error(' No loop3DAngles data available! Angles were not extracted from the video.');
                                console.error('This means the video was not processed through generateLoop() or angles were not calculated.');
                                alert('No angle data found. Please record a shot or upload a video first.');
                                return null;
                            }
                            
                            const userData = [];
                            for (let i = 0; i < poses.length; i++) {
                                const frameData = {
                                    state: stages[i] || 'neutral',
                                    time: i * (1/30), // Assuming 30 fps
                                    elbow_angle: null,
                                    wrist_angle: null,
                                    arm_angle: null,
                                    landmarks: poses[i] || [],
                                    metrics: {}
                                };
                                
                                // Extract angles from loop3DAngles if available
                                if (angles && angles[i]) {
                                    const angleData = angles[i];
                                    
                                    // Log first frame to verify calculations
                                    if (i === 0) {
                                        console.log(' Angles extracted from video! Sample angles from first frame:', angleData);
                                        console.log('Available angle keys:', Object.keys(angleData));
                                    }
                                    
                                    // Map angles to frame data
                                    if (angleData.right_elbow !== null && angleData.right_elbow !== undefined) {
                                        frameData.elbow_angle = angleData.right_elbow;
                                    }
                                    if (angleData.wrist_snap !== null && angleData.wrist_snap !== undefined) {
                                        frameData.wrist_angle = angleData.wrist_snap;
                                    }
                                    // Add other angles if available
                                    if (angleData.left_elbow !== null && angleData.left_elbow !== undefined) {
                                        frameData.arm_angle = angleData.left_elbow;
                                    }
                                    
                                    // Store ALL angles in metrics (including elbow_flare, wrist_snap, etc.)
                                    frameData.metrics = { ...angleData };
                                }
                                
                                userData.push(frameData);
                            }
                            
                            return userData;
                        };
                        
                        const userData = convertToUserData();
                        
                        if (!userData || userData.length === 0) {
                            console.error(' Failed to convert user data. Check if video was processed and angles were extracted.');
                            alert('Error: No user data available. Please ensure the video has been processed by clicking "Generate Animation" first.');
                            console.error('No user data available for comparison');
                            if (runningOverlay) runningOverlay.style.display = 'none';
                            document.getElementById('step2').style.display = 'none';
                            document.getElementById('step3').style.display = 'block';
                            document.getElementById('playerMatchResults').classList.add('active');
                            document.getElementById('idealFormResults').classList.remove('active');
                            return;
                        }
                        
                        // Show loading state
                        if (runningOverlay) {
                            runningOverlay.style.display = 'flex';
                            const statusText = runningOverlay.querySelector('p');
                            if (statusText) {
                                statusText.textContent = 'Comparing with all benchmarks...';
                            }
                        }
                        
                        // Compare with all benchmarks (with timeout)
                        if (window.compareWithAllBenchmarks) {
                            console.log('Starting comparison with all benchmarks...');
                            console.log('User data:', {
                                frames: userData.length,
                                hasMetrics: userData[0]?.metrics ? Object.keys(userData[0].metrics).length : 0,
                                sampleMetrics: userData[0]?.metrics || {}
                            });
                            
                            // Verify benchmark files are available
                            if (window.getAllBenchmarkFiles) {
                                window.getAllBenchmarkFiles().then(files => {
                                    console.log('Available benchmark files:', files);
                                }).catch(err => {
                                    console.error('Error getting benchmark files:', err);
                                });
                            }
                            
                            // Add timeout to prevent hanging
                            const timeoutPromise = new Promise((_, reject) => {
                                setTimeout(() => reject(new Error('Comparison timeout after 60 seconds')), 60000);
                            });
                            
                            Promise.race([
                                window.compareWithAllBenchmarks(userData),
                                timeoutPromise
                            ]).then(matches => {
                                console.log('=== Player Match Results ===');
                                console.log('Number of matches:', matches?.length || 0);
                                console.log('Matches:', matches);
                                
                                if (!matches || matches.length === 0) {
                                    console.warn(' No matches found. This could mean:');
                                    console.warn('  1. All benchmark comparisons returned 0% similarity');
                                    console.warn('  2. All benchmarks have missing/null metrics');
                                    console.warn('  3. User data has missing/null metrics');
                                    console.warn('  4. No benchmark files were found');
                                    console.warn('Check the console logs above for detailed comparison results.');
                                }
                                
                                // Store matches globally for Ideal Form comparison
                                window.topPlayerMatches = matches || [];
                                window.topPlayerMatch = matches && matches.length > 0 ? matches[0] : null;
                                
                                // Update UI with results (even if empty, to clear hardcoded content)
                                if (window.updatePlayerMatchUI) {
                                    window.updatePlayerMatchUI(matches || []);
                                } else {
                                    console.error('updatePlayerMatchUI function not available!');
                                }
                                
                                // Always hide overlay
                                if (runningOverlay) runningOverlay.style.display = 'none';
                                document.getElementById('step2').style.display = 'none';
                                document.getElementById('step3').style.display = 'block';
                                document.getElementById('playerMatchResults').classList.add('active');
                                document.getElementById('idealFormResults').classList.remove('active');
                            }).catch(error => {
                                console.error('Error comparing with benchmarks:', error);
                                // Always hide overlay even on error
                                if (runningOverlay) runningOverlay.style.display = 'none';
                                document.getElementById('step2').style.display = 'none';
                                document.getElementById('step3').style.display = 'block';
                                document.getElementById('playerMatchResults').classList.add('active');
                                document.getElementById('idealFormResults').classList.remove('active');
                                
                                // Show error message
                                alert('Error comparing with benchmarks: ' + error.message);
                            });
                        } else {
                            console.error('compareWithAllBenchmarks function not available');
                            // Always hide overlay
                            if (runningOverlay) runningOverlay.style.display = 'none';
                            document.getElementById('step2').style.display = 'none';
                            document.getElementById('step3').style.display = 'block';
                            document.getElementById('playerMatchResults').classList.add('active');
                            document.getElementById('idealFormResults').classList.remove('active');
                        }
                    }
                    
                    if (analysisType === 'ideal') {
                        // Ideal Form - calculate metrics and compare with top match
                        console.log('Calculating Ideal Form metrics from angles...');
                        
                        // Wait for angles to be extracted if not ready yet
                        const checkAngles = () => {
                            if (loop3DAngles && loop3DAngles.length > 0) {
                                // Check if we have a top match to compare against
                                if (window.topPlayerMatch && window.topPlayerMatch.comparison) {
                                    calculateIdealFormMetricsWithComparison(window.topPlayerMatch);
                                } else {
                                calculateIdealFormMetrics();
                                }
                                setTimeout(() => {
                                    if (runningOverlay) runningOverlay.style.display = 'none';
                                    document.getElementById('step2').style.display = 'none';
                                    document.getElementById('step3').style.display = 'block';
                                    document.getElementById('playerMatchResults').classList.remove('active');
                                    document.getElementById('idealFormResults').classList.add('active');
                                }, 1000);
                            } else if (isGeneratingLoop) {
                                // Still generating, wait a bit
                                setTimeout(checkAngles, 500);
                            } else {
                                // Not generated yet, generate now
                                generateLoop(true).then(() => {
                                    calculateIdealFormMetrics();
                                    setTimeout(() => {
                                        if (runningOverlay) runningOverlay.style.display = 'none';
                                        document.getElementById('step2').style.display = 'none';
                                        document.getElementById('step3').style.display = 'block';
                                        document.getElementById('playerMatchResults').classList.remove('active');
                                        document.getElementById('idealFormResults').classList.add('active');
                                    }, 1000);
                                });
                            }
                        };
                        checkAngles();
                    }
                });
            });

            // Handle "Back" button
            const backBtn = document.getElementById('backToRecordBtn');
            if (backBtn) {
                backBtn.addEventListener('click', goBackToRecord);
            }

            // Handle "Try Other Analysis" button
            const tryOtherBtn = document.getElementById('tryOtherAnalysis');
            if (tryOtherBtn) {
                tryOtherBtn.addEventListener('click', function() {
                    // Go back to step2 with video still loaded
                    document.getElementById('step3').style.display = 'none';
                    document.getElementById('step3').classList.remove('active');
                    document.getElementById('step2').style.display = 'block';
                    document.getElementById('step2').classList.add('active');

                    // Show analysis options
                    showAnalysisOptions();

                    // Pre-select the OTHER analysis type
                    const otherType = window.selectedAnalysisType === 'ideal' ? 'similarity' : 'ideal';
                    document.querySelectorAll('.analysis-type-btn').forEach(b => {
                        b.classList.remove('selected');
                        if (b.dataset.type === otherType) {
                            b.classList.add('selected');
                        }
                    });
                });
            }
        });

        // Make showAnalysisOptions available globally
        window.showAnalysisOptions = showAnalysisOptions;

        // ========== Player Match UI Event Handlers ==========

        // Benchmark Comparison Button Handler
        document.getElementById('compareBenchmarksBtn')?.addEventListener('click', async function() {
            const modal = document.getElementById('benchmarkComparisonModal');
            if (!modal) return;
            
            // Show modal
            modal.style.display = 'flex';
            
            // Load benchmark files list
            const select1 = document.getElementById('benchmarkSelect1');
            const select2 = document.getElementById('benchmarkSelect2');
            
            if (!select1 || !select2) return;
            
            // Clear existing options
            select1.innerHTML = '<option value="">Select player...</option>';
            select2.innerHTML = '<option value="">Select player...</option>';
            
            // Load benchmark files
            try {
                if (window.getAllBenchmarkFiles) {
                    const benchmarkFiles = await window.getAllBenchmarkFiles();
                    console.log('Available benchmarks:', benchmarkFiles);
                    
                    // Format player names and add to selects
                    benchmarkFiles.forEach(playerId => {
                        const playerName = window.formatPlayerName ? window.formatPlayerName(playerId) : playerId.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                        const option1 = document.createElement('option');
                        option1.value = playerId;
                        option1.textContent = playerName;
                        select1.appendChild(option1);
                        
                        const option2 = document.createElement('option');
                        option2.value = playerId;
                        option2.textContent = playerName;
                        select2.appendChild(option2);
                    });
                } else {
                    console.error('getAllBenchmarkFiles function not available');
                    alert('Error: Benchmark loading function not available');
                }
            } catch (error) {
                console.error('Error loading benchmarks:', error);
                alert('Error loading benchmarks: ' + error.message);
            }
        });
        
        // Close modal button
        document.getElementById('closeBenchmarkModalBtn')?.addEventListener('click', function() {
            const modal = document.getElementById('benchmarkComparisonModal');
            if (modal) {
                modal.style.display = 'none';
                // Reset selects
                document.getElementById('benchmarkSelect1').value = '';
                document.getElementById('benchmarkSelect2').value = '';
                document.getElementById('benchmarkComparisonResults').style.display = 'none';
            }
        });
        
        // Compare button handler
        document.getElementById('compareBenchmarksSubmitBtn')?.addEventListener('click', async function() {
            const playerId1 = document.getElementById('benchmarkSelect1')?.value;
            const playerId2 = document.getElementById('benchmarkSelect2')?.value;
            
            if (!playerId1 || !playerId2) {
                alert('Please select both players to compare');
                return;
            }
            
            if (playerId1 === playerId2) {
                alert('Please select two different players');
                return;
            }
            
            const submitBtn = document.getElementById('compareBenchmarksSubmitBtn');
            const resultsDiv = document.getElementById('benchmarkComparisonResults');
            const detailsDiv = document.getElementById('benchmarkComparisonDetails');
            const scoreSpan = document.getElementById('benchmarkSimilarityScore');
            
            // Show loading
            submitBtn.disabled = true;
            submitBtn.textContent = 'Comparing...';
            resultsDiv.style.display = 'none';
            
            try {
                // Load both benchmarks
                if (!window.loadBenchmarkFromFile) {
                    throw new Error('loadBenchmarkFromFile function not available');
                }
                
                if (!window.compareDetailedMetrics) {
                    throw new Error('compareDetailedMetrics function not available');
                }
                
                const [benchmark1, benchmark2] = await Promise.all([
                    window.loadBenchmarkFromFile(playerId1),
                    window.loadBenchmarkFromFile(playerId2)
                ]);
                
                if (!benchmark1 || benchmark1.length === 0) {
                    throw new Error(`Could not load benchmark for ${playerId1}`);
                }
                
                if (!benchmark2 || benchmark2.length === 0) {
                    throw new Error(`Could not load benchmark for ${playerId2}`);
                }
                
                // Compare benchmarks
                const comparison = window.compareDetailedMetrics(benchmark1, benchmark2);
                
                // Display results
                const playerName1 = window.formatPlayerName ? window.formatPlayerName(playerId1) : playerId1.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                const playerName2 = window.formatPlayerName ? window.formatPlayerName(playerId2) : playerId2.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                
                scoreSpan.textContent = `${Math.round(comparison.overallScore)}%`;
                
                // Build comparison details
                detailsDiv.innerHTML = '';
                
                if (comparison.metricScores) {
                    Object.keys(comparison.metricScores).forEach(metricName => {
                        const score = comparison.metricScores[metricName];
                        if (score === null || score === undefined) return;
                        
                        const value1 = comparison.userMetrics?.[metricName];
                        const value2 = comparison.benchmarkMetrics?.[metricName];
                        const diff = comparison.metricDiffs?.[metricName];
                        
                        const metricCard = document.createElement('div');
                        metricCard.style.cssText = 'padding: 15px; background: var(--bg-card); border: 1px solid var(--border-color); border-radius: 8px;';
                        
                        const metricDisplayName = metricName.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                        
                        metricCard.innerHTML = `
                            <div style="font-weight: 600; margin-bottom: 8px; font-size: 14px;">${metricDisplayName}</div>
                            <div style="font-size: 24px; font-weight: 700; color: var(--primary-color); margin-bottom: 8px;">${Math.round(score)}%</div>
                            <div style="font-size: 12px; color: var(--text-gray);">
                                ${playerName1}: ${value1 !== null && value1 !== undefined ? value1.toFixed(1) : 'N/A'}<br>
                                ${playerName2}: ${value2 !== null && value2 !== undefined ? value2.toFixed(1) : 'N/A'}<br>
                                ${diff !== null && diff !== undefined ? `Diff: ${diff.toFixed(1)}` : ''}
                            </div>
                        `;
                        
                        detailsDiv.appendChild(metricCard);
                    });
                }
                
                resultsDiv.style.display = 'block';
                
            } catch (error) {
                console.error('Error comparing benchmarks:', error);
                alert('Error comparing benchmarks: ' + error.message);
            } finally {
                submitBtn.disabled = false;
                submitBtn.textContent = 'Compare';
            }
        });
        
        // Close modal when clicking outside
        document.getElementById('benchmarkComparisonModal')?.addEventListener('click', function(e) {
            if (e.target === this) {
                this.style.display = 'none';
                document.getElementById('benchmarkSelect1').value = '';
                document.getElementById('benchmarkSelect2').value = '';
                document.getElementById('benchmarkComparisonResults').style.display = 'none';
            }
        });

        // Quick Fixes toggles
        document.querySelectorAll('.pm-fix-toggle').forEach(toggle => {
            toggle.addEventListener('click', () => {
                const item = toggle.closest('.pm-fix-item');
                item.classList.toggle('active');
            });
        });

        // Player row selection
        const pmRows = document.querySelectorAll('.pm-row');
        let pmSelectedIndex = 0;

        function updatePMSelection(index) {
            if (index < 0) index = 0;
            if (index >= pmRows.length) index = pmRows.length - 1;
            pmSelectedIndex = index;

            pmRows.forEach((row, i) => {
                if (i === pmSelectedIndex) {
                    row.classList.add('pm-row-selected');
                } else {
                    row.classList.remove('pm-row-selected');
                }
            });

            // Update right column with selected player name
            const selectedRow = pmRows[pmSelectedIndex];
            const playerName = selectedRow.querySelector('.pm-name').textContent;
            document.querySelectorAll('.pm-player-name').forEach(el => {
                el.textContent = playerName;
            });

            selectedRow.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }

        // Keyboard navigation
        document.addEventListener('keydown', (e) => {
            const pmResults = document.getElementById('playerMatchResults');
            if (!pmResults || !pmResults.classList.contains('active')) return;

            if (e.key === 'ArrowDown') {
                e.preventDefault();
                updatePMSelection(pmSelectedIndex + 1);
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                updatePMSelection(pmSelectedIndex - 1);
            }
        });

        // Click to select player
        pmRows.forEach((row, i) => {
            row.addEventListener('click', () => updatePMSelection(i));
        });

        // PM Try Other Analysis button
        const pmTryOther = document.getElementById('pmTryOther');
        if (pmTryOther) {
            pmTryOther.addEventListener('click', function() {
                document.getElementById('step3').style.display = 'none';
                document.getElementById('playerMatchResults').classList.remove('active');
                document.getElementById('step2').style.display = 'block';
                showAnalysisOptions();
                // Pre-select ideal form
                document.querySelectorAll('.analysis-type-btn').forEach(b => {
                    b.classList.remove('selected');
                    if (b.dataset.type === 'ideal') b.classList.add('selected');
                });
            });
        }

        // PM Download Extraction Button Handler
        document.getElementById('pmDownloadExtraction')?.addEventListener('click', function() {
            if (!loop3DPoses || loop3DPoses.length === 0) {
                alert('No extraction data available. Please generate animation first by clicking "Generate Animation"');
                return;
            }
            
            if (!loop3DAngles || loop3DAngles.length === 0) {
                alert('No angle data found. Please ensure the video has been processed.');
                return;
            }
            
            try {
                // Extract data from loop3DPoses, loop3DStages, and loop3DAngles
                // Format similar to benchmarkVideoData (same as "Extract Angles & Save Player Data" button)
                const playerData = [];
                
                for (let i = 0; i < loop3DPoses.length; i++) {
                    const frameData = {
                        state: loop3DStages[i] || 'neutral',
                        time: i * (1/30), // Assuming 30 fps
                        elbow_angle: null,
                        wrist_angle: null,
                        arm_angle: null,
                        landmarks: loop3DPoses[i] || [],
                        metrics: {}
                    };
                    
                    // Extract angles from loop3DAngles if available
                    if (loop3DAngles && loop3DAngles[i]) {
                        const angles = loop3DAngles[i];
                        
                        // Map angles to frame data
                        if (angles.right_elbow !== null && angles.right_elbow !== undefined) {
                            frameData.elbow_angle = angles.right_elbow;
                        }
                        if (angles.wrist_snap !== null && angles.wrist_snap !== undefined) {
                            frameData.wrist_angle = angles.wrist_snap;
                        }
                        // Add other angles if available
                        if (angles.left_elbow !== null && angles.left_elbow !== undefined) {
                            frameData.arm_angle = angles.left_elbow;
                        }
                        
                        // Store ALL angles in metrics (including elbow_flare, wrist_snap, etc.)
                        frameData.metrics = { ...angles };
                    }
                    
                    playerData.push(frameData);
                }
                
                // Create JS file content (same format as "Extract Angles & Save Player Data")
                const date = new Date().toISOString().split('T')[0];
                const jsContent = `// User extraction data (extracted from video on ${date})
const user_extraction_data = ${JSON.stringify(playerData, null, 2)};
`;
                
                const blob = new Blob([jsContent], { type: 'text/javascript' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `user_extraction_${date}.js`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                console.log('Downloaded extraction data from Player Match:', {
                    frames: playerData.length,
                    date: date
                });
            } catch (error) {
                console.error('Error downloading extraction:', error);
                alert('Error downloading extraction: ' + error.message);
            }
        });
        
        // PM New Comparison button
        const pmNewComparison = document.getElementById('pmNewComparison');
        if (pmNewComparison) {
            pmNewComparison.addEventListener('click', function() {
                document.getElementById('step3').style.display = 'none';
                document.getElementById('playerMatchResults').classList.remove('active');
                document.getElementById('step2').style.display = 'block';
                goBackToRecord();
            });
        }

        // ========== Ideal Form UI Handlers ==========

        // Consistency toggle (will be overwritten by real data when analysis runs)
        let ifConsistencyData = { session: 78, week: 75, month: 74, career: 72 };
        document.querySelectorAll('.if-toggle-btn').forEach(btn => {
            btn.addEventListener('click', function() {
                document.querySelectorAll('.if-toggle-btn').forEach(b => b.classList.remove('active'));
                this.classList.add('active');
                const period = this.dataset.period;
                document.getElementById('ifConsistencyValue').textContent = ifConsistencyData[period];
            });
        });

        // IF Try Other (go to Player Match)
        const ifTryOther = document.getElementById('ifTryOther');
        if (ifTryOther) {
            ifTryOther.addEventListener('click', function() {
                document.getElementById('idealFormResults').classList.remove('active');
                document.getElementById('playerMatchResults').classList.add('active');
            });
        }

        // IF New Analysis button
        const ifNewAnalysis = document.getElementById('ifNewAnalysis');
        if (ifNewAnalysis) {
            ifNewAnalysis.addEventListener('click', function() {
                document.getElementById('step3').style.display = 'none';
                document.getElementById('idealFormResults').classList.remove('active');
                document.getElementById('step2').style.display = 'block';
                goBackToRecord();
            });
        }
        // ============================================================
        // SHOT ANALYSIS RULE ENGINE + DRILL LIBRARY
        // ============================================================

        // --- MediaPipe Pose landmark indices ---
        const MP = {
            LEFT_SHOULDER: 11, RIGHT_SHOULDER: 12,
            LEFT_ELBOW: 13, RIGHT_ELBOW: 14,
            LEFT_WRIST: 15, RIGHT_WRIST: 16,
            LEFT_HIP: 23, RIGHT_HIP: 24,
            LEFT_KNEE: 25, RIGHT_KNEE: 26,
            LEFT_ANKLE: 27, RIGHT_ANKLE: 28,
            LEFT_HEEL: 29, RIGHT_HEEL: 30,
            LEFT_FOOT_INDEX: 31, RIGHT_FOOT_INDEX: 32,
            NOSE: 0
        };

        // --- Angle helper (same as tool/app.js) ---
        function calcAngle3D(a, b, c) {
            if (!a || !b || !c) return null;
            const ba = [a[0]-b[0], a[1]-b[1], a[2]-b[2]];
            const bc = [c[0]-b[0], c[1]-b[1], c[2]-b[2]];
            const dot = ba[0]*bc[0] + ba[1]*bc[1] + ba[2]*bc[2];
            const magBA = Math.sqrt(ba[0]**2 + ba[1]**2 + ba[2]**2);
            const magBC = Math.sqrt(bc[0]**2 + bc[1]**2 + bc[2]**2);
            if (magBA < 1e-5 || magBC < 1e-5) return null;
            const cosine = Math.max(-1, Math.min(1, dot / (magBA * magBC)));
            return Math.acos(cosine) * (180 / Math.PI);
        }

        // --- Thresholds & feedback rules ---
        const THRESHOLDS = {
            elbowFlare:     { ideal: [5, 15],  warning: [15, 25], unit: '' },
            trunkLean:      { ideal: [0, 8],   warning: [8, 15],  unit: '' },
            kneeBend:       { ideal: [130, 160], warning: [115, 130], unit: '' },
            elbowExtension: { ideal: [160, 180], warning: [140, 160], unit: '' },
            wristSnap:      { ideal: [50, 80],  warning: [35, 50], unit: '' },
            footAlignment:  { ideal: [-5, 5],   warning: [-15, -5], unit: '' },
            footStance:     { ideal: [14, 20],  warning: [10, 14], unit: 'in' },
            releaseHeight:  { ideal: [92, 100], warning: [85, 92], unit: 'in' }
        };

        const FEEDBACK = {
            elbowFlare: {
                good: 'Elbow alignment is tight  minimal flare detected.',
                warning: 'Slight elbow flare detected. Try tucking your shooting elbow closer to your body.',
                bad: 'Significant elbow flare. Focus on keeping your elbow directly under the ball at set point.'
            },
            trunkLean: {
                good: 'Great upright posture throughout your shot.',
                warning: 'Mild forward lean at release. Focus on staying tall through the shot.',
                bad: 'Too much trunk lean is reducing consistency. Practice wall alignment drills.'
            },
            kneeBend: {
                good: 'Solid knee bend generating good power from legs.',
                warning: 'Shallow knee bend  you may be arm-shooting. Sink a bit lower.',
                bad: 'Very little knee bend detected. More leg drive will add range and consistency.'
            },
            elbowExtension: {
                good: 'Full elbow extension at release  excellent follow-through.',
                warning: 'Elbow not fully extending. Reach higher on your follow-through.',
                bad: 'Short-arming the shot. Focus on pushing through to full extension.'
            },
            wristSnap: {
                good: 'Clean wrist snap with good backspin potential.',
                warning: 'Incomplete wrist snap. Hold your gooseneck follow-through longer.',
                bad: 'Minimal wrist snap  work on snapping through the ball for better rotation.'
            },
            footAlignment: {
                good: 'Feet are well-aligned to the basket.',
                warning: 'Feet slightly angled off target. Square up before each shot.',
                bad: 'Feet are significantly misaligned. Use a tape line to practice squaring up.'
            },
            footStance: {
                good: 'Stance width is in the optimal range.',
                warning: 'Stance is slightly narrow or wide. Aim for shoulder-width apart.',
                bad: 'Stance width is off  adjust to shoulder-width for better balance.'
            },
            releaseHeight: {
                good: 'Release height is in the ideal window.',
                warning: 'Release is slightly low. Try to release at or above forehead height.',
                bad: 'Release is too low  higher release makes the shot harder to contest.'
            }
        };

        // --- Classification helpers ---
        function classifyMetric(value, thresholdKey) {
            const t = THRESHOLDS[thresholdKey];
            if (!t) return 'good';
            const [lo, hi] = t.ideal;
            if (value >= lo && value <= hi) return 'good';
            const [wLo, wHi] = t.warning;
            // Check if value is in warning zone (either side)
            if (value >= wLo && value < lo) return 'warning';
            if (value > hi && value <= (wHi > hi ? wHi : hi + (wHi - wLo))) return 'warning';
            return 'bad';
        }

        function metricToScore(value, thresholdKey) {
            const t = THRESHOLDS[thresholdKey];
            if (!t) return 75;
            const [lo, hi] = t.ideal;
            const mid = (lo + hi) / 2;
            const range = (hi - lo) / 2;
            const dist = Math.abs(value - mid);
            // Score: 100 at ideal midpoint, drops proportionally
            const score = Math.max(0, Math.min(100, Math.round(100 - (dist / (range * 3)) * 100)));
            return score;
        }

        function classifyIdealForm(metrics) {
            const keys = ['elbowFlare','trunkLean','kneeBend','elbowExtension','wristSnap'];
            const strengths = [];
            const workOn = [];
            const quickTips = [];
            const scores = {};

            keys.forEach(k => {
                const level = classifyMetric(metrics[k], k);
                scores[k] = metricToScore(metrics[k], k);
                const fb = FEEDBACK[k];
                if (level === 'good') {
                    strengths.push({ metric: k, feedback: fb.good });
                } else {
                    workOn.push({ metric: k, level, feedback: level === 'warning' ? fb.warning : fb.bad });
                    quickTips.push(level === 'warning' ? fb.warning : fb.bad);
                }
            });

            // Also classify secondary metrics
            ['footAlignment','footStance','releaseHeight'].forEach(k => {
                const level = classifyMetric(metrics[k], k);
                scores[k] = metricToScore(metrics[k], k);
                const fb = FEEDBACK[k];
                if (level !== 'good') {
                    quickTips.push(level === 'warning' ? fb.warning : fb.bad);
                    workOn.push({ metric: k, level, feedback: level === 'warning' ? fb.warning : fb.bad });
                }
            });

            // If everything is good, add encouragement tips
            if (quickTips.length === 0) {
                quickTips.push('Your mechanics look solid  focus on repetition for consistency.');
                quickTips.push('Try increasing your shooting distance to test your form under pressure.');
            }

            const avgScore = Math.round(Object.values(scores).reduce((a,b) => a+b, 0) / Object.values(scores).length);

            return { strengths, workOn, quickTips, scores, consistencyScore: avgScore };
        }

        // --- Drill Library ---
        const DRILLS = [
            {
                id: 'wall-alignment', metric: 'trunkLean', priority: 1,
                title: 'Wall Alignment Shots', icon: '',
                desc: 'Stand 1ft from wall, shoot without touching. Builds upright muscle memory.',
                fullDesc: 'Stand with your back against a wall and practice your shooting motion. Keep your shoulders touching the wall throughout to build muscle memory for upright posture.',
                time: '10 mins', reps: '25 reps'
            },
            {
                id: 'elbow-tuck', metric: 'elbowFlare', priority: 1,
                title: 'Elbow Tuck Drill', icon: '',
                desc: 'Hold a tennis ball between your elbow and torso. Shoot without dropping it.',
                fullDesc: 'Place a tennis ball between your shooting elbow and ribs. Practice your shooting motion keeping the ball in place. This trains your arm to stay aligned and reduces elbow flare.',
                time: '10 mins', reps: '20 reps'
            },
            {
                id: 'squat-shoot', metric: 'kneeBend', priority: 1,
                title: 'Squat & Shoot', icon: '',
                desc: 'Start in low squat, explode up through your legs into your shot.',
                fullDesc: 'Start in a low squat position before each shot. Explode up through your legs and transfer that energy into your shot. Focus on consistent knee bend depth.',
                time: '15 mins', reps: '20 reps'
            },
            {
                id: 'gooseneck', metric: 'wristSnap', priority: 1,
                title: 'Gooseneck Hold Drill', icon: '',
                desc: 'Hold your follow-through with wrist fully snapped until ball hits rim.',
                fullDesc: 'After each shot, hold your follow-through with wrist fully snapped (gooseneck position) until the ball hits the rim. This builds muscle memory for complete wrist rotation.',
                time: '10 mins', reps: '30 reps'
            },
            {
                id: 'reach-high', metric: 'elbowExtension', priority: 1,
                title: 'Reach & Release', icon: '',
                desc: 'Focus on pushing to full arm extension on every shot. Reach for the sky.',
                fullDesc: 'On each shot, exaggerate your follow-through by reaching as high as possible. Your fingertips should point at the rim at full extension. This corrects short-arming.',
                time: '10 mins', reps: '25 reps'
            },
            {
                id: 'tape-line', metric: 'footAlignment', priority: 1,
                title: 'Tape Line Drill', icon: '',
                desc: 'Place tape on floor pointing at rim. Align feet parallel before each shot.',
                fullDesc: 'Put a strip of tape on the floor pointing directly at the basket. Before every shot, look down and align both feet parallel to the tape. Builds awareness of foot positioning.',
                time: '10 mins', reps: '20 reps'
            },
            {
                id: 'stance-check', metric: 'footStance', priority: 2,
                title: 'Stance Width Check', icon: '',
                desc: 'Use a measuring stick to set shoulder-width stance before each rep.',
                fullDesc: 'Place a stick or tape markers at shoulder-width on the floor. Step to those marks before every shot. Over time you will internalize the correct width.',
                time: '10 mins', reps: '15 reps'
            },
            {
                id: 'high-release', metric: 'releaseHeight', priority: 2,
                title: 'High Release Practice', icon: '',
                desc: 'Partner holds hand at forehead height  release above it every rep.',
                fullDesc: 'Have a partner or use a marker at your forehead height. Practice releasing the ball above that marker on every shot to raise your release point.',
                time: '10 mins', reps: '20 reps'
            },
            {
                id: 'rhythm-count', metric: 'rhythm', priority: 1,
                title: 'Rhythm Counting', icon: '',
                desc: 'Count "1-2-shoot" aloud. Knee bends on 1, elbow rises on 2, release on shoot.',
                fullDesc: 'Say "1-2-shoot" out loud with each shot. Bend knees on "1", bring the ball up on "2", and release on "shoot". This synchronizes your lower and upper body timing.',
                time: '10 mins', reps: '20 reps'
            }
        ];

        function getDrillsForMetric(metricKey) {
            return DRILLS.filter(d => d.metric === metricKey).sort((a,b) => a.priority - b.priority);
        }

        function getWorkOnItems(workOnList) {
            return workOnList.map(item => {
                const drills = getDrillsForMetric(item.metric);
                return { ...item, drills };
            });
        }

        // --- Metric names for display ---
        const METRIC_DISPLAY = {
            elbowFlare: 'Elbow Flare',
            trunkLean: 'Trunk Stability',
            kneeBend: 'Knee Bend',
            elbowExtension: 'Elbow Extension',
            wristSnap: 'Wrist Snap',
            footAlignment: 'Foot Alignment',
            footStance: 'Foot Stance',
            releaseHeight: 'Release Height',
            rhythm: 'Rhythm'
        };

        // --- Compute metrics from pose data ---
        function computeMetricsFromPoseData(poseData) {
            if (!poseData || poseData.length === 0) return null;

            const frameMetrics = [];

            for (const frame of poseData) {
                const lm = frame.landmarks;
                if (!lm || lm.length < 33) continue;

                const m = {};

                // Elbow flare: angle between shoulder-elbow line and vertical
                // Measure how far the elbow deviates from directly below shoulder in the frontal plane
                const rShoulder = lm[MP.RIGHT_SHOULDER];
                const rElbow = lm[MP.RIGHT_ELBOW];
                const rWrist = lm[MP.RIGHT_WRIST];
                const rHip = lm[MP.RIGHT_HIP];
                const lShoulder = lm[MP.LEFT_SHOULDER];
                const lHip = lm[MP.LEFT_HIP];
                const rKnee = lm[MP.RIGHT_KNEE];
                const lKnee = lm[MP.LEFT_KNEE];
                const rAnkle = lm[MP.RIGHT_ANKLE];
                const lAnkle = lm[MP.LEFT_ANKLE];
                const rHeel = lm[MP.RIGHT_HEEL];
                const lHeel = lm[MP.LEFT_HEEL];
                const rFoot = lm[MP.RIGHT_FOOT_INDEX];
                const lFoot = lm[MP.LEFT_FOOT_INDEX];
                const nose = lm[MP.NOSE];

                // Elbow flare: angle at shoulder between hip and elbow (deviation from body line)
                // Ideal: elbow stays close to body (~5-15 from torso line)
                const elbowFlareAngle = calcAngle3D(rHip, rShoulder, rElbow);
                m.elbowFlare = elbowFlareAngle != null ? Math.abs(elbowFlareAngle - 90) : 10; // deviation from 90

                // Trunk lean: angle of torso from vertical
                // Use midpoint of shoulders vs midpoint of hips
                const midShoulder = [(rShoulder[0]+lShoulder[0])/2, (rShoulder[1]+lShoulder[1])/2, (rShoulder[2]+lShoulder[2])/2];
                const midHip = [(rHip[0]+lHip[0])/2, (rHip[1]+lHip[1])/2, (rHip[2]+lHip[2])/2];
                // Vertical reference point above hip
                const aboveHip = [midHip[0], midHip[1] - 0.5, midHip[2]];
                const trunkAngle = calcAngle3D(midShoulder, midHip, aboveHip);
                m.trunkLean = trunkAngle != null ? trunkAngle : 5;

                // Knee bend: angle at knee (hip-knee-ankle)
                const kneeAngle = calcAngle3D(rHip, rKnee, rAnkle);
                m.kneeBend = kneeAngle != null ? kneeAngle : 150;

                // Elbow extension: angle at elbow (shoulder-elbow-wrist)
                const elbowExt = calcAngle3D(rShoulder, rElbow, rWrist);
                m.elbowExtension = elbowExt != null ? elbowExt : 160;

                // Wrist snap: use the pre-computed wrist_angle if available, otherwise estimate
                if (frame.wrist_angle != null && !isNaN(frame.wrist_angle)) {
                    m.wristSnap = Math.abs(180 - frame.wrist_angle);
                } else {
                    // Estimate from elbow-wrist-fingertip direction (approximate)
                    m.wristSnap = 60; // fallback
                }

                // Foot alignment: angle of foot line relative to forward direction
                // Forward = from ankle midpoint toward basket (assume basket is directly ahead in Z)
                const footMidX = (rAnkle[0] + lAnkle[0]) / 2;
                const footDirX = rFoot[0] - rAnkle[0];
                const footDirZ = rFoot[2] - rAnkle[2];
                const footAngle = Math.atan2(footDirX, Math.abs(footDirZ) + 0.001) * (180 / Math.PI);
                m.footAlignment = footAngle;

                // Foot stance: distance between ankles (normalized to approximate inches)
                // Landmarks are normalized 0-1, typical shoulder width ~0.15 in normalized coords  18 inches
                const ankleDist = Math.sqrt(
                    (rAnkle[0]-lAnkle[0])**2 + (rAnkle[1]-lAnkle[1])**2 + (rAnkle[2]-lAnkle[2])**2
                );
                // Scale: shoulder width (~0.15 normalized)  18 inches
                const shoulderWidth = Math.sqrt(
                    (rShoulder[0]-lShoulder[0])**2 + (rShoulder[1]-lShoulder[1])**2 + (rShoulder[2]-lShoulder[2])**2
                );
                const inchesPerUnit = shoulderWidth > 0.01 ? 18 / shoulderWidth : 120;
                m.footStance = ankleDist * inchesPerUnit;

                // Release height: wrist Y relative to full body height, scaled to inches
                // Estimate player height from nose to ankle in normalized coords
                const bodyHeight = Math.abs(nose[1] - ((rAnkle[1]+lAnkle[1])/2));
                const wristFromGround = Math.abs(((rAnkle[1]+lAnkle[1])/2) - rWrist[1]);
                // Assume 74 inches player height (6'2") as default
                const heightInches = bodyHeight > 0.01 ? 74 / bodyHeight : 74 / 0.5;
                m.releaseHeight = wristFromGround * (74 / (bodyHeight > 0.01 ? bodyHeight : 0.5));

                // Rhythm offset: difference in timing between knee minimum and elbow max
                // (approximated per-frame as position-based offset)
                m.rhythmOffset = 0; // will be computed across frames below

                frameMetrics.push(m);
            }

            if (frameMetrics.length === 0) return null;

            // Average all metrics across frames
            const avg = {};
            const keys = Object.keys(frameMetrics[0]);
            keys.forEach(k => {
                const vals = frameMetrics.map(f => f[k]).filter(v => v != null && !isNaN(v));
                avg[k] = vals.length > 0 ? vals.reduce((a,b) => a+b, 0) / vals.length : 0;
            });

            // Compute rhythm offset from knee bend trajectory
            // Find frame with minimum knee angle (deepest bend) and frame with max elbow extension
            let minKneeIdx = 0, maxElbowIdx = 0;
            let minKnee = 999, maxElbow = 0;
            frameMetrics.forEach((f, i) => {
                if (f.kneeBend < minKnee) { minKnee = f.kneeBend; minKneeIdx = i; }
                if (f.elbowExtension > maxElbow) { maxElbow = f.elbowExtension; maxElbowIdx = i; }
            });
            const totalFrames = frameMetrics.length;
            // Rhythm offset in seconds (assume ~30fps capture)
            avg.rhythmOffset = Math.abs(maxElbowIdx - minKneeIdx) / 30;

            return avg;
        }

        // --- Radar chart point calculation ---
        // 5 axes: elbowFlare, trunkLean, kneeBend, elbowExtension, wristSnap
        // Chart center (150, 130), radius 100
        function radarPoint(index, score, cx, cy, r) {
            // 5 spokes, starting from top (270), going clockwise
            const angle = (Math.PI * 2 / 5) * index - Math.PI / 2;
            const dist = (score / 100) * r;
            return [cx + dist * Math.cos(angle), cy + dist * Math.sin(angle)];
        }

        function radarPolygonPoints(scores, cx, cy, r) {
            const keys = ['elbowFlare','trunkLean','kneeBend','elbowExtension','wristSnap'];
            return keys.map((k, i) => {
                const [x, y] = radarPoint(i, scores[k] || 50, cx, cy, r);
                return `${Math.round(x)},${Math.round(y)}`;
            }).join(' ');
        }

        // --- UI Population: Ideal Form ---
        function populateIdealFormUI(result, workOnItems, metrics) {
            // Update consistency score
            const score = result.consistencyScore;
            ifConsistencyData = {
                session: score,
                week: Math.max(0, score - 3),
                month: Math.max(0, score - 4),
                career: Math.max(0, score - 6)
            };
            const valEl = document.getElementById('ifConsistencyValue');
            if (valEl) valEl.textContent = score;

            // Update Quick Tips
            const tipsList = document.querySelector('.if-tips-list');
            if (tipsList) {
                tipsList.innerHTML = result.quickTips.slice(0, 4).map(tip =>
                    `<li class="if-tip-item"><span class="if-tip-bullet"></span>${tip}</li>`
                ).join('');
            }

            // Update Work On grid
            const workonGrid = document.querySelector('.if-workon-grid');
            if (workonGrid) {
                if (workOnItems.length === 0) {
                    workonGrid.innerHTML = '<div class="if-workon-card"><div class="if-workon-title">Looking Great!</div><div class="if-workon-desc">All your metrics are in the ideal range. Keep up the consistency!</div></div>';
                } else {
                    workonGrid.innerHTML = workOnItems.slice(0, 3).map(item => {
                        const drill = item.drills && item.drills[0];
                        const drillHTML = drill ? `
                            <div class="if-workon-drill">
                                <div class="if-workon-drill-label">Recommended Drill</div>
                                <div class="if-workon-drill-name">${drill.title}</div>
                                <div class="if-workon-drill-tip">${drill.desc}</div>
                            </div>` : '';
                        return `<div class="if-workon-card">
                            <div class="if-workon-title">${METRIC_DISPLAY[item.metric] || item.metric}</div>
                            <div class="if-workon-desc">${item.feedback}</div>
                            ${drillHTML}
                        </div>`;
                    }).join('');
                }
            }

            // Update Radar chart
            const radarSVG = document.querySelector('.if-radar-chart svg');
            if (radarSVG) {
                const cx = 150, cy = 130, r = 100;
                // Update player polygon
                const playerPoly = radarSVG.querySelectorAll('polygon')[1];
                if (playerPoly) {
                    playerPoly.setAttribute('points', radarPolygonPoints(result.scores, cx, cy, r));
                }
                // Update score labels (the last 5 <text> elements)
                const texts = radarSVG.querySelectorAll('text');
                const scoreKeys = ['elbowFlare','trunkLean','kneeBend','elbowExtension','wristSnap'];
                const scoreTexts = Array.from(texts).slice(-5);
                scoreKeys.forEach((k, i) => {
                    if (scoreTexts[i]) scoreTexts[i].textContent = result.scores[k] || 0;
                });
            }

            // Update individual metric cards
            updateRhythmCard(metrics);
            updateFootAlignmentCard(metrics);
            updateFootStanceCard(metrics);
            updateReleaseHeightCard(metrics);
        }

        function updateRhythmCard(metrics) {
            const offset = metrics.rhythmOffset || 0;
            // Update knee marker position (normalized 0-100%)
            const kneeMarker = document.querySelector('.if-rhythm-marker.knee');
            const elbowMarker = document.querySelector('.if-rhythm-marker.elbow');
            if (kneeMarker) kneeMarker.style.left = '50%';
            if (elbowMarker) elbowMarker.style.left = Math.min(95, Math.max(5, 50 + offset * 500)) + '%';

            const statusEl = document.querySelector('.if-rhythm-status');
            if (statusEl) {
                const synced = offset < 0.03;
                statusEl.className = 'if-rhythm-status ' + (synced ? 'synced' : 'offset');
                statusEl.innerHTML = `<span class="if-rhythm-dot"></span>${synced ? 'In sync' : offset.toFixed(2) + 's offset'}`;
            }
        }

        function updateFootAlignmentCard(metrics) {
            const angle = Math.round(metrics.footAlignment || 0);
            // Rotate needle: -45 to +45 maps to full sweep
            const rotation = Math.max(-45, Math.min(45, angle));
            // rotation in SVG: 0 is top, our angle maps -45 to +45 to -74 to +74 in transform
            const svgRotation = (rotation / 45) * 74;
            const needle = document.querySelector('.if-arc-container svg g');
            if (needle) needle.setAttribute('transform', `rotate(${svgRotation}, 50, 55)`);

            const valueEl = document.querySelector('.if-arc-value');
            if (valueEl) {
                const color = Math.abs(angle) <= 5 ? '#3DD68C' : (Math.abs(angle) <= 15 ? '#FFD93D' : '#FF6B7A');
                valueEl.style.color = color;
                valueEl.innerHTML = `${angle > 0 ? '+' : ''}${angle}<span class="if-arc-unit"></span>`;
            }
        }

        function updateFootStanceCard(metrics) {
            const stance = Math.round(metrics.footStance || 17);
            const inOptimal = stance >= 14 && stance <= 20;
            const label = document.querySelector('.if-stance-label');
            if (label) {
                label.style.color = inOptimal ? 'var(--success-color)' : '#FFD93D';
                label.textContent = `${stance}" width ${inOptimal ? '(optimal)' : '(adjust)'}`;
            }
            // Update foot marker positions proportionally
            const totalTrack = 100; // percent
            const normalizedStance = Math.min(80, Math.max(20, (stance / 30) * 100));
            const leftFoot = document.querySelectorAll('.if-stance-foot');
            if (leftFoot.length >= 2) {
                leftFoot[0].style.left = (50 - normalizedStance/2) + '%';
                leftFoot[1].style.left = (50 + normalizedStance/2) + '%';
            }
        }

        function updateReleaseHeightCard(metrics) {
            const height = Math.round(metrics.releaseHeight || 96);
            const inRange = height >= 92 && height <= 100;
            const fillPct = Math.min(100, Math.max(10, (height / 110) * 100));
            const fill = document.querySelector('.if-release-fill');
            if (fill) fill.style.height = fillPct + '%';

            const valueEl = document.querySelector('.if-release-value');
            if (valueEl) valueEl.textContent = height + '"';

            const rangeLabels = document.querySelectorAll('.if-release-target-text');
            if (rangeLabels.length >= 2) {
                rangeLabels[1].style.color = inRange ? 'var(--success-color)' : '#FFD93D';
                rangeLabels[1].textContent = inRange ? 'In range' : (height < 92 ? 'Below target' : 'Above target');
            }
        }

        // --- UI Population: Player Match ---
        function populatePlayerMatchUI(metrics) {
            if (!metrics) return;

            // Determine top 3 issues for quick fixes
            const checkOrder = ['trunkLean','kneeBend','wristSnap','elbowFlare','elbowExtension','footAlignment'];
            const issues = [];
            checkOrder.forEach(k => {
                const level = classifyMetric(metrics[k], k);
                if (level !== 'good') {
                    const drills = getDrillsForMetric(k);
                    issues.push({ metric: k, level, drills, feedback: FEEDBACK[k][level] });
                }
            });

            // If fewer than 3 issues, pad with maintenance tips
            while (issues.length < 3) {
                const remaining = checkOrder.filter(k => !issues.find(i => i.metric === k));
                if (remaining.length === 0) break;
                const k = remaining[0];
                const drills = getDrillsForMetric(k);
                issues.push({ metric: k, level: 'maintenance', drills, feedback: FEEDBACK[k].good });
            }

            const fixItems = document.querySelectorAll('.pm-fix-item');
            const icons = { trunkLean: '', kneeBend: '', wristSnap: '', elbowFlare: '', elbowExtension: '', footAlignment: '' };
            const fixTitles = {
                trunkLean: 'Stay more upright',
                kneeBend: 'Deepen your knee bend',
                wristSnap: 'Snap your wrist fully',
                elbowFlare: 'Tuck your elbow in',
                elbowExtension: 'Extend your follow-through',
                footAlignment: 'Square your feet'
            };

            issues.slice(0, 3).forEach((issue, i) => {
                if (!fixItems[i]) return;
                const iconEl = fixItems[i].querySelector('.pm-fix-icon');
                const titleEl = fixItems[i].querySelector('.pm-fix-title');
                const tipEl = fixItems[i].querySelector('.pm-fix-tip');
                const drillName = fixItems[i].querySelector('.pm-drill-name');
                const drillDesc = fixItems[i].querySelector('.pm-drill-desc');
                const drillMeta = fixItems[i].querySelector('.pm-drill-meta');

                if (iconEl) iconEl.textContent = icons[issue.metric] || '';
                if (titleEl) titleEl.textContent = fixTitles[issue.metric] || METRIC_DISPLAY[issue.metric];
                if (tipEl) tipEl.textContent = issue.feedback;

                if (issue.drills && issue.drills[0]) {
                    const d = issue.drills[0];
                    if (drillName) drillName.textContent = d.title;
                    if (drillDesc) drillDesc.textContent = d.fullDesc;
                    if (drillMeta) drillMeta.innerHTML = `<span> ${d.time}</span><span> ${d.reps}</span>`;
                }
            });
        }

        // ============================================================
        // PLAYER DETAILS PANEL
        // ============================================================
        (function initPlayerDetails() {
            const panel = document.getElementById('playerDetailsPanel');
            const bg = document.getElementById('playerDetailsBg');
            const openBtn = document.getElementById('playerDetailsBtn');
            const closeBtn = document.getElementById('closePlayerDetails');
            const saveBtn = document.getElementById('pdSave');
            const nameInput = document.getElementById('pdName');
            const feetSelect = document.getElementById('pdFeet');
            const inchesSelect = document.getElementById('pdInches');
            const handBtns = document.querySelectorAll('.pd-hand-btn');
            const savedMsg = document.getElementById('pdSavedMsg');

            let selectedHand = '';

            function openPanel() {
                panel.style.display = 'block';
                bg.style.display = 'block';
                // Close profile menu
                const menu = document.getElementById('profileMenu');
                if (menu) menu.style.display = 'none';
            }

            function closePanel() {
                panel.style.display = 'none';
                bg.style.display = 'none';
            }

            if (openBtn) openBtn.addEventListener('click', openPanel);
            const navBtn = document.getElementById('playerDetailsNavBtn');
            if (navBtn) navBtn.addEventListener('click', openPanel);
            if (closeBtn) closeBtn.addEventListener('click', closePanel);
            if (bg) bg.addEventListener('click', closePanel);

            // Hand selection toggle
            handBtns.forEach(btn => {
                btn.addEventListener('click', function() {
                    selectedHand = this.dataset.hand;
                    handBtns.forEach(b => {
                        b.style.borderColor = '#3A3A42';
                        b.style.color = '#8B8B96';
                        b.style.background = '#2A2A30';
                    });
                    this.style.borderColor = 'var(--primary-color)';
                    this.style.color = '#fff';
                    this.style.background = 'rgba(255, 107, 122, 0.15)';
                });
            });

            // Load saved details
            function loadDetails() {
                try {
                    const saved = JSON.parse(localStorage.getItem('playerDetails') || '{}');
                    if (saved.name) nameInput.value = saved.name;
                    if (saved.feet) feetSelect.value = saved.feet;
                    if (saved.inches !== undefined && saved.inches !== '') inchesSelect.value = saved.inches;
                    if (saved.hand) {
                        selectedHand = saved.hand;
                        handBtns.forEach(b => {
                            if (b.dataset.hand === saved.hand) {
                                b.style.borderColor = 'var(--primary-color)';
                                b.style.color = '#fff';
                                b.style.background = 'rgba(255, 107, 122, 0.15)';
                            }
                        });
                    }
                    applyToUI(saved);
                } catch(e) {}
            }

            // Apply player details to the Ideal Form header
            function applyToUI(details) {
                const playerInfoEl = document.querySelector('.if-player-info');
                if (playerInfoEl && (details.name || details.feet || details.hand)) {
                    const name = details.name || 'Player';
                    const height = details.feet ? `${details.feet}'${details.inches || 0}"` : '';
                    const hand = details.hand || '';
                    playerInfoEl.innerHTML =
                        `<span><span class="if-label">Player</span>${name}</span>` +
                        (height ? `<span><span class="if-label">Height</span>${height}</span>` : '') +
                        (hand ? `<span><span class="if-label">Hand</span>${hand}</span>` : '');
                }
            }

            // Save
            if (saveBtn) {
                saveBtn.addEventListener('click', function() {
                    const details = {
                        name: nameInput.value.trim(),
                        feet: feetSelect.value,
                        inches: inchesSelect.value,
                        hand: selectedHand
                    };
                    localStorage.setItem('playerDetails', JSON.stringify(details));
                    applyToUI(details);
                    savedMsg.style.display = 'block';
                    setTimeout(() => { savedMsg.style.display = 'none'; }, 1500);
                });
            }

            // Load on init
            loadDetails();

            // Expose so analysis can re-apply after populating
            window.applyPlayerDetails = function() {
                try {
                    const saved = JSON.parse(localStorage.getItem('playerDetails') || '{}');
                    applyToUI(saved);
                } catch(e) {}
            };
        })();

        // ============================================================
        // WIRE ANALYSIS BUTTONS TO USE REAL POSE DATA
        // ============================================================
        (function wireAnalysisButtons() {
            // Override the existing click handlers by re-attaching
            document.querySelectorAll('.analysis-type-btn').forEach(btn => {
                const clone = btn.cloneNode(true);
                btn.parentNode.replaceChild(clone, btn);

                clone.addEventListener('click', function() {
                    if (this.id === 'backToRecordBtn') return;

                    document.querySelectorAll('.analysis-type-btn').forEach(b => b.classList.remove('selected'));
                    this.classList.add('selected');

                    const analysisType = this.dataset.type;
                    window.selectedAnalysisType = analysisType;

                    const readyOverlay = document.getElementById('videoReadyOverlay');
                    if (readyOverlay) readyOverlay.style.display = 'none';
                    const runningOverlay = document.getElementById('analysisRunningOverlay');
                    if (runningOverlay) runningOverlay.style.display = 'flex';

                    // Compute metrics from real pose data
                    const metrics = computeMetricsFromPoseData(window.userPoseData);

                    setTimeout(() => {
                        if (runningOverlay) runningOverlay.style.display = 'none';
                        document.getElementById('step2').style.display = 'none';
                        document.getElementById('step3').style.display = 'block';

                        if (analysisType === 'similarity') {
                            document.getElementById('playerMatchResults').classList.add('active');
                            document.getElementById('idealFormResults').classList.remove('active');
                            if (metrics) populatePlayerMatchUI(metrics);
                        } else {
                            document.getElementById('playerMatchResults').classList.remove('active');
                            document.getElementById('idealFormResults').classList.add('active');
                            if (metrics) {
                                const result = classifyIdealForm(metrics);
                                const workOnItems = getWorkOnItems(result.workOn);
                                populateIdealFormUI(result, workOnItems, metrics);
                                if (window.applyPlayerDetails) window.applyPlayerDetails();
                            }
                        }
                    }, 800);
                });
            });
        })();

        /**
         * Update Player Match UI with comparison results
         * @param {Array} matches - Array of top 5 matches with playerId, playerName, score
         */
        function updatePlayerMatchUI(matches) {
            const pmList = document.getElementById('playerMatchList');
            if (!pmList) {
                console.error('Cannot update player match UI: playerMatchList element not found');
                return;
            }
            
            // Always clear existing rows (including hardcoded content)
            pmList.innerHTML = '';
            
            if (!matches || matches.length === 0) {
                console.warn('No matches found. Showing empty state.');
                pmList.innerHTML = `
                    <div style="padding: 40px; text-align: center; color: var(--text-gray);">
                        <div style="font-size: 48px; margin-bottom: 20px;"></div>
                        <div style="font-size: 18px; font-weight: 600; margin-bottom: 10px;">No matches found</div>
                        <div style="font-size: 14px;">Please ensure your video has been processed and contains valid shot data.</div>
                        <div style="font-size: 12px; margin-top: 20px; color: var(--text-gray); opacity: 0.7;">
                            Check the browser console for detailed comparison logs.
                        </div>
                    </div>
                `;
                return;
            }
            
            console.log('Updating Player Match UI with', matches.length, 'matches:', matches.map(m => `${m.playerName}: ${m.score.toFixed(1)}%`));
            
            // Create rows for top 5 matches
            matches.forEach((match, index) => {
                const rank = index + 1;
                const score = Math.round(match.score);
                const isFirst = rank === 1;
                
                const row = document.createElement('div');
                row.className = `pm-row ${isFirst ? 'pm-row-selected' : ''}`;
                row.setAttribute('data-player', match.playerId);
                
                row.innerHTML = `
                    <div class="pm-rank ${isFirst ? 'pm-rank-1' : ''}">${rank}</div>
                    <div class="pm-info">
                        <div class="pm-name">${match.playerName}</div>
                        <div class="pm-archetype">Shooting Form</div>
                    </div>
                    <div class="pm-similarity">
                        <div class="pm-score">${score}%</div>
                        <div class="pm-bar"><div class="pm-fill" style="width: ${score}%"></div></div>
                    </div>
                    <div class="pm-stats">
                        <span>6'4"</span>
                        <span>6'6" WS</span>
                        <span>Right</span>
                    </div>
                    <button class="pm-expand-btn" style="background: none; border: none; color: var(--text-gray); cursor: pointer; padding: 8px; font-size: 18px;"></button>
                `;
                
                // Add expandable details section
                const detailsSection = document.createElement('div');
                detailsSection.className = 'pm-details-expanded';
                detailsSection.style.display = 'none';
                detailsSection.style.padding = '20px';
                detailsSection.style.background = 'var(--bg-card)';
                detailsSection.style.borderTop = '1px solid var(--border-color)';
                detailsSection.style.marginTop = '10px';
                
                // Populate with comparison data
                if (match.comparison) {
                    const comp = match.comparison;
                    let detailsHTML = '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px;">';
                    
                    Object.keys(comp.metricScores || {}).forEach(metricName => {
                        const metricScore = comp.metricScores[metricName];
                        const metricDiff = comp.metricDiffs[metricName];
                        const userValue = comp.userMetrics[metricName];
                        const benchValue = comp.benchmarkMetrics[metricName];
                        
                        if (metricScore !== null) {
                            const isAveraged = true; // Could check if it's frame-specific
                            detailsHTML += `
                                <div style="padding: 12px; background: var(--bg-primary); border-radius: 6px; border: 1px solid var(--border-color);">
                                    <div style="font-weight: 600; margin-bottom: 8px; color: var(--text-dark);">${formatMetricName(metricName)}</div>
                                    <div style="font-size: 13px; color: var(--text-gray); margin-bottom: 4px;">
                                        Similarity: <span style="color: var(--primary-color); font-weight: 600;">${Math.round(metricScore)}%</span>
                                    </div>
                                    <div style="font-size: 12px; color: var(--text-gray); margin-bottom: 4px;">
                                        Your Value: <strong>${userValue !== null ? userValue.toFixed(1) + '' : 'N/A'}</strong>
                                    </div>
                                    <div style="font-size: 12px; color: var(--text-gray); margin-bottom: 4px;">
                                        ${match.playerName}: <strong>${benchValue !== null ? benchValue.toFixed(1) + '' : 'N/A'}</strong>
                                    </div>
                                    <div style="font-size: 11px; color: var(--text-gray); margin-top: 6px; padding-top: 6px; border-top: 1px solid var(--border-color);">
                                        ${isAveraged ? ' Averaged across all frames' : ' Single frame comparison'}
                                        ${metricDiff !== null ? ` | Difference: ${metricDiff.toFixed(1)}` : ''}
                                    </div>
                                </div>
                            `;
                        }
                    });
                    
                    detailsHTML += '</div>';
                    detailsSection.innerHTML = detailsHTML;
                }
                
                row.appendChild(detailsSection);
                
                // Add click handler for row selection
                row.addEventListener('click', function(e) {
                    // Don't toggle if clicking the expand button
                    if (e.target.classList.contains('pm-expand-btn')) {
                        e.stopPropagation();
                        const isExpanded = detailsSection.style.display !== 'none';
                        detailsSection.style.display = isExpanded ? 'none' : 'block';
                        const btn = e.target;
                        btn.textContent = isExpanded ? '' : '';
                        return;
                    }
                    
                    // Remove selected class from all rows
                    document.querySelectorAll('.pm-row').forEach(r => r.classList.remove('pm-row-selected'));
                    // Add selected class to clicked row
                    this.classList.add('pm-row-selected');
                    
                    // Update right column with this player's comparison data
                    if (match.comparison) {
                        updatePlayerMatchRightColumn(match);
                    }
                });
                
                pmList.appendChild(row);
            });
            
            console.log('Player Match UI updated with', matches.length, 'matches');
            
            // Update right column with top match data
            if (matches.length > 0 && matches[0].comparison) {
                updatePlayerMatchRightColumn(matches[0]);
            }
        }
        
        /**
         * Update Player Match right column with shared traits and differences from top match
         * @param {Object} topMatch - Top match object with playerName, score, and comparison data
         */
        function updatePlayerMatchRightColumn(topMatch) {
            if (!topMatch || !topMatch.comparison) {
                console.warn('Cannot update right column: no comparison data');
                return;
            }
            
            const comparison = topMatch.comparison;
            const playerName = topMatch.playerName;
            
            // Get shared traits (high similarity >= 85%) and differences (low similarity < 70%)
            const sharedTraits = comparison.sharedTraits || [];
            const differences = comparison.differences || [];
            
            console.log(`Updating right column for ${playerName}:`, {
                sharedTraits: sharedTraits.length,
                differences: differences.length
            });
            
            // Update shared traits section
            const sharedTraitsContainer = document.querySelector('.pm-traits');
            if (sharedTraitsContainer) {
                // Clear existing content
                sharedTraitsContainer.innerHTML = '';
                
                // Create header
                const header = document.createElement('div');
                header.className = 'pm-section-header';
                header.innerHTML = `
                    <span class="pm-section-title">Shared traits with</span>
                    <span class="pm-player-name">${playerName}</span>
                `;
                sharedTraitsContainer.appendChild(header);
                
                // Add traits
                if (sharedTraits.length > 0) {
                    sharedTraits.forEach(trait => {
                        const traitEl = document.createElement('div');
                        traitEl.className = 'pm-trait-item';
                        
                        // Get icon based on metric name
                        const iconMap = {
                            'release_height': '',
                            'wrist_snap': '',
                            'elbow_extension': '',
                            'trunk_lean': '',
                            'knee_bend': '',
                            'elbow_flare': '',
                            'shoulder_angle': '',
                            'foot_alignment': '',
                            'foot_angle': ''
                        };
                        const icon = iconMap[trait.name] || '';
                        
                        // Create description based on values
                        const userVal = trait.userValue !== null && trait.userValue !== undefined ? trait.userValue.toFixed(1) + '' : 'N/A';
                        const benchVal = trait.benchmarkValue !== null && trait.benchmarkValue !== undefined ? trait.benchmarkValue.toFixed(1) + '' : 'N/A';
                        const detail = `You: ${userVal} | ${playerName}: ${benchVal}`;
                        
                        traitEl.innerHTML = `
                            <div class="pm-trait-icon">${icon}</div>
                            <div class="pm-trait-text">
                                <div class="pm-trait-name">${formatMetricName(trait.name)}</div>
                                <div class="pm-trait-detail">${detail}</div>
                            </div>
                            <div class="pm-trait-match">${Math.round(trait.score)}%</div>
                        `;
                        sharedTraitsContainer.appendChild(traitEl);
                    });
                } else {
                    // Show message if no shared traits
                    const noTraits = document.createElement('div');
                    noTraits.style.cssText = 'padding: 20px; text-align: center; color: var(--text-gray); font-size: 14px;';
                    noTraits.textContent = 'No shared traits found (similarity < 85%)';
                    sharedTraitsContainer.appendChild(noTraits);
                }
            }
            
            // Update differences section
            const differencesContainer = document.querySelector('.pm-differences');
            if (differencesContainer) {
                // Clear existing content
                differencesContainer.innerHTML = '';
                
                // Create header
                const header = document.createElement('div');
                header.className = 'pm-section-header';
                header.innerHTML = `
                    <span class="pm-section-title">Key differences from</span>
                    <span class="pm-player-name">${playerName}</span>
                `;
                differencesContainer.appendChild(header);
                
                // Add differences
                if (differences.length > 0) {
                    differences.forEach(diff => {
                        const diffEl = document.createElement('div');
                        diffEl.className = 'pm-diff-item';
                        
                        // Get icon based on metric name
                        const iconMap = {
                            'release_height': '',
                            'wrist_snap': '',
                            'elbow_extension': '',
                            'trunk_lean': '',
                            'knee_bend': '',
                            'elbow_flare': '',
                            'shoulder_angle': '',
                            'foot_alignment': '',
                            'foot_angle': ''
                        };
                        const icon = iconMap[diff.name] || '';
                        
                        // Create description based on values
                        const userVal = diff.userValue !== null && diff.userValue !== undefined ? diff.userValue.toFixed(1) + '' : 'N/A';
                        const benchVal = diff.benchmarkValue !== null && diff.benchmarkValue !== undefined ? diff.benchmarkValue.toFixed(1) + '' : 'N/A';
                        const diffAmount = diff.difference !== null && diff.difference !== undefined ? diff.difference.toFixed(1) + '' : 'N/A';
                        const detail = `You: ${userVal} | ${playerName}: ${benchVal} (diff: ${diffAmount})`;
                        
                        diffEl.innerHTML = `
                            <div class="pm-diff-icon">${icon}</div>
                            <div class="pm-diff-text">
                                <div class="pm-diff-name">${formatMetricName(diff.name)}</div>
                                <div class="pm-diff-detail">${detail}</div>
                            </div>
                            <div class="pm-diff-gap">${diff.score < 100 ? '-' : ''}${Math.round(Math.abs(100 - diff.score))}%</div>
                        `;
                        differencesContainer.appendChild(diffEl);
                    });
                } else {
                    // Show message if no differences
                    const noDiffs = document.createElement('div');
                    noDiffs.style.cssText = 'padding: 20px; text-align: center; color: var(--text-gray); font-size: 14px;';
                    noDiffs.textContent = 'No significant differences found (similarity >= 70%)';
                    differencesContainer.appendChild(noDiffs);
                }
            }
        }
        
        // Make function available globally
        window.updatePlayerMatchUI = updatePlayerMatchUI;

        /**
         * Format metric name from snake_case to Title Case
         * @param {string} name - Metric name in snake_case
         * @returns {string} Formatted name
         */
        function formatMetricName(name) {
            if (!name) return '';
            return name.split('_').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(' ');
        }

        /**
         * Update Ideal Form UI with comparison to top player
         * @param {Object} userMetrics - User's calculated metrics
         * @param {Object} comparison - Comparison data from compareDetailedMetrics
         * @param {string} playerName - Name of the top matching player
         */
        function updateIdealFormUIWithComparison(userMetrics, comparison, playerName) {
            // Update player name in header
            const playerNameEls = document.querySelectorAll('.pm-player-name');
            playerNameEls.forEach(el => {
                if (el) el.textContent = playerName;
            });

            // Get shared traits and differences from comparison
            // These are derived from the player with highest similarity (top match)
            const sharedTraits = comparison.sharedTraits || [];
            const differences = comparison.differences || [];

            // Update shared traits section
            const sharedTraitsContainer = document.querySelector('.pm-traits');
            if (sharedTraitsContainer) {
                const header = sharedTraitsContainer.querySelector('.pm-section-header');
                if (header) {
                    // Clear existing traits (keep header)
                    sharedTraitsContainer.innerHTML = '';
                    sharedTraitsContainer.appendChild(header);
                    
                    // Add traits
                    sharedTraits.forEach(trait => {
                        const traitEl = document.createElement('div');
                        traitEl.className = 'pm-trait-item';
                        traitEl.innerHTML = `
                            <div class="pm-trait-icon"></div>
                            <div class="pm-trait-text">
                                <div class="pm-trait-name">${formatMetricName(trait.name)}</div>
                                <div class="pm-trait-detail">User: ${trait.userValue !== null && trait.userValue !== undefined ? trait.userValue.toFixed(1) + '' : 'N/A'} | ${playerName}: ${trait.benchmarkValue !== null && trait.benchmarkValue !== undefined ? trait.benchmarkValue.toFixed(1) + '' : 'N/A'}</div>
                            </div>
                            <div class="pm-trait-match">${Math.round(trait.score)}%</div>
                        `;
                        sharedTraitsContainer.appendChild(traitEl);
                    });
                }
            }

            // Update differences section
            const differencesContainer = document.querySelector('.pm-differences');
            if (differencesContainer) {
                const header = differencesContainer.querySelector('.pm-section-header');
                if (header) {
                    differencesContainer.innerHTML = '';
                    differencesContainer.appendChild(header);
                    
                    // Add differences
                    differences.forEach(diff => {
                        const diffEl = document.createElement('div');
                        diffEl.className = 'pm-diff-item';
                        diffEl.innerHTML = `
                            <div class="pm-diff-icon"></div>
                            <div class="pm-diff-text">
                                <div class="pm-diff-name">${formatMetricName(diff.name)}</div>
                                <div class="pm-diff-detail">User: ${diff.userValue !== null && diff.userValue !== undefined ? diff.userValue.toFixed(1) + '' : 'N/A'} | ${playerName}: ${diff.benchmarkValue !== null && diff.benchmarkValue !== undefined ? diff.benchmarkValue.toFixed(1) + '' : 'N/A'}</div>
                            </div>
                            <div class="pm-diff-gap">${diff.score < 100 ? '-' : ''}${Math.round(Math.abs(100 - diff.score))}%</div>
                        `;
                        differencesContainer.appendChild(diffEl);
                    });
                }
            }
        }

        // Calculate Ideal Form metrics from extracted angles
        function calculateIdealFormMetrics() {
            if (!loop3DAngles || loop3DAngles.length === 0) {
                console.warn('No angles data available for Ideal Form metrics');
                return;
            }

            // Find the frame with maximum knee bend (lowest knee angle = most bend)
            let maxKneeBendFrame = 0;
            let maxKneeBend = 180; // Start with straight leg
            let kneeBendValues = [];
            
            // Find release point (follow_through stage) - this is the START of follow_through
            let releaseFrameIndex = -1;
            let followThroughStartIndex = -1;
            
            // Find the first frame with follow_through stage (start of follow_through)
            for (let i = 0; i < loop3DStages.length; i++) {
                if (loop3DStages[i] === 'follow_through') {
                    followThroughStartIndex = i;
                    releaseFrameIndex = i; // Use same frame for release point
                    break;
                }
            }
            
            // If no follow_through found, use the frame with maximum elbow extension
            if (releaseFrameIndex === -1) {
                let maxElbowExt = 0;
                for (let i = 0; i < loop3DAngles.length; i++) {
                    const angles = loop3DAngles[i];
                    if (angles && angles.right_elbow !== null && angles.right_elbow !== undefined) {
                        if (angles.right_elbow > maxElbowExt) {
                            maxElbowExt = angles.right_elbow;
                            releaseFrameIndex = i;
                            followThroughStartIndex = i;
                        }
                    }
                }
            }
            
            // Calculate metrics from angles
            const metrics = {
                knee_bend: null,
                elbow_extension: null,
                wrist_snap: null,
                elbow_flare: null,
                trunk_lean: null,
                foot_alignment: null,
                shoulder_angle: null,
                foot_angle: null,
                release_height: null
            };
            
            // Calculate release height from wrist position at release point
            if (releaseFrameIndex >= 0 && releaseFrameIndex < loop3DPoses.length) {
                const releasePose = loop3DPoses[releaseFrameIndex];
                if (releasePose && releasePose[16]) { // Right wrist is landmark 16
                    const wrist = releasePose[16];
                    
                    // Get user height (default to 72 inches / 6 feet)
                    const userHeightInput = document.getElementById('userHeight');
                    const userHeightInches = userHeightInput ? parseFloat(userHeightInput.value) || 72 : 72;
                    
                    // MediaPipe landmarks are normalized (0-1), where Y=0 is top of frame, Y=1 is bottom
                    // We need to convert this to actual height
                    // Assuming the person takes up roughly 80-90% of the frame height
                    // The wrist Y position relative to the person's height
                    
                    // Find ankle position (landmark 28 - right ankle) to establish ground level
                    let groundY = 1.0; // Default to bottom of frame
                    if (releasePose[28] && releasePose[28].visibility > 0.3) {
                        groundY = releasePose[28].y;
                    } else if (releasePose[27] && releasePose[27].visibility > 0.3) {
                        groundY = releasePose[27].y; // Left ankle
                    }
                    
                    // Find head position (landmark 0 - nose) to establish top
                    let headY = 0.0;
                    if (releasePose[0] && releasePose[0].visibility > 0.3) {
                        headY = releasePose[0].y;
                    }
                    
                    // Calculate person's height in normalized coordinates
                    const personHeightNormalized = groundY - headY;
                    
                    if (personHeightNormalized > 0 && wrist.visibility > 0.3) {
                        // Calculate wrist height relative to ground
                        const wristHeightNormalized = groundY - wrist.y;
                        
                        // Convert to actual inches
                        // The person's normalized height represents their actual height
                        const scaleFactor = userHeightInches / personHeightNormalized;
                        const wristHeightInches = wristHeightNormalized * scaleFactor;
                        
                        // Release height is measured from ground
                        metrics.release_height = Math.round(wristHeightInches);
                    }
                }
            }
            
            // Calculate average and max values across all frames
            const validKneeBends = [];
            const validElbowExts = [];
            const validWristSnaps = [];
            const validElbowFlares = [];
            const validTrunkLeans = [];
            const validFootAlignments = [];
            
            loop3DAngles.forEach((angles, index) => {
                if (angles.right_knee !== null && angles.right_knee !== undefined) {
                    validKneeBends.push(angles.right_knee);
                    // Lower angle = more bend
                    if (angles.right_knee < maxKneeBend) {
                        maxKneeBend = angles.right_knee;
                        maxKneeBendFrame = index;
                    }
                }
                if (angles.right_elbow !== null && angles.right_elbow !== undefined) {
                    validElbowExts.push(angles.right_elbow);
                }
                if (angles.wrist_snap !== null && angles.wrist_snap !== undefined) {
                    validWristSnaps.push(angles.wrist_snap);
                }
                if (angles.elbow_flare !== null && angles.elbow_flare !== undefined) {
                    validElbowFlares.push(angles.elbow_flare);
                }
                if (angles.trunk_lean !== null && angles.trunk_lean !== undefined) {
                    validTrunkLeans.push(angles.trunk_lean);
                }
                if (angles.foot_alignment !== null && angles.foot_alignment !== undefined) {
                    validFootAlignments.push(angles.foot_alignment);
                }
            });
            
            // Store shoulder and foot angles separately
            const validShoulderAngles = [];
            const validFootAngles = [];
            
            loop3DAngles.forEach((angles) => {
                if (angles.shoulder_angle !== null && angles.shoulder_angle !== undefined) {
                    validShoulderAngles.push(angles.shoulder_angle);
                }
                if (angles.foot_angle !== null && angles.foot_angle !== undefined) {
                    validFootAngles.push(angles.foot_angle);
                }
            });
            
            // Foot alignment MUST be calculated at the START of follow_through stage
            if (followThroughStartIndex >= 0 && followThroughStartIndex < loop3DAngles.length) {
                const followThroughAngles = loop3DAngles[followThroughStartIndex];
                metrics.shoulder_angle = followThroughAngles.shoulder_angle !== null ? followThroughAngles.shoulder_angle : null;
                metrics.foot_angle = followThroughAngles.foot_angle !== null ? followThroughAngles.foot_angle : null;
                metrics.foot_alignment = followThroughAngles.foot_alignment !== null ? followThroughAngles.foot_alignment : null;
                console.log(`Foot alignment calculated at follow_through start (frame ${followThroughStartIndex}):`, {
                    shoulder_angle: metrics.shoulder_angle,
                    foot_angle: metrics.foot_angle,
                    foot_alignment: metrics.foot_alignment
                });
            } else {
                // Fallback to averages if no follow_through found
                metrics.shoulder_angle = validShoulderAngles.length > 0 ? validShoulderAngles.reduce((a, b) => a + b, 0) / validShoulderAngles.length : null;
                metrics.foot_angle = validFootAngles.length > 0 ? validFootAngles.reduce((a, b) => a + b, 0) / validFootAngles.length : null;
                metrics.foot_alignment = validFootAlignments.length > 0 ? validFootAlignments.reduce((a, b) => a + b, 0) / validFootAlignments.length : null;
                console.warn('No follow_through stage found, using average for foot alignment');
            }
            
            // Calculate other metrics (use values at release point if available, otherwise average)
            if (releaseFrameIndex >= 0 && releaseFrameIndex < loop3DAngles.length) {
                const releaseAngles = loop3DAngles[releaseFrameIndex];
                metrics.knee_bend = releaseAngles.right_knee !== null ? releaseAngles.right_knee : 
                    (validKneeBends.length > 0 ? validKneeBends.reduce((a, b) => a + b, 0) / validKneeBends.length : null);
                metrics.elbow_extension = releaseAngles.right_elbow !== null ? releaseAngles.right_elbow : 
                    (validElbowExts.length > 0 ? validElbowExts.reduce((a, b) => a + b, 0) / validElbowExts.length : null);
                metrics.wrist_snap = releaseAngles.wrist_snap !== null ? releaseAngles.wrist_snap : 
                    (validWristSnaps.length > 0 ? validWristSnaps.reduce((a, b) => a + b, 0) / validWristSnaps.length : null);
                metrics.elbow_flare = releaseAngles.elbow_flare !== null ? releaseAngles.elbow_flare : 
                    (validElbowFlares.length > 0 ? validElbowFlares.reduce((a, b) => a + b, 0) / validElbowFlares.length : null);
                metrics.trunk_lean = releaseAngles.trunk_lean !== null ? releaseAngles.trunk_lean : 
                    (validTrunkLeans.length > 0 ? validTrunkLeans.reduce((a, b) => a + b, 0) / validTrunkLeans.length : null);
            } else {
                // Use averages
                metrics.knee_bend = validKneeBends.length > 0 ? validKneeBends.reduce((a, b) => a + b, 0) / validKneeBends.length : null;
                metrics.elbow_extension = validElbowExts.length > 0 ? validElbowExts.reduce((a, b) => a + b, 0) / validElbowExts.length : null;
                metrics.wrist_snap = validWristSnaps.length > 0 ? validWristSnaps.reduce((a, b) => a + b, 0) / validWristSnaps.length : null;
                metrics.elbow_flare = validElbowFlares.length > 0 ? validElbowFlares.reduce((a, b) => a + b, 0) / validElbowFlares.length : null;
                metrics.trunk_lean = validTrunkLeans.length > 0 ? validTrunkLeans.reduce((a, b) => a + b, 0) / validTrunkLeans.length : null;
            }
            
            console.log('Calculated metrics:', metrics);
            
            // Convert angles to scores (0-100 scale) and update UI
            updateIdealFormUI(metrics);
        }

        /**
         * Calculate Ideal Form metrics and compare with top player match
         * @param {Object} topMatch - Top player match with comparison data (must be highest similarity)
         */
        function calculateIdealFormMetricsWithComparison(topMatch) {
            if (!loop3DAngles || loop3DAngles.length === 0) {
                console.warn('No angles data available for Ideal Form metrics');
                return;
            }

            // Ensure we're using the top match (highest similarity)
            if (!topMatch || !topMatch.comparison) {
                console.warn('No top match comparison data available, falling back to basic metrics');
                calculateIdealFormMetrics();
                return;
            }

            // Calculate user metrics first (same logic as calculateIdealFormMetrics)
            calculateIdealFormMetrics();
            
            // Use comparison data from topMatch (highest similarity player)
            // This ensures shared traits and differences are derived from the best match
            const comparison = topMatch.comparison;
            
            // Verify this is the top match by checking if it's the first in the matches array
            if (window.topPlayerMatches && window.topPlayerMatches.length > 0) {
                const actualTopMatch = window.topPlayerMatches[0];
                if (actualTopMatch.playerId !== topMatch.playerId) {
                    console.warn('Warning: Using non-top match for comparison. Using actual top match instead.');
                    const actualComparison = actualTopMatch.comparison;
                    if (actualComparison && actualComparison.userMetrics) {
                        updateIdealFormUIWithComparison(actualComparison.userMetrics, actualComparison, actualTopMatch.playerName);
                        return;
                    }
                }
            }
            
            // Update UI with comparison data from highest similarity player
            if (comparison && comparison.userMetrics) {
                updateIdealFormUIWithComparison(comparison.userMetrics, comparison, topMatch.playerName);
            }
        }

        // Update Ideal Form UI with calculated metrics
        function updateIdealFormUI(metrics) {
            // Convert angles to scores (0-100 scale)
            // Lower knee angle = more bend = better (higher score)
            // Higher elbow extension = better (higher score)
            // etc.
            
            const scores = {
                knee_bend: metrics.knee_bend !== null ? 
                    Math.max(0, Math.min(100, 100 - (metrics.knee_bend - 90) * 2)) : 71,
                elbow_extension: metrics.elbow_extension !== null ? 
                    Math.max(0, Math.min(100, (metrics.elbow_extension / 180) * 100)) : 88,
                wrist_snap: metrics.wrist_snap !== null ? 
                    Math.max(0, Math.min(100, (metrics.wrist_snap / 90) * 100)) : 79,
                elbow_flare: metrics.elbow_flare !== null ? 
                    Math.max(0, Math.min(100, 100 - Math.abs(metrics.elbow_flare - 90) * 2)) : 82,
                trunk_lean: metrics.trunk_lean !== null ? 
                    Math.max(0, Math.min(100, 100 - Math.abs(metrics.trunk_lean) * 2)) : 68
            };
            
            // Update radar chart scores
            const radarScores = {
                'Elbow Flare': Math.round(scores.elbow_flare),
                'Trunk Lean': Math.round(scores.trunk_lean),
                'Knee Bend': Math.round(scores.knee_bend),
                'Elbow Ext.': Math.round(scores.elbow_extension),
                'Wrist Snap': Math.round(scores.wrist_snap)
            };
            
            // Update foot alignment (show shoulder and foot angles separately)
            if (metrics.shoulder_angle !== null || metrics.foot_angle !== null) {
                const footAlignmentEl = document.querySelector('.if-arc-value');
                if (footAlignmentEl) {
                    const shoulderAngle = metrics.shoulder_angle !== null ? Math.round(metrics.shoulder_angle) : null;
                    const footAngle = metrics.foot_angle !== null ? Math.round(metrics.foot_angle) : null;
                    
                    // Display both angles
                    let displayText = '';
                    if (shoulderAngle !== null && footAngle !== null) {
                        displayText = `Shoulders: ${shoulderAngle > 0 ? '+' : ''}${shoulderAngle}<br>Feet: ${footAngle > 0 ? '+' : ''}${footAngle}`;
                    } else if (shoulderAngle !== null) {
                        displayText = `Shoulders: ${shoulderAngle > 0 ? '+' : ''}${shoulderAngle}`;
                    } else if (footAngle !== null) {
                        displayText = `Feet: ${footAngle > 0 ? '+' : ''}${footAngle}`;
                    }
                    
                    footAlignmentEl.innerHTML = displayText;
                    footAlignmentEl.style.fontSize = '16px'; // Smaller font to fit both lines
                    footAlignmentEl.style.lineHeight = '1.4';
                    
                    // Update SVG rotation based on offset (if both angles available)
                    if (metrics.foot_alignment !== null) {
                        const offsetAngle = Math.round(metrics.foot_alignment);
                        const svgTransform = document.querySelector('.if-arc-svg g[transform]');
                        if (svgTransform) {
                            // Clamp rotation to visible range (-45 to +45 degrees)
                            const clampedAngle = Math.max(-45, Math.min(45, offsetAngle));
                            const rotation = -74 + clampedAngle; // Adjust from base rotation
                            svgTransform.setAttribute('transform', `rotate(${rotation}, 50, 55)`);
                            
                            // Update color based on offset magnitude
                            const line = svgTransform.querySelector('line');
                            const circle = svgTransform.querySelector('circle');
                            if (line && circle) {
                                if (Math.abs(offsetAngle) <= 5) {
                                    // Good alignment (within 5 degrees) - green
                                    line.setAttribute('stroke', '#3DD68C');
                                    circle.setAttribute('fill', '#3DD68C');
                                } else if (Math.abs(offsetAngle) <= 15) {
                                    // Moderate offset (5-15 degrees) - yellow
                                    line.setAttribute('stroke', '#FFD93D');
                                    circle.setAttribute('fill', '#FFD93D');
                                } else {
                                    // Large offset (>15 degrees) - red/orange
                                    line.setAttribute('stroke', '#FF6B7A');
                                    circle.setAttribute('fill', '#FF6B7A');
                                }
                            }
                        }
                        
                        // Update the work-on description if it exists
                        const workOnDesc = document.querySelector('.if-workon-desc');
                        if (workOnDesc && Math.abs(offsetAngle) > 5) {
                            workOnDesc.textContent = `Feet are angled ${Math.abs(offsetAngle)} ${offsetAngle > 0 ? 'clockwise' : 'counterclockwise'} from shoulder alignment, affecting accuracy on longer shots.`;
                        }
                    }
                }
            }
            
            // Update release height
            if (metrics.release_height !== null) {
                const releaseValueEl = document.querySelector('.if-release-value');
                const releaseFillEl = document.querySelector('.if-release-fill');
                const releaseTargetEl = document.querySelector('.if-release-target');
                
                if (releaseValueEl) {
                    releaseValueEl.textContent = `${metrics.release_height}"`;
                }
                
                // Update bar visualization (target range is 92-100 inches)
                const targetMin = 92;
                const targetMax = 100;
                const targetRange = targetMax - targetMin;
                const maxHeight = 120; // Maximum expected height for visualization
                
                if (releaseFillEl) {
                    // Calculate fill percentage (0-100% of bar)
                    const fillPercent = Math.min(100, (metrics.release_height / maxHeight) * 100);
                    releaseFillEl.style.height = `${fillPercent}%`;
                }
                
                if (releaseTargetEl) {
                    // Position target zone (92-100 inches)
                    const targetBottom = ((maxHeight - targetMax) / maxHeight) * 100;
                    const targetHeight = (targetRange / maxHeight) * 100;
                    releaseTargetEl.style.bottom = `${targetBottom}%`;
                    releaseTargetEl.style.height = `${targetHeight}%`;
                }
                
                // Update status text
                const statusText = document.querySelectorAll('.if-release-target-text');
                if (statusText.length > 1) {
                    if (metrics.release_height >= targetMin && metrics.release_height <= targetMax) {
                        statusText[1].textContent = 'In range';
                        statusText[1].style.color = 'var(--success-color)';
                    } else if (metrics.release_height < targetMin) {
                        statusText[1].textContent = 'Below target';
                        statusText[1].style.color = '#FFD93D';
                    } else {
                        statusText[1].textContent = 'Above target';
                        statusText[1].style.color = '#FF6B7A';
                    }
                }
            }
            
            console.log('Updated Ideal Form UI with scores:', radarScores);
            console.log('Release height:', metrics.release_height);
            // Note: The radar chart SVG is hardcoded, so we'd need to update the polygon points
            // For now, the scores are calculated and logged. The UI update would require
            // recalculating the polygon points based on the scores.
        }

        // ====================== 3D POSE LOOP ANIMATION ======================
        // EXACT CODE FROM videopose3d-integration BRANCH
        let isGeneratingLoop = false;
        let isLoopPlaying = false;
        let loopAnimationFrameId = null;
        let currentLoopFrameIndex = 0;
        let loopScene = null;
        let loopCamera = null;
        let loopRenderer = null;
        let loopSkeletonObjects = [];
        let loop3DPoses = [];
        let loop3DStages = [];
        let loop3DAngles = []; // Store angles for each frame
        let selectedShotCount = 10; // Default to 10 shots
        let detectedShots = []; // Array to store detected shot sequences
        let isUploadMode = false; // Track whether user is uploading vs recording
        
        // Sync variables to window for webcam recording access
        // Create a function to sync window variables to let variables
        function syncLoopVariablesFromWindow() {
            if (window.loop3DPoses && window.loop3DPoses.length > 0 && loop3DPoses.length === 0) {
                loop3DPoses = window.loop3DPoses;
                loop3DStages = window.loop3DStages || [];
                loop3DAngles = window.loop3DAngles || [];
                currentLoopFrameIndex = window.currentLoopFrameIndex || 0;
            }
        }
        
        // Also sync let variables to window when they change (for generateLoop)
        const originalPush = Array.prototype.push;
        const createSyncedArray = (arr, windowKey) => {
            return new Proxy(arr, {
                set(target, prop, value) {
                    target[prop] = value;
                    if (window[windowKey]) {
                        window[windowKey][prop] = value;
                    }
                    return true;
                }
            });
        };

        // Interpolate frames to create smoother animation
        function interpolateFrames(originalFrames, factor) {
            if (originalFrames.length < 2) return originalFrames;
            
            const interpolated = [];
            
            // For each pair of consecutive frames
            for (let i = 0; i < originalFrames.length; i++) {
                const currentFrame = originalFrames[i];
                const nextFrame = originalFrames[(i + 1) % originalFrames.length]; // Wrap around for loop
                
                // Add the original frame
                interpolated.push(currentFrame);
                
                // Create (factor - 1) interpolated frames between current and next
                for (let interpStep = 1; interpStep < factor; interpStep++) {
                    const t = interpStep / factor; // Interpolation factor (0 to 1)
                    const interpolatedFrame = [];
                    
                    // Interpolate each landmark
                    for (let landmarkIdx = 0; landmarkIdx < Math.max(currentFrame.length, nextFrame.length); landmarkIdx++) {
                        const currentLandmark = currentFrame[landmarkIdx];
                        const nextLandmark = nextFrame[landmarkIdx];
                        
                        if (currentLandmark && nextLandmark) {
                            // Linear interpolation for x, y, z, and visibility
                            const interpolatedLandmark = {
                                x: currentLandmark.x + (nextLandmark.x - currentLandmark.x) * t,
                                y: currentLandmark.y + (nextLandmark.y - currentLandmark.y) * t,
                                z: (currentLandmark.z || 0) + ((nextLandmark.z || 0) - (currentLandmark.z || 0)) * t,
                                visibility: currentLandmark.visibility + (nextLandmark.visibility - currentLandmark.visibility) * t,
                                index: currentLandmark.index !== undefined ? currentLandmark.index : landmarkIdx
                            };
                            interpolatedFrame.push(interpolatedLandmark);
                        } else if (currentLandmark) {
                            // If next frame doesn't have this landmark, use current
                            interpolatedFrame.push(currentLandmark);
                        } else if (nextLandmark) {
                            // If current frame doesn't have this landmark, use next
                            interpolatedFrame.push(nextLandmark);
                        } else {
                            // Neither frame has this landmark, create a default
                            interpolatedFrame.push({
                                x: 0.5,
                                y: 0.5,
                                z: 0,
                                visibility: 0,
                                index: landmarkIdx
                            });
                        }
                    }
                    
                    interpolated.push(interpolatedFrame);
                }
            }
            
            return interpolated;
        }

        // Initialize loop 3D viewer
        function initLoop3DViewer() {
            const canvas = document.getElementById('skeletonCanvas3d');
            if (!canvas) {
                console.error('skeletonCanvas3d not found');
                return;
            }
            
            // Get actual canvas dimensions from container
            const container = canvas.parentElement;
            const width = container ? container.clientWidth : 800;
            const height = container ? container.clientHeight : 600;
            
            console.log('Initializing loop 3D viewer:', width, 'x', height);
            
            // Scene
            loopScene = new THREE.Scene();
            loopScene.background = new THREE.Color(0x1a1a1a);
            
            // Camera
            loopCamera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
            loopCamera.position.set(0, 0, 5);
            loopCamera.lookAt(0, 0, 0); // IMPORTANT: Look at origin
            
            // Renderer
            loopRenderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
            loopRenderer.setSize(width, height, false);
            loopRenderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Limit pixel ratio for performance
            
            // Set canvas size explicitly
            canvas.width = width;
            canvas.height = height;
            
            // Grid
            const gridHelper = new THREE.GridHelper(10, 10, 0x444444, 0x222222);
            loopScene.add(gridHelper);
            
            // Axes
            const axesHelper = new THREE.AxesHelper(2);
            loopScene.add(axesHelper);
            
            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            loopScene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 5, 5);
            loopScene.add(directionalLight);
            
            // Render initial empty scene
            loopRenderer.render(loopScene, loopCamera);
            
            console.log('Loop 3D viewer initialized:', width, 'x', height);
        }

        // Get color based on shot stage
        function getStageColor(stage) {
            const colors = {
                'neutral': 0x888888,
                'pre_shot': 0x0000FF,  // Blue
                'follow_through': 0x00FF00  // Green
            };
            return colors[stage] || 0x888888;
        }

        // Update loop 3D skeleton - use EXACT same logic as main 3D viewer
        function updateLoop3DSkeleton(landmarks, stage = null) {
            if (!loopScene || !landmarks || landmarks.length === 0) return;

            // Clear previous skeleton
            loopSkeletonObjects.forEach(obj => loopScene.remove(obj));
            loopSkeletonObjects = [];

            // Get current stage for color coding (use provided stage or fallback)
            const currentStage = stage || (loop3DStages && loop3DStages[currentLoopFrameIndex] 
                ? loop3DStages[currentLoopFrameIndex] 
                : "neutral");
            const stageColor = getStageColor(currentStage);

            // Complete MediaPipe Pose connections (all main body connections)
            const connections = [
                // Torso (core skeleton)
                [11, 12],  // Shoulders
                [11, 23],  // Left shoulder to left hip
                [12, 24],  // Right shoulder to right hip
                [23, 24],  // Hips
                // Left arm (complete chain)
                [11, 13],  // Left shoulder to left elbow
                [13, 15],  // Left elbow to left wrist
                // Right arm (complete chain)
                [12, 14],  // Right shoulder to right elbow
                [14, 16],  // Right elbow to right wrist
                // Left leg (complete chain)
                [23, 25],  // Left hip to left knee
                [25, 27],  // Left knee to left ankle
                // Right leg (complete chain)
                [24, 26],  // Right hip to right knee
                [26, 28]   // Right knee to right ankle
            ];

            // First pass: calculate center for better normalization
            let centerX = 0, centerY = 0, centerZ = 0;
            let validCount = 0;
            
            landmarks.forEach((lm) => {
                if (lm.visibility >= 0.3) {
                    centerX += lm.x;
                    centerY += lm.y;
                    centerZ += (lm.z || 0);
                    validCount++;
                }
            });
            
            if (validCount === 0) return;
            
            centerX /= validCount;
            centerY /= validCount;
            centerZ /= validCount;
            
            // Calculate scale based on shoulder width (more stable)
            let scale = 4.0;
            if (landmarks[11] && landmarks[12] && 
                landmarks[11].visibility > 0.5 && landmarks[12].visibility > 0.5) {
                const shoulderWidth = Math.abs(landmarks[11].x - landmarks[12].x);
                scale = Math.max(3.0, Math.min(6.0, 1.0 / (shoulderWidth + 0.1)));
            }

            // Helper function to calculate 3D position from landmark
            const calculatePos3D = (lm) => {
                const x = (lm.x - centerX) * scale * 2;
                const y = -(lm.y - centerY) * scale * 2;  // Flip Y for 3D
                const zOffset = (lm.z || 0) - centerZ;
                const z = zOffset * scale * 0.5;  // Reduced Z scale
                return { x, y, z };
            };

            // Create joints (spheres) with improved coordinate transformation
            landmarks.forEach((lm, index) => {
                // Calculate position for all landmarks (even low visibility ones for connections)
                const pos3d = calculatePos3D(lm);
                landmarks[index].pos3d = pos3d;
                
                // Only create visible spheres for landmarks with good visibility
                if (lm.visibility < 0.3) {
                    return;  // Don't show sphere, but keep pos3d for connections
                }

                const geometry = new THREE.SphereGeometry(0.04, 12, 12);
                // Use stage color instead of visibility-based color
                const material = new THREE.MeshPhongMaterial({ 
                    color: stageColor, 
                    emissive: stageColor, 
                    emissiveIntensity: 0.4,
                    shininess: 30
                });
                const sphere = new THREE.Mesh(geometry, material);
                sphere.position.set(pos3d.x, pos3d.y, pos3d.z);
                loopScene.add(sphere);
                loopSkeletonObjects.push(sphere);
            });

            // Create connections (lines) - draw if both landmarks exist and have reasonable visibility
            connections.forEach(([startIdx, endIdx]) => {
                if (startIdx >= landmarks.length || endIdx >= landmarks.length) {
                    return;
                }
                
                const start = landmarks[startIdx];
                const end = landmarks[endIdx];
                
                if (!start || !end) {
                    return;
                }
                
                // Draw connection if both landmarks have at least minimal visibility
                if (start.visibility < 0.2 || end.visibility < 0.2) {
                    return;  // Too low visibility, skip connection
                }
                
                // pos3d should already be set from the joint creation loop above
                if (!start.pos3d || !end.pos3d) {
                    return;  // Safety check
                }

                const geometry = new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3(start.pos3d.x, start.pos3d.y, start.pos3d.z),
                    new THREE.Vector3(end.pos3d.x, end.pos3d.y, end.pos3d.z)
                ]);

                // Make connections more visible - use stage color
                const material = new THREE.LineBasicMaterial({ 
                    color: stageColor, 
                    linewidth: 3,
                    opacity: 0.95,
                    transparent: true
                });
                const line = new THREE.Line(geometry, material);
                loopScene.add(line);
                loopSkeletonObjects.push(line);
            });
            
            // Update camera aspect ratio in case canvas size changed
            if (loopCamera && loopRenderer) {
                const canvas = document.getElementById('skeletonCanvas3d');
                if (canvas) {
                    const width = canvas.clientWidth || 800;
                    const height = canvas.clientHeight || 800;
                    loopCamera.aspect = width / height;
                    loopCamera.updateProjectionMatrix();
                    loopRenderer.setSize(width, height, false);
                }
            }
            
            loopRenderer.render(loopScene, loopCamera);
        }
        
        // Animate loop
        function animateLoop() {
            // Always sync with window variables (for webcam recording compatibility)
            const poses = (loop3DPoses.length > 0 ? loop3DPoses : (window.loop3DPoses || []));
            const stages = (loop3DStages.length > 0 ? loop3DStages : (window.loop3DStages || []));
            const playing = isLoopPlaying || window.isLoopPlaying;
            
            if (!playing || poses.length === 0) return;
            
            // Sync current index
            let currentIndex = (currentLoopFrameIndex !== undefined && currentLoopFrameIndex !== null) 
                ? currentLoopFrameIndex 
                : (window.currentLoopFrameIndex !== undefined ? window.currentLoopFrameIndex : 0);
            
            // Update to current frame
            if (currentIndex < poses.length) {
                const stage = (stages[currentIndex] || 'neutral');
                updateLoop3DSkeleton(poses[currentIndex], stage);
                
                const loopFrameInfo = document.getElementById('frameCounter');
                if (loopFrameInfo) {
                    loopFrameInfo.textContent = `Frame: ${currentIndex + 1}/${poses.length}`;
                }
                
                // Move to next frame
                const nextIndex = (currentIndex + 1) % poses.length;
                currentLoopFrameIndex = nextIndex;
                window.currentLoopFrameIndex = nextIndex;
            }
            
            // Continue animation (ultra-fast frame-by-frame: ~256 fps for extremely smooth playback)
            loopAnimationFrameId = setTimeout(() => {
                requestAnimationFrame(animateLoop);
            }, 3.90625); // 3.90625ms = ~256 fps (1/128 of original 500ms)
        }

        // Calculate angle between three points (in degrees)
        function calculateAngle(point1, point2, point3) {
            // point2 is the vertex
            const v1 = {
                x: point1.x - point2.x,
                y: point1.y - point2.y,
                z: (point1.z || 0) - (point2.z || 0)
            };
            const v2 = {
                x: point3.x - point2.x,
                y: point3.y - point2.y,
                z: (point3.z || 0) - (point2.z || 0)
            };
            
            // Calculate dot product
            const dot = v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;
            
            // Calculate magnitudes
            const mag1 = Math.sqrt(v1.x * v1.x + v1.y * v1.y + v1.z * v1.z);
            const mag2 = Math.sqrt(v2.x * v2.x + v2.y * v2.y + v2.z * v2.z);
            
            if (mag1 === 0 || mag2 === 0) return null;
            
            // Calculate angle in radians, then convert to degrees
            const cosAngle = dot / (mag1 * mag2);
            const angle = Math.acos(Math.max(-1, Math.min(1, cosAngle)));
            return angle * (180 / Math.PI);
        }

        // Extract angles from landmarks for a frame
        function extractAnglesFromLandmarks(landmarks) {
            const angles = {};
            
            // Left Knee: hip(23) - knee(25) - ankle(27)
            if (landmarks[23] && landmarks[25] && landmarks[27] &&
                landmarks[23].visibility > 0.3 && landmarks[25].visibility > 0.3 && landmarks[27].visibility > 0.3) {
                angles.left_knee = calculateAngle(landmarks[23], landmarks[25], landmarks[27]);
            }
            
            // Right Knee: hip(24) - knee(26) - ankle(28)
            if (landmarks[24] && landmarks[26] && landmarks[28] &&
                landmarks[24].visibility > 0.3 && landmarks[26].visibility > 0.3 && landmarks[28].visibility > 0.3) {
                angles.right_knee = calculateAngle(landmarks[24], landmarks[26], landmarks[28]);
            }
            
            // Left Elbow: shoulder(11) - elbow(13) - wrist(15)
            if (landmarks[11] && landmarks[13] && landmarks[15] &&
                landmarks[11].visibility > 0.3 && landmarks[13].visibility > 0.3 && landmarks[15].visibility > 0.3) {
                angles.left_elbow = calculateAngle(landmarks[11], landmarks[13], landmarks[15]);
            }
            
            // Right Elbow: shoulder(12) - elbow(14) - wrist(16)
            if (landmarks[12] && landmarks[14] && landmarks[16] &&
                landmarks[12].visibility > 0.3 && landmarks[14].visibility > 0.3 && landmarks[16].visibility > 0.3) {
                angles.right_elbow = calculateAngle(landmarks[12], landmarks[14], landmarks[16]);
            }
            
            // Wrist Snap: angle from finger/knuckle(20) - wrist(16) - elbow(14) of right hand
            // This should be calculated at release height (max wrist y), but we calculate for all frames
            // The meaningful value will be at the frame where wrist y is maximum
            if (landmarks[14] && landmarks[16] && landmarks[20] &&
                landmarks[14].visibility > 0.3 && landmarks[16].visibility > 0.3 && landmarks[20].visibility > 0.3) {
                // Calculate angle: finger tip -> wrist -> elbow (right hand)
                angles.wrist_snap = calculateAngle(landmarks[20], landmarks[16], landmarks[14]);
            }
            
            // Elbow Flare: angle between vertical line down from right shoulder and line from shoulder to elbow
            // Vertical line: straight down from shoulder (no change in x or z, only y changes)
            // This is for right shoulder(12) and right elbow(14)
            if (landmarks[12] && landmarks[14] &&
                landmarks[12].visibility > 0.3 && landmarks[14].visibility > 0.3) {
                // Vertical line down from shoulder: same x and z, only y changes (pointing downward)
                const verticalPoint = {
                    x: landmarks[12].x,
                    y: landmarks[12].y - 1, // 1 unit down (normalized coordinates)
                    z: landmarks[12].z || 0
                };
                
                // Line from shoulder to elbow
                const shoulderToElbow = {
                    x: landmarks[14].x - landmarks[12].x,
                    y: landmarks[14].y - landmarks[12].y,
                    z: (landmarks[14].z || 0) - (landmarks[12].z || 0)
                };
                
                // Vertical line (pointing down)
                const verticalLine = {
                    x: 0,
                    y: -1,
                    z: 0
                };
                
                // Calculate angle between vertical line and shoulder-to-elbow line
                const dot = verticalLine.x * shoulderToElbow.x + verticalLine.y * shoulderToElbow.y + verticalLine.z * shoulderToElbow.z;
                const magVertical = Math.sqrt(verticalLine.x * verticalLine.x + verticalLine.y * verticalLine.y + verticalLine.z * verticalLine.z);
                const magArm = Math.sqrt(shoulderToElbow.x * shoulderToElbow.x + shoulderToElbow.y * shoulderToElbow.y + shoulderToElbow.z * shoulderToElbow.z);
                
                if (magVertical > 0 && magArm > 0) {
                    angles.elbow_flare = Math.acos(Math.max(-1, Math.min(1, dot / (magVertical * magArm)))) * (180 / Math.PI);
                }
            }
            
            // Trunk Lean: angle between vertical and hip-shoulder line
            if (landmarks[11] && landmarks[12] && landmarks[23] && landmarks[24] &&
                landmarks[11].visibility > 0.3 && landmarks[12].visibility > 0.3 &&
                landmarks[23].visibility > 0.3 && landmarks[24].visibility > 0.3) {
                const shoulderCenter = {
                    x: (landmarks[11].x + landmarks[12].x) / 2,
                    y: (landmarks[11].y + landmarks[12].y) / 2,
                    z: ((landmarks[11].z || 0) + (landmarks[12].z || 0)) / 2
                };
                const hipCenter = {
                    x: (landmarks[23].x + landmarks[24].x) / 2,
                    y: (landmarks[23].y + landmarks[24].y) / 2,
                    z: ((landmarks[23].z || 0) + (landmarks[24].z || 0)) / 2
                };
                const trunkLine = {
                    x: shoulderCenter.x - hipCenter.x,
                    y: shoulderCenter.y - hipCenter.y,
                    z: shoulderCenter.z - hipCenter.z
                };
                const vertical = { x: 0, y: -1, z: 0 };
                const dot = trunkLine.x * vertical.x + trunkLine.y * vertical.y + trunkLine.z * vertical.z;
                const mag = Math.sqrt(trunkLine.x * trunkLine.x + trunkLine.y * trunkLine.y + trunkLine.z * trunkLine.z);
                if (mag > 0) {
                    const angle = Math.acos(Math.max(-1, Math.min(1, dot / mag))) * (180 / Math.PI);
                    angles.trunk_lean = 90 - angle; // Convert to lean angle
                }
            }
            
            // Foot Alignment: Calculate based on shoulder alignment
            // First, calculate shoulder alignment angle using x and z coordinates (3D)
            let shoulderAlignmentAngle = null;
            if (landmarks[11] && landmarks[12] &&
                landmarks[11].visibility > 0.3 && landmarks[12].visibility > 0.3) {
                // Calculate shoulder line in x-z plane (top-down view)
                const deltaX = landmarks[12].x - landmarks[11].x;  // Right shoulder - Left shoulder
                const deltaZ = (landmarks[12].z || 0) - (landmarks[11].z || 0);
                
                // Calculate angle using atan2(deltaZ, deltaX)
                // This gives the angle of the line in the x-z plane
                // Positive angle = rotated counterclockwise (right shoulder forward/backward)
                // Negative angle = rotated clockwise (left shoulder forward/backward)
                // 0 = horizontal line (aligned with x-axis)
                if (deltaX !== 0 || deltaZ !== 0) {
                    const angle = Math.atan2(deltaZ, deltaX) * (180 / Math.PI);
                    shoulderAlignmentAngle = angle;
                    angles.shoulder_angle = angle; // Store shoulder angle
                }
            }
            
            // Calculate foot alignment angle using x and z coordinates (3D)
            let footAlignmentAngle = null;
            if (landmarks[27] && landmarks[28] &&
                landmarks[27].visibility > 0.3 && landmarks[28].visibility > 0.3) {
                // Calculate foot line in x-z plane (top-down view)
                const deltaX = landmarks[28].x - landmarks[27].x;  // Right ankle - Left ankle
                const deltaZ = (landmarks[28].z || 0) - (landmarks[27].z || 0);
                
                // Calculate angle using atan2(deltaZ, deltaX)
                // This gives the angle of the line in the x-z plane
                // Positive angle = rotated counterclockwise (right foot forward/backward)
                // Negative angle = rotated clockwise (left foot forward/backward)
                // 0 = horizontal line (aligned with x-axis)
                if (deltaX !== 0 || deltaZ !== 0) {
                    const angle = Math.atan2(deltaZ, deltaX) * (180 / Math.PI);
                    footAlignmentAngle = angle;
                    angles.foot_angle = angle; // Store foot angle
                }
            }
            
            // Calculate foot alignment offset (how many degrees feet are off from shoulders)
            if (shoulderAlignmentAngle !== null && footAlignmentAngle !== null) {
                // The offset is the difference between foot angle and shoulder angle
                // Positive = feet are rotated more clockwise than shoulders
                // Negative = feet are rotated more counterclockwise than shoulders
                angles.foot_alignment = footAlignmentAngle - shoulderAlignmentAngle;
            } else if (footAlignmentAngle !== null) {
                // If we can't calculate shoulder angle, just use foot angle relative to reference
                angles.foot_alignment = footAlignmentAngle;
            }
            
            return angles;
        }

        // Generate loop from video - with real-time 3D visualization
        async function generateLoop(silent = false) {
            const video = document.getElementById('userVideo');
            console.log('generateLoop called, video:', video, 'src:', video?.src, 'readyState:', video?.readyState);
            
            if (!video) {
                console.error('Video element not found');
                alert('Video element not found. Please refresh the page.');
                return;
            }
            
            if (!video.src || video.src === '' || video.src === window.location.href) {
                console.error('Video source not set');
                alert('Please upload a video first.');
                return;
            }
            
            if (isGeneratingLoop) {
                console.log('Already generating loop');
                return;
            }
            
            // Wait for video to be ready
            if (video.readyState < 2) {
                console.log('Waiting for video metadata to load...');
                await new Promise((resolve) => {
                    if (video.readyState >= 2) {
                        resolve();
                    } else {
                        video.addEventListener('loadedmetadata', resolve, { once: true });
                        // Timeout after 5 seconds
                        setTimeout(() => {
                            console.error('Video metadata load timeout');
                            alert('Video failed to load. Please try uploading again.');
                            resolve();
                        }, 5000);
                    }
                });
            }
            
            if (video.readyState < 2 || !video.videoWidth || !video.videoHeight) {
                console.error('Video not ready:', { readyState: video.readyState, width: video.videoWidth, height: video.videoHeight });
                alert('Video is not ready. Please wait for it to load completely.');
                return;
            }
            
            console.log('Video is ready:', { 
                src: video.src.substring(0, 50) + '...', 
                readyState: video.readyState, 
                width: video.videoWidth, 
                height: video.videoHeight,
                duration: video.duration 
            });
            
            // Make sure video is visible (might be hidden)
            if (video.style.display === 'none') {
                video.style.display = 'block';
            }
            
            isGeneratingLoop = true;
            const generateBtn = document.getElementById('generateAnimationBtn');
            if (!silent && generateBtn) {
                generateBtn.disabled = true;
                generateBtn.textContent = ' Processing...';
            }
            
            loop3DPoses = [];
            loop3DStages = [];
            loop3DAngles = [];
            detectedShots = []; // Reset detected shots
            currentLoopFrameIndex = 0;
            
            // Show skeleton viewer and shot counter (hide processing overlay to show skeleton)
            const processingOverlay = document.getElementById('skeletonProcessing');
            const statusEl = document.getElementById('processingStatus');

            // Hide processing overlay so skeleton is visible
            if (processingOverlay) processingOverlay.style.display = 'none';

            // Show skeleton viewer (this will display the 3D skeleton during processing)
            const readyOverlay = document.getElementById('videoReadyOverlay');
            if (readyOverlay) readyOverlay.style.display = 'flex';
            
            // Initialize loop 3D viewer if not already done
            if (!loopScene || !loopRenderer) {
                initLoop3DViewer();
                // Wait a bit for canvas to be ready
                await new Promise(resolve => setTimeout(resolve, 100));
            }
            
            try {
                const originalTime = video.currentTime;
                const originalPaused = video.paused;
                
                if (!video.paused) {
                    video.pause();
                }
                
                const duration = video.duration;
                const fps = 30;
                const frameInterval = 1 / fps;
                const totalFrames = Math.ceil(duration * fps);
                
                console.log(`Generating loop: ${totalFrames} frames`);
                
                // Create canvas for processing
                const processCanvas = document.createElement('canvas');
                const ctx = processCanvas.getContext('2d');
                
                // Check if MediaPipe Pose is available
                if (typeof Pose === 'undefined') {
                    throw new Error('MediaPipe Pose not loaded');
                }
                
                // Initialize MediaPipe Pose
                const pose = new Pose({
                    locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`
                });
                
                pose.setOptions({
                    modelComplexity: 2,
                    smoothLandmarks: true,
                    minDetectionConfidence: 0.7,
                    minTrackingConfidence: 0.7
                });
                
                let processedCount = 0;
                
                // Shot detection state (shared object for closure)
                const shotDetectionState = {
                    shotsDetected: 0,
                    currentShotFrames: [], // Store frames for current potential shot
                    currentShotStages: [],
                    currentShotAngles: [],
                    state: "looking_for_pre_shot", // looking_for_pre_shot, in_shot_sequence, shot_complete
                    shouldStop: false,
                    lastDetectedStage: 'neutral', // Track stage for speed control
                    seenFollowThrough: false, // Track if we've seen follow_through in current sequence
                    elbowDropped: false // Track if elbow has dropped below shoulder
                };
                
                pose.onResults((results) => {
                    if (results.poseLandmarks) {
                        const landmarks = results.poseLandmarks.map((lm, i) => ({
                            x: lm.x,
                            y: lm.y,
                            z: lm.z || 0,
                            visibility: lm.visibility || 1
                        }));
                        
                        // Detect shot stage
                        let state = 'neutral';
                        const rightWrist = landmarks[16];
                        const leftWrist = landmarks[15];
                        const rightShoulder = landmarks[12];
                        const leftShoulder = landmarks[11];
                        const rightHip = landmarks[24]; // Right hip (waist)
                        
                        if (rightWrist && rightShoulder && rightHip) {
                            // Follow-through: wrist is above shoulder (arm raised high)
                            // In normalized coordinates, smaller y = higher on screen
                            if (rightWrist.y < rightShoulder.y) {
                                state = 'follow_through';
                            }
                            // Pre-shot: right wrist is below shoulder AND above right waist 
                            // AND within shoulder width distance of left wrist
                            else if (rightWrist.y > rightShoulder.y && rightWrist.y < rightHip.y) {
                                // Check if wrists are within shoulder width distance
                                if (leftWrist && leftShoulder) {
                                    // Calculate shoulder width distance (3D distance)
                                    const shoulderWidth = Math.sqrt(
                                        Math.pow(rightShoulder.x - leftShoulder.x, 2) + 
                                        Math.pow((rightShoulder.z || 0) - (leftShoulder.z || 0), 2)
                                    );
                                    
                                    // Calculate distance between wrists (3D distance)
                                    const wristDistance = Math.sqrt(
                                        Math.pow(rightWrist.x - leftWrist.x, 2) + 
                                        Math.pow((rightWrist.z || 0) - (leftWrist.z || 0), 2)
                                    );
                                    
                                    // Check if wrists are within shoulder width distance (hands together)
                                    if (wristDistance <= shoulderWidth * 1.5) {
                                        state = 'pre_shot';
                                    }
                                }
                            }
                        }
                        
                        // Update last detected stage for speed control
                        shotDetectionState.lastDetectedStage = state;
                        
                        // Update 3D skeleton in real-time (always show during processing)
                        if (loopScene && loopRenderer) {
                            updateLoop3DSkeleton(landmarks, state);
                            loopRenderer.render(loopScene, loopCamera);
                        }
                        
                        // Extract angles for this frame
                        const angles = extractAnglesFromLandmarks(landmarks);
                        
                        // Shot detection state machine - only store frames when in a shot sequence
                        if (shotDetectionState.state === "looking_for_pre_shot") {
                            // Waiting for pre_shot to start a new sequence
                            if (state === "pre_shot") {
                                // Start of potential shot sequence
                                shotDetectionState.currentShotFrames = [landmarks];
                                shotDetectionState.currentShotStages = [state];
                                shotDetectionState.currentShotAngles = [angles];
                                
                                // Add first frame to main arrays
                                loop3DPoses.push(landmarks);
                                loop3DStages.push(state);
                                loop3DAngles.push(angles);
                                
                                // Sync to window for webcam recording
                                window.loop3DPoses = loop3DPoses;
                                window.loop3DStages = loop3DStages;
                                window.loop3DAngles = loop3DAngles;
                                
                                shotDetectionState.state = "in_shot_sequence";
                                shotDetectionState.seenFollowThrough = false;
                                shotDetectionState.elbowDropped = false;
                                console.log('Started potential shot sequence');
                            }
                            // Otherwise, skip this frame (not in a shot)
                        } else if (shotDetectionState.state === "in_shot_sequence") {
                            // Check if sequence broke: if we go to neutral before seeing follow_through, reset
                            if (state === "neutral" && !shotDetectionState.seenFollowThrough) {
                                // Sequence broke before follow_through, reset and wait for next pre_shot
                                console.log('Shot sequence broken (went to neutral before follow_through), resetting...');
                                shotDetectionState.currentShotFrames = [];
                                shotDetectionState.currentShotStages = [];
                                shotDetectionState.currentShotAngles = [];
                                shotDetectionState.state = "looking_for_pre_shot";
                                shotDetectionState.seenFollowThrough = false;
                                shotDetectionState.elbowDropped = false;
                                return; // Skip this frame, wait for next pre_shot
                            }
                            
                            // We're in a shot sequence, keep adding frames
                            shotDetectionState.currentShotFrames.push(landmarks);
                            shotDetectionState.currentShotStages.push(state);
                            shotDetectionState.currentShotAngles.push(angles);
                            
                            // Also add directly to main arrays (no waiting for completion)
                            loop3DPoses.push(landmarks);
                            loop3DStages.push(state);
                            loop3DAngles.push(angles);
                            
                            // Track if we've seen follow_through
                            if (state === "follow_through") {
                                shotDetectionState.seenFollowThrough = true;
                            }
                            
                            // Check if shot is complete: wrist in follow_through comes below right shoulder
                            if (shotDetectionState.seenFollowThrough && landmarks && landmarks.length > 16) {
                                const rightWrist = landmarks[16]; // Right wrist
                                const rightShoulder = landmarks[12]; // Right shoulder
                                
                                if (rightWrist && rightShoulder && rightWrist.y !== undefined && rightShoulder.y !== undefined) {
                                    // In normalized coordinates, larger y = lower on screen
                                    // If wrist.y > shoulder.y, wrist is below shoulder
                                    // This means the wrist has dropped below the shoulder after follow_through
                                    if (rightWrist.y > rightShoulder.y) {
                                        // Shot complete! Mark it and reset for next shot
                                        const shotStartIndex = loop3DPoses.length - shotDetectionState.currentShotFrames.length;
                                const shotEndIndex = loop3DPoses.length - 1;
                                
                                shotDetectionState.shotsDetected++;
                                detectedShots.push({
                                    start: shotStartIndex,
                                    end: shotEndIndex,
                                    frames: shotDetectionState.currentShotFrames.length
                                });
                                
                                        if (isUploadMode) {
                                            console.log(` Shot ${shotDetectionState.shotsDetected} detected: ${shotDetectionState.currentShotFrames.length} frames (wrist dropped below shoulder)`);
                                        } else {
                                            console.log(` Shot ${shotDetectionState.shotsDetected}/${selectedShotCount} complete: ${shotDetectionState.currentShotFrames.length} frames (wrist dropped below shoulder)`);
                                        }
                                
                                // Check if we've reached the target
                                if (shotDetectionState.shotsDetected >= selectedShotCount) {
                                    shotDetectionState.shouldStop = true;
                                    console.log(`Reached target of ${selectedShotCount} shots, will stop processing`);
                                } else {
                                            // Reset and wait for next pre_shot
                                shotDetectionState.currentShotFrames = [];
                                shotDetectionState.currentShotStages = [];
                                shotDetectionState.currentShotAngles = [];
                                shotDetectionState.state = "looking_for_pre_shot";
                                            shotDetectionState.seenFollowThrough = false;
                                            shotDetectionState.elbowDropped = false;
                            }
                                    }
                                }
                            }
                            
                            // Continue recording all frames - no early stopping
                            // Otherwise, continue adding frames to current sequence
                        }
                    }
                    processedCount++;
                });
                
                await pose.initialize();
                
                // Process each frame with variable speed
                for (let frameIndex = 0; frameIndex < totalFrames; frameIndex++) {
                    // Check if we should stop (after reaching target number of shots)
                    if (shotDetectionState.shouldStop) {
                        console.log(`Stopping processing at frame ${frameIndex} (reached ${shotDetectionState.shotsDetected} shots)`);
                        if (statusEl) {
                            statusEl.textContent = ` Detected ${shotDetectionState.shotsDetected} shot(s), finalizing...`;
                        }
                        break;
                    }
                    
                    const targetTime = frameIndex * frameInterval;
                    if (targetTime >= duration) break;
                    
                    // Seek to frame
                    video.currentTime = targetTime;
                    
                    // Wait for seek to complete
                    await new Promise((resolve) => {
                        if (Math.abs(video.currentTime - targetTime) < 0.1) {
                            resolve();
                            return;
                        }
                        const onSeeked = () => {
                            video.removeEventListener('seeked', onSeeked);
                            resolve();
                        };
                        video.addEventListener('seeked', onSeeked);
                        setTimeout(() => {
                            video.removeEventListener('seeked', onSeeked);
                            resolve();
                        }, 1000);
                    });
                    
                    // Variable delay based on stage: fast for neutral, slow for shot sequences
                    // Use the stage detected from the previous frame
                    let frameDelay = 10; // Very fast for neutral (skip quickly)
                    if (shotDetectionState.lastDetectedStage === 'pre_shot' || shotDetectionState.lastDetectedStage === 'follow_through') {
                        frameDelay = 200; // Slower for shot sequences (20x slower)
                    }
                    
                    // Wait for frame to render (variable delay)
                    await new Promise(resolve => setTimeout(resolve, frameDelay));
                    
                    // Capture and process frame (wait for video to be ready)
                    // Check if video is ready - need at least HAVE_CURRENT_DATA (readyState >= 2)
                    if (video.readyState < 2) {
                        // Wait a bit for video to load more data
                        await new Promise(resolve => setTimeout(resolve, 50));
                    }
                    
                    if (video.videoWidth > 0 && video.videoHeight > 0 && video.readyState >= 2) {
                        processCanvas.width = video.videoWidth;
                        processCanvas.height = video.videoHeight;
                        
                        try {
                            ctx.drawImage(video, 0, 0, processCanvas.width, processCanvas.height);
                            
                            // Verify we actually drew something
                            const imageData = ctx.getImageData(0, 0, 1, 1);
                            if (imageData.data[3] === 0) {
                                console.warn(`Frame ${frameIndex} appears to be empty`);
                            }
                            
                            // Process through MediaPipe (onResults callback will update skeleton and stage)
                            await pose.send({ image: processCanvas });
                        } catch (error) {
                            console.error(`Error processing frame ${frameIndex}:`, error);
                        }
                    } else {
                        console.warn(`Frame ${frameIndex} skipped - video not ready:`, {
                            width: video.videoWidth,
                            height: video.videoHeight,
                            readyState: video.readyState
                        });
                    }
                    
                    // Don't show progress text - skeleton overlay is visible instead
                    // Progress is shown through the skeleton animation
                }
                
                // Close pose
                pose.close();
                
                // Restore original state
                video.currentTime = originalTime;
                
                // Handle final shot if we ended in a shot sequence
                // Note: Frames are already added to main arrays during processing, but we need to track the shot
                if (shotDetectionState.state === "in_shot_sequence" && shotDetectionState.currentShotFrames.length > 0) {
                    // Calculate shot boundaries (frames were already added during processing)
                    const shotStartIndex = loop3DPoses.length - shotDetectionState.currentShotFrames.length;
                        const shotEndIndex = loop3DPoses.length - 1;
                        
                        shotDetectionState.shotsDetected++;
                        detectedShots.push({
                            start: shotStartIndex,
                            end: shotEndIndex,
                            frames: shotDetectionState.currentShotFrames.length
                        });
                    console.log(`Shot ${shotDetectionState.shotsDetected}/${selectedShotCount} detected: ${shotDetectionState.currentShotFrames.length} frames`);
                }
                
                if (loop3DPoses.length > 0) {
                    console.log(`Total shots detected: ${detectedShots.length}, total frames stored: ${loop3DPoses.length}`);
                    
                    // All frames in loop3DPoses are already from valid shot sequences
                    // If we detected more shots than requested, we need to trim to only the first N shots
                    if (detectedShots.length > selectedShotCount) {
                        // Calculate how many frames to keep (first N shots)
                        let framesToKeep = 0;
                        for (let i = 0; i < selectedShotCount; i++) {
                            framesToKeep += detectedShots[i].frames;
                        }
                        
                        // Trim arrays to only include first N shots
                        loop3DPoses = loop3DPoses.slice(0, framesToKeep);
                        loop3DStages = loop3DStages.slice(0, framesToKeep);
                        loop3DAngles = loop3DAngles.slice(0, framesToKeep);
                        
                        console.log(`Trimmed to first ${selectedShotCount} shots: ${framesToKeep} frames`);
                    }
                    
                    // Update status to show shot count
                    if (statusEl && !silent) {
                        const shotsUsed = Math.min(detectedShots.length, selectedShotCount);
                        if (detectedShots.length >= selectedShotCount) {
                            statusEl.textContent = ` Successfully detected and clipped ${shotsUsed} shot(s) (${loop3DPoses.length} frames)`;
                        } else {
                            statusEl.textContent = ` Detected ${detectedShots.length} shot(s), using all (${loop3DPoses.length} frames, requested: ${selectedShotCount})`;
                        }
                    }
                    console.log(`Shot processing complete: ${Math.min(detectedShots.length, selectedShotCount)} shots, ${loop3DPoses.length} total frames`);
                    
                    // Interpolate frames to make animation smoother (16x frames)
                    const interpolationFactor = 16;
                    const originalFrameCount = loop3DPoses.length;
                    const interpolatedPoses = interpolateFrames(loop3DPoses, interpolationFactor);
                    loop3DPoses = interpolatedPoses;
                    
                    // Interpolate stages as well
                    if (loop3DStages && loop3DStages.length > 0) {
                        const interpolatedStages = [];
                        for (let i = 0; i < interpolatedPoses.length; i++) {
                            const originalFrameIndex = Math.floor(i / interpolationFactor);
                            const stage = loop3DStages[Math.min(originalFrameIndex, loop3DStages.length - 1)] || "neutral";
                            interpolatedStages.push(stage);
                        }
                        loop3DStages = interpolatedStages;
                    }
                    
                    // Interpolate angles as well (linear interpolation)
                    if (loop3DAngles && loop3DAngles.length > 0) {
                        const interpolatedAngles = [];
                        for (let i = 0; i < interpolatedPoses.length; i++) {
                            const originalFrameIndex = Math.floor(i / interpolationFactor);
                            const nextFrameIndex = (originalFrameIndex + 1) % loop3DAngles.length;
                            const t = (i % interpolationFactor) / interpolationFactor;
                            
                            const currentAngles = loop3DAngles[originalFrameIndex] || {};
                            const nextAngles = loop3DAngles[nextFrameIndex] || {};
                            const interpolated = {};
                            
                            // Interpolate each angle
                            Object.keys(currentAngles).forEach(key => {
                                if (currentAngles[key] !== null && nextAngles[key] !== null) {
                                    interpolated[key] = currentAngles[key] + (nextAngles[key] - currentAngles[key]) * t;
                                } else if (currentAngles[key] !== null) {
                                    interpolated[key] = currentAngles[key];
                                } else if (nextAngles[key] !== null) {
                                    interpolated[key] = nextAngles[key];
                                }
                            });
                            
                            interpolatedAngles.push(interpolated);
                        }
                        loop3DAngles = interpolatedAngles;
                    }
                    
                    // Show save player data form, download button, and clip button (always, even when silent)
                    const saveForm = document.getElementById('savePlayerDataForm');
                    if (saveForm && loop3DPoses.length > 0) {
                        saveForm.style.display = 'block';
                    }
                    const downloadExtractionContainer = document.getElementById('downloadExtractionContainer');
                    if (downloadExtractionContainer && loop3DPoses.length > 0) {
                        downloadExtractionContainer.style.display = 'block';
                    }
                    const clipButtonContainer = document.getElementById('clipButtonContainer');
                    if (clipButtonContainer && loop3DPoses.length > 0) {
                        clipButtonContainer.style.display = 'block';
                    }
                    
                    if (!silent) {
                        if (statusEl) {
                            statusEl.textContent = ` Loop generated! ${loop3DPoses.length} frames (${originalFrameCount} original, ${loop3DPoses.length - originalFrameCount} interpolated)`;
                        }
                        
                        // Update frame slider
                        const slider = document.getElementById('frameSlider');
                        if (slider) {
                            slider.max = loop3DPoses.length - 1;
                            slider.value = 0;
                        }
                        
                        // Update frame counter
                        const counter = document.getElementById('frameCounter');
                        if (counter) {
                            counter.textContent = `Frame: 1/${loop3DPoses.length}`;
                        }
                        
                        // Hide processing overlay
                        if (processingOverlay) processingOverlay.style.display = 'none';
                    }
                    
                    // Don't show animation automatically - just extract data for metrics
                    // Animation will only show if user clicks "Generate Animation" button
                    console.log('Loop generated with angles:', loop3DAngles.length, 'frames');
                    if (loop3DAngles.length > 0) {
                        console.log('Sample angles:', loop3DAngles[0]);
                    }
                    
                    // Store that angles have been extracted
                    window.anglesExtracted = true;
                } else {
                    console.warn('No shot sequences detected');
                    if (statusEl && !silent) {
                        statusEl.textContent = ' No shot sequences detected. Please ensure the video contains complete shot sequences (pre_shot  follow_through  pre_shot).';
                    }
                    if (processingOverlay) processingOverlay.style.display = 'none';
                }
                
            } catch (error) {
                console.error('Error generating loop:', error);
                const statusEl = document.getElementById('processingStatus');
                if (statusEl) statusEl.textContent = ' Error: ' + error.message;
                const processingOverlay = document.getElementById('skeletonProcessing');
                if (processingOverlay) processingOverlay.style.display = 'none';
            } finally {
                isGeneratingLoop = false;
                if (!silent) {
                    const generateBtn = document.getElementById('generateAnimationBtn');
                    if (generateBtn) {
                        generateBtn.disabled = false;
                        generateBtn.textContent = ' Generate Animation';
                    }
                }
            }
        }

        // Start skeleton viewer - now generates loop from video
        function startSkeletonViewer() {
            // Generate loop from video
            generateLoop();
        }

        // Stop skeleton viewer
        function stopSkeletonViewer() {
            isLoopPlaying = false;
            if (loopAnimationFrameId) {
                clearTimeout(loopAnimationFrameId);
                loopAnimationFrameId = null;
            }
        }

        // Setup loop animation controls on DOM load
        document.addEventListener('DOMContentLoaded', function() {
            // Frame slider event - scrub through frames
            const slider = document.getElementById('frameSlider');
            if (slider) {
                slider.addEventListener('input', function(e) {
                    isLoopPlaying = false;
                    if (window.isLoopPlaying !== undefined) window.isLoopPlaying = false;
                    const playBtn = document.getElementById('playPauseLoop');
                    const pauseBtn = document.getElementById('pauseLoopBtn');
                    if (playBtn) playBtn.style.display = 'inline-block';
                    if (pauseBtn) pauseBtn.style.display = 'none';

                    const frameIndex = parseInt(e.target.value);
                    currentLoopFrameIndex = frameIndex;
                    if (window.currentLoopFrameIndex !== undefined) window.currentLoopFrameIndex = frameIndex;
                    
                    // Sync with window if needed
                    const poses = loop3DPoses.length > 0 ? loop3DPoses : (window.loop3DPoses || []);
                    const stages = loop3DStages.length > 0 ? loop3DStages : (window.loop3DStages || []);
                    
                    if (poses && poses[frameIndex]) {
                        updateLoop3DSkeleton(poses[frameIndex], stages[frameIndex] || 'neutral');

                        const counter = document.getElementById('frameCounter');
                        if (counter) counter.textContent = `Frame: ${frameIndex + 1}/${poses.length}`;
                    }
                });
            }

            // Play button
            const playBtn = document.getElementById('playPauseLoop');
            if (playBtn) {
                playBtn.addEventListener('click', function() {
                    // Sync with window if needed
                    const poses = loop3DPoses.length > 0 ? loop3DPoses : (window.loop3DPoses || []);
                    if (poses.length > 0) {
                        isLoopPlaying = true;
                        if (window.isLoopPlaying !== undefined) window.isLoopPlaying = true;
                        this.style.display = 'none';
                        const pauseBtn = document.getElementById('pauseLoopBtn');
                        if (pauseBtn) pauseBtn.style.display = 'inline-block';
                        animateLoop();
                    }
                });
            }

            // Pause button
            const pauseBtn = document.getElementById('pauseLoopBtn');
            if (pauseBtn) {
                pauseBtn.addEventListener('click', function() {
                    isLoopPlaying = false;
                    if (loopAnimationFrameId) {
                        clearTimeout(loopAnimationFrameId);
                        loopAnimationFrameId = null;
                    }
                    const playBtn = document.getElementById('playPauseLoop');
                    if (playBtn) playBtn.style.display = 'inline-block';
                    this.style.display = 'none';
                });
            }

            // Camera X position control (horizontal)
            const cameraXSlider = document.getElementById('cameraX');
            if (cameraXSlider) {
                cameraXSlider.addEventListener('input', function(e) {
                    if (loopCamera) {
                        const angle = (parseFloat(e.target.value) * Math.PI) / 180;
                        const radius = 5;
                        loopCamera.position.x = Math.sin(angle) * radius;
                        loopCamera.position.z = Math.cos(angle) * radius;
                        loopCamera.lookAt(0, 0, 0);
                        if (loopRenderer && loopScene) {
                            loopRenderer.render(loopScene, loopCamera);
                        }
                    }
                });
            }

            // Camera Y position control (vertical)
            const cameraYSlider = document.getElementById('cameraY');
            if (cameraYSlider) {
                cameraYSlider.addEventListener('input', function(e) {
                    if (loopCamera) {
                        loopCamera.position.y = parseFloat(e.target.value);
                        loopCamera.lookAt(0, 0, 0);
                        if (loopRenderer && loopScene) {
                            loopRenderer.render(loopScene, loopCamera);
                        }
                    }
                });
            }

            // Camera zoom control
            const cameraZoomSlider = document.getElementById('cameraZoom');
            if (cameraZoomSlider) {
                cameraZoomSlider.addEventListener('input', function(e) {
                    if (loopCamera) {
                        const distance = parseFloat(e.target.value);
                        const direction = new THREE.Vector3();
                        loopCamera.getWorldDirection(direction);
                        direction.multiplyScalar(-distance);
                        loopCamera.position.set(direction.x, loopCamera.position.y, direction.z);
                        loopCamera.lookAt(0, 0, 0);
                        if (loopRenderer && loopScene) {
                            loopRenderer.render(loopScene, loopCamera);
                        }
                    }
                });
            }
        });

        // ====================== BENCHMARK UPLOAD FUNCTIONALITY ======================
        
        let benchmarkVideoData = null;
        let currentDisplayMode = 'averaged'; // 'single' or 'averaged'
        let currentFrameIndex = 0;

        // Video file input handler
        document.getElementById('benchmarkVideoInput')?.addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                document.getElementById('benchmarkVideoFileName').textContent = `Selected: ${file.name}`;
                document.getElementById('processBenchmarkBtn').style.display = 'inline-block';
                benchmarkVideoData = null; // Reset previous data
                document.getElementById('benchmarkMetricsDisplay').style.display = 'none';
            }
        });

        // Process video button handler - uses same code as generateLoop
        document.getElementById('processBenchmarkBtn')?.addEventListener('click', async function() {
            const fileInput = document.getElementById('benchmarkVideoInput');
            const file = fileInput.files[0];
            
            if (!file) {
                alert('Please select a video file first');
                return;
            }

            const statusEl = document.getElementById('benchmarkProcessingStatus');
            const processBtn = document.getElementById('processBenchmarkBtn');
            const skeletonContainer = document.getElementById('benchmarkSkeletonContainer');
            const processingOverlay = document.getElementById('benchmarkSkeletonProcessing');
            const statusText = document.getElementById('benchmarkProcessingStatusText');
            
            processBtn.disabled = true;
            statusEl.style.display = 'block';
            statusEl.style.background = '#f0f9ff';
            statusEl.style.color = '#0369a1';
            statusEl.textContent = 'Processing video... This may take a moment.';
            
            // Show skeleton container immediately (before video loads)
            if (skeletonContainer) {
                skeletonContainer.style.display = 'block';
                // Make sure it's visible
                skeletonContainer.style.visibility = 'visible';
            }
            if (processingOverlay) {
                processingOverlay.style.display = 'flex';
            }
            if (statusText) statusText.textContent = 'Extracting skeleton...';

            try {
                // Create video element
                const video = document.createElement('video');
                video.src = URL.createObjectURL(file);
                video.muted = true;
                video.playsInline = true;
                
                // Wait for video to load
                await new Promise((resolve, reject) => {
                    video.addEventListener('loadedmetadata', resolve, { once: true });
                    video.addEventListener('error', reject, { once: true });
                    setTimeout(() => reject(new Error('Video load timeout')), 10000);
                });
                
                const duration = video.duration;
                const fps = 30;
                const frameInterval = 1 / fps;
                const totalFrames = Math.ceil(duration * fps);
                
                console.log(`Processing benchmark video: ${totalFrames} frames`);
                
                // Initialize 3D viewer for benchmark
                const canvas = document.getElementById('benchmarkSkeletonCanvas');
                if (!canvas) throw new Error('Canvas not found');
                
                let benchmarkScene = null;
                let benchmarkRenderer = null;
                let benchmarkCamera = null;
                
                // Initialize Three.js scene
                const width = canvas.offsetWidth;
                const height = canvas.offsetHeight;
                
                benchmarkScene = new THREE.Scene();
                benchmarkScene.background = new THREE.Color(0x1a1a1a);
                
                benchmarkCamera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
                benchmarkCamera.position.set(0, 1.5, 3);
                benchmarkCamera.lookAt(0, 0, 0);
                
                benchmarkRenderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
                benchmarkRenderer.setSize(width, height, false);
                
                // Add grid and axes
                const gridHelper = new THREE.GridHelper(10, 10, 0x333333, 0x222222);
                benchmarkScene.add(gridHelper);
                
                const axesHelper = new THREE.AxesHelper(2);
                benchmarkScene.add(axesHelper);
                
                // Add lighting (required for MeshPhongMaterial)
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                benchmarkScene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(5, 10, 5);
                benchmarkScene.add(directionalLight);
                
                // Skeleton visualization - use same complex code as shot sync tab
                let benchmarkSkeletonObjects = [];
                
                // Helper function to get stage color (same as shot sync)
                const getBenchmarkStageColor = (stage) => {
                    const colors = {
                        'neutral': 0x888888,
                        'pre_shot': 0x0000FF,  // Blue
                        'follow_through': 0x00FF00  // Green
                    };
                    return colors[stage] || 0x888888;
                };
                
                const updateBenchmarkSkeleton = (landmarks, stage = null) => {
                    if (!benchmarkScene || !landmarks || landmarks.length === 0) return;

                    // Clear previous skeleton
                    benchmarkSkeletonObjects.forEach(obj => benchmarkScene.remove(obj));
                    benchmarkSkeletonObjects = [];

                    // Get current stage for color coding (use provided stage or default to neutral)
                    const currentStage = stage || "neutral";
                    const stageColor = getBenchmarkStageColor(currentStage);

                    // Complete MediaPipe Pose connections (all main body connections)
                    const connections = [
                        // Torso (core skeleton)
                        [11, 12],  // Shoulders
                        [11, 23],  // Left shoulder to left hip
                        [12, 24],  // Right shoulder to right hip
                        [23, 24],  // Hips
                        // Left arm (complete chain)
                        [11, 13],  // Left shoulder to left elbow
                        [13, 15],  // Left elbow to left wrist
                        // Right arm (complete chain)
                        [12, 14],  // Right shoulder to right elbow
                        [14, 16],  // Right elbow to right wrist
                        // Left leg (complete chain)
                        [23, 25],  // Left hip to left knee
                        [25, 27],  // Left knee to left ankle
                        // Right leg (complete chain)
                        [24, 26],  // Right hip to right knee
                        [26, 28]   // Right knee to right ankle
                    ];

                    // First pass: calculate center for better normalization
                    let centerX = 0, centerY = 0, centerZ = 0;
                    let validCount = 0;
                    
                    landmarks.forEach((lm) => {
                        // If visibility is missing, assume it's visible (1.0)
                        const visibility = lm.visibility !== undefined ? lm.visibility : 1.0;
                        if (visibility >= 0.3) {
                            centerX += lm.x;
                            centerY += lm.y;
                            centerZ += (lm.z || 0);
                            validCount++;
                        }
                    });
                    
                    if (validCount === 0) return;
                    
                    centerX /= validCount;
                    centerY /= validCount;
                    centerZ /= validCount;
                    
                    // Calculate scale based on shoulder width (more stable)
                    let scale = 4.0;
                    const leftShoulder = landmarks[11];
                    const rightShoulder = landmarks[12];
                    if (leftShoulder && rightShoulder) {
                        const leftVis = leftShoulder.visibility !== undefined ? leftShoulder.visibility : 1.0;
                        const rightVis = rightShoulder.visibility !== undefined ? rightShoulder.visibility : 1.0;
                        if (leftVis > 0.5 && rightVis > 0.5) {
                            const shoulderWidth = Math.abs(leftShoulder.x - rightShoulder.x);
                            scale = Math.max(3.0, Math.min(6.0, 1.0 / (shoulderWidth + 0.1)));
                        }
                    }

                    // Helper function to calculate 3D position from landmark
                    const calculatePos3D = (lm) => {
                        const x = (lm.x - centerX) * scale * 2;
                        const y = -(lm.y - centerY) * scale * 2;  // Flip Y for 3D
                        const zOffset = (lm.z || 0) - centerZ;
                        const z = zOffset * scale * 0.5;  // Reduced Z scale
                        return { x, y, z };
                    };

                    // Create joints (spheres) with improved coordinate transformation
                    landmarks.forEach((lm, index) => {
                        // Calculate position for all landmarks (even low visibility ones for connections)
                        const pos3d = calculatePos3D(lm);
                        landmarks[index].pos3d = pos3d;
                        
                        // Only create visible spheres for landmarks with good visibility
                        const visibility = lm.visibility !== undefined ? lm.visibility : 1.0;
                        if (visibility < 0.3) {
                            return;  // Don't show sphere, but keep pos3d for connections
                        }

                        const geometry = new THREE.SphereGeometry(0.04, 12, 12);
                        // Use stage color instead of visibility-based color
                        const material = new THREE.MeshPhongMaterial({ 
                            color: stageColor, 
                            emissive: stageColor, 
                            emissiveIntensity: 0.4,
                            shininess: 30
                        });
                        const sphere = new THREE.Mesh(geometry, material);
                        sphere.position.set(pos3d.x, pos3d.y, pos3d.z);
                        benchmarkScene.add(sphere);
                        benchmarkSkeletonObjects.push(sphere);
                    });

                    // Create connections (lines) - draw if both landmarks exist and have reasonable visibility
                    connections.forEach(([startIdx, endIdx]) => {
                        if (startIdx >= landmarks.length || endIdx >= landmarks.length) {
                            return;
                        }
                        
                        const start = landmarks[startIdx];
                        const end = landmarks[endIdx];
                        
                        if (!start || !end) {
                            return;
                        }
                        
                        // Draw connection if both landmarks have at least minimal visibility
                        const startVis = start.visibility !== undefined ? start.visibility : 1.0;
                        const endVis = end.visibility !== undefined ? end.visibility : 1.0;
                        if (startVis < 0.2 || endVis < 0.2) {
                            return;  // Too low visibility, skip connection
                        }
                        
                        // pos3d should already be set from the joint creation loop above
                        if (!start.pos3d || !end.pos3d) {
                            return;  // Safety check
                        }

                        const geometry = new THREE.BufferGeometry().setFromPoints([
                            new THREE.Vector3(start.pos3d.x, start.pos3d.y, start.pos3d.z),
                            new THREE.Vector3(end.pos3d.x, end.pos3d.y, end.pos3d.z)
                        ]);

                        // Make connections more visible - use stage color
                        const material = new THREE.LineBasicMaterial({ 
                            color: stageColor, 
                            linewidth: 3,
                            opacity: 0.95,
                            transparent: true
                        });
                        const line = new THREE.Line(geometry, material);
                        benchmarkScene.add(line);
                        benchmarkSkeletonObjects.push(line);
                    });
                    
                    // Update camera aspect ratio in case canvas size changed
                    if (benchmarkCamera && benchmarkRenderer) {
                        const canvas = document.getElementById('benchmarkSkeletonCanvas');
                        if (canvas) {
                            const width = canvas.clientWidth || 800;
                            const height = canvas.clientHeight || 800;
                            benchmarkCamera.aspect = width / height;
                            benchmarkCamera.updateProjectionMatrix();
                            benchmarkRenderer.setSize(width, height, false);
                        }
                    }
                    
                    benchmarkRenderer.render(benchmarkScene, benchmarkCamera);
                };
                
                // Animate benchmark loop (EXACT same code as shot sync tab)
                const animateBenchmarkLoop = () => {
                    if (!isBenchmarkPlaying || benchmark3DPoses.length === 0) return;
                    
                    // Update to current frame
                    if (benchmarkCurrentFrameIndex < benchmark3DPoses.length) {
                        const currentStage = benchmark3DStages[benchmarkCurrentFrameIndex] || 'neutral';
                        updateBenchmarkSkeleton(benchmark3DPoses[benchmarkCurrentFrameIndex], currentStage);
                        
                        // Move to next frame
                        benchmarkCurrentFrameIndex = (benchmarkCurrentFrameIndex + 1) % benchmark3DPoses.length;
                    }
                    
                    // Continue animation (ultra-fast frame-by-frame: ~256 fps for extremely smooth playback)
                    benchmarkAnimationFrameId = setTimeout(() => {
                        requestAnimationFrame(animateBenchmarkLoop);
                    }, 3.90625); // 3.90625ms = ~256 fps (1/128 of original 500ms)
                };
                
                // Create canvas for processing
                const processCanvas = document.createElement('canvas');
                const ctx = processCanvas.getContext('2d');
                
                // Check if MediaPipe Pose is available
                if (typeof Pose === 'undefined') {
                    throw new Error('MediaPipe Pose not loaded');
                }
                
                // Initialize MediaPipe Pose
                const pose = new Pose({
                    locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`
                });
                
                pose.setOptions({
                    modelComplexity: 2,
                    smoothLandmarks: true,
                    minDetectionConfidence: 0.7,
                    minTrackingConfidence: 0.7
                });
                
                // Store extracted data
                const extractedPoses = [];
                const extractedStages = [];
                const extractedAngles = [];
                // Store normalized landmarks for animation (same as loop3DPoses in shot sync)
                const benchmark3DPoses = [];
                const benchmark3DStages = [];
                let recordingActive = false;
                let seenFollowThrough = false;
                let startTime = 0;
                let shotComplete = false; // Flag to stop after first complete shot
                let benchmarkCurrentFrameIndex = 0;
                let isBenchmarkPlaying = false;
                let benchmarkAnimationFrameId = null;
                
                pose.onResults((results) => {
                    if (results.poseLandmarks) {
                        // Keep landmarks in MediaPipe format for angle calculations
                        const landmarks = results.poseLandmarks.map((lm, i) => ({
                            x: lm.x,
                            y: lm.y,
                            z: lm.z || 0,
                            visibility: lm.visibility || 1
                        }));
                        
                        // Detect shot stage
                        let state = 'neutral';
                        const rightWrist = landmarks[16];
                        const leftWrist = landmarks[15];
                        const rightShoulder = landmarks[12];
                        const leftShoulder = landmarks[11];
                        const rightHip = landmarks[24]; // Right hip (waist)
                        
                        if (rightWrist && rightShoulder && rightHip) {
                            // Follow-through: wrist is above shoulder (arm raised high)
                            // In normalized coordinates, smaller y = higher on screen
                            if (rightWrist.y < rightShoulder.y) {
                                state = 'follow_through';
                            }
                            // Pre-shot: right wrist is below shoulder AND above right waist 
                            // AND within shoulder width distance of left wrist
                            else if (rightWrist.y > rightShoulder.y && rightWrist.y < rightHip.y) {
                                // Check if wrists are within shoulder width distance
                                if (leftWrist && leftShoulder) {
                                    // Calculate shoulder width distance (3D distance)
                                    const shoulderWidth = Math.sqrt(
                                        Math.pow(rightShoulder.x - leftShoulder.x, 2) + 
                                        Math.pow((rightShoulder.z || 0) - (leftShoulder.z || 0), 2)
                                    );
                                    
                                    // Calculate distance between wrists (3D distance)
                                    const wristDistance = Math.sqrt(
                                        Math.pow(rightWrist.x - leftWrist.x, 2) + 
                                        Math.pow((rightWrist.z || 0) - (leftWrist.z || 0), 2)
                                    );
                                    
                                    // Check if wrists are within shoulder width distance (hands together)
                                    if (wristDistance <= shoulderWidth * 1.5) {
                                        state = 'pre_shot';
                                    }
                                }
                            }
                        }
                        
                        // Update 3D skeleton in real-time (preserve visibility for complex skeleton rendering)
                        const normalizedFor3D = landmarks.map(lm => ({
                            x: lm.x,
                            y: lm.y,
                            z: lm.z || 0,
                            visibility: lm.visibility !== undefined ? lm.visibility : 1.0
                        }));
                        
                        // Show skeleton during processing (but don't store here - store in recordingActive block)
                        if (!isBenchmarkPlaying && recordingActive) {
                            updateBenchmarkSkeleton(normalizedFor3D, state);
                        }
                        
                        // Extract angles using the function that expects MediaPipe format
                        const angles = extractAnglesFromLandmarks(results.poseLandmarks);
                        
                        // Store results in closure for use below
                        const currentResults = results;
                        
                        // Track shot sequence (same logic as generateLoop)
                        // For benchmark, we want to capture the first complete shot sequence
                        if (state === "pre_shot" && !recordingActive) {
                            // Start of potential shot sequence
                            recordingActive = true;
                            seenFollowThrough = false;
                            startTime = video.currentTime;
                            extractedPoses.length = 0;
                            extractedStages.length = 0;
                            extractedAngles.length = 0;
                            benchmark3DPoses.length = 0;
                            benchmark3DStages.length = 0;
                        } else if (state === "neutral" && recordingActive && !seenFollowThrough) {
                            // Sequence broke before follow_through, reset
                            recordingActive = false;
                            seenFollowThrough = false;
                            startTime = 0;
                            extractedPoses.length = 0;
                            extractedStages.length = 0;
                            extractedAngles.length = 0;
                            benchmark3DPoses.length = 0;
                            benchmark3DStages.length = 0;
                        } else if (state === "follow_through" && recordingActive) {
                            seenFollowThrough = true;
                        } else if (state === "pre_shot" && recordingActive && seenFollowThrough) {
                            // Complete shot sequence detected (pre_shot  follow_through  pre_shot)
                            // Mark as complete - the frame will be added below
                            shotComplete = true;
                        }
                        
                        // Record while actively recording
                        if (recordingActive) {
                            const elapsed = video.currentTime - startTime;
                            
                            // Convert MediaPipe landmarks (normalized 0-1) to pixel coordinates using get3DPoint
                            // Use currentResults.poseLandmarks directly (has proper visibility property)
                            const landmarks3D = [];
                            for (let i = 0; i < 33; i++) {
                                const pt = window.get3DPoint ? 
                                    window.get3DPoint(currentResults.poseLandmarks, i, video.videoWidth, video.videoHeight) :
                                    (currentResults.poseLandmarks[i] ? [
                                        currentResults.poseLandmarks[i].x * video.videoWidth, 
                                        currentResults.poseLandmarks[i].y * video.videoHeight, 
                                        (currentResults.poseLandmarks[i].z || 0) * video.videoWidth
                                    ] : null);
                                landmarks3D.push(pt || [NaN, NaN, NaN]);
                            }
                            
                            // Normalize pose orientation (using function from app.js)
                            let normalizedLandmarks = landmarks3D;
                            if (window.normalizePoseOrientation) {
                                normalizedLandmarks = window.normalizePoseOrientation(landmarks3D);
                            }
                            
                            // Extract detailed metrics
                            let detailedMetrics = {};
                            if (window.extractDetailedMetricsFromLandmarks) {
                                detailedMetrics = window.extractDetailedMetricsFromLandmarks(normalizedLandmarks);
                            }
                            
                            // Calculate basic angles using get3DPoint and calculateAngle
                            // Use currentResults.poseLandmarks directly (has proper visibility)
                            let elbowAngle = null, wristAngle = null, armAngle = null;
                            if (window.get3DPoint && window.calculateAngle) {
                                const rightShoulder = window.get3DPoint(currentResults.poseLandmarks, 12, video.videoWidth, video.videoHeight);
                                const rightElbow = window.get3DPoint(currentResults.poseLandmarks, 14, video.videoWidth, video.videoHeight);
                                const rightWrist = window.get3DPoint(currentResults.poseLandmarks, 16, video.videoWidth, video.videoHeight);
                                const rightIndex = window.get3DPoint(currentResults.poseLandmarks, 20, video.videoWidth, video.videoHeight);
                                const leftShoulder = window.get3DPoint(currentResults.poseLandmarks, 11, video.videoWidth, video.videoHeight);
                                
                                if (rightShoulder && rightElbow && rightWrist) {
                                    elbowAngle = window.calculateAngle(rightShoulder, rightElbow, rightWrist);
                                }
                                if (rightElbow && rightWrist && rightIndex) {
                                    wristAngle = window.calculateAngle(rightElbow, rightWrist, rightIndex);
                                }
                                if (leftShoulder && rightShoulder && rightElbow) {
                                    armAngle = window.calculateAngle(leftShoulder, rightShoulder, rightElbow);
                                }
                            }
                            
                            // Fallback: use angles from extractAnglesFromLandmarks if basic calculation failed
                            if ((elbowAngle === null || isNaN(elbowAngle)) && angles.right_elbow !== null && angles.right_elbow !== undefined) {
                                elbowAngle = angles.right_elbow;
                            }
                            if ((wristAngle === null || isNaN(wristAngle)) && angles.wrist_snap !== null && angles.wrist_snap !== undefined) {
                                wristAngle = angles.wrist_snap;
                            }
                            
                            extractedPoses.push({
                                state: state,
                                time: elapsed,
                                elbow_angle: elbowAngle,
                                wrist_angle: wristAngle,
                                arm_angle: armAngle,
                                landmarks: normalizedLandmarks,
                                metrics: detailedMetrics
                            });
                            extractedStages.push(state);
                            extractedAngles.push(angles);
                            
                            // Store normalized landmarks with visibility for animation loop (same as shot sync tab)
                            const normalizedForAnimation = landmarks.map(lm => ({
                                x: lm.x,
                                y: lm.y,
                                z: lm.z || 0,
                                visibility: lm.visibility !== undefined ? lm.visibility : 1.0
                            }));
                            benchmark3DPoses.push(normalizedForAnimation);
                            benchmark3DStages.push(state);
                        }
                    }
                });
                
                await pose.initialize();
                
                // Process each frame
                for (let frameIndex = 0; frameIndex < totalFrames; frameIndex++) {
                    // Stop if we've captured a complete shot
                    if (shotComplete && extractedPoses.length > 0) {
                        console.log('Complete shot sequence captured, stopping processing');
                        break;
                    }
                    
                    const targetTime = frameIndex * frameInterval;
                    if (targetTime >= duration) break;
                    
                    // Update status
                    if (statusText && frameIndex % 30 === 0) {
                        const progress = Math.round((frameIndex / totalFrames) * 100);
                        statusText.textContent = `Processing frame ${frameIndex}/${totalFrames} (${progress}%)...`;
                    }
                    
                    // Seek to frame
                    video.currentTime = targetTime;
                    
                    // Wait for seek to complete
                    await new Promise((resolve) => {
                        if (Math.abs(video.currentTime - targetTime) < 0.1) {
                            resolve();
                            return;
                        }
                        const onSeeked = () => {
                            video.removeEventListener('seeked', onSeeked);
                            resolve();
                        };
                        video.addEventListener('seeked', onSeeked);
                        setTimeout(() => {
                            video.removeEventListener('seeked', onSeeked);
                            resolve();
                        }, 1000);
                    });
                    
                    // Wait for frame to render
                    await new Promise(resolve => setTimeout(resolve, 50));
                    
                    // Check if video is ready
                    if (video.readyState < 2) {
                        await new Promise(resolve => setTimeout(resolve, 50));
                    }
                    
                    if (video.videoWidth > 0 && video.videoHeight > 0 && video.readyState >= 2) {
                        processCanvas.width = video.videoWidth;
                        processCanvas.height = video.videoHeight;
                        
                        // Update progress in overlay
                        if (statusText && frameIndex % 10 === 0) {
                            const progress = Math.round((frameIndex / totalFrames) * 100);
                            statusText.textContent = `Extracting skeleton... ${progress}%`;
                        }
                        
                        try {
                            ctx.drawImage(video, 0, 0, processCanvas.width, processCanvas.height);
                            await pose.send({ image: processCanvas });
                        } catch (error) {
                            console.error(`Error processing frame ${frameIndex}:`, error);
                        }
                    }
                }
                
                // Close pose
                pose.close();
                URL.revokeObjectURL(video.src);
                
                // Hide processing overlay (but keep skeleton visible if we have data)
                if (processingOverlay) processingOverlay.style.display = 'none';
                
                if (extractedPoses.length > 0) {
                    benchmarkVideoData = extractedPoses;
                    
                    statusEl.style.background = '#dcfce7';
                    statusEl.style.color = '#166534';
                    statusEl.textContent = ` Successfully processed ${extractedPoses.length} frames`;
                    
                    // Show metrics display
                    document.getElementById('benchmarkMetricsDisplay').style.display = 'block';
                    
                    // Initialize display
                    currentDisplayMode = 'averaged';
                    updateMetricsDisplay();
                    
                    // Start animation loop (EXACT same as shot sync tab)
                    if (benchmark3DPoses.length > 0) {
                        benchmarkCurrentFrameIndex = 0;
                        isBenchmarkPlaying = true;
                        animateBenchmarkLoop();
                    }
                } else {
                    throw new Error('No shot sequence detected in video. Please ensure the video contains a clear shooting motion (pre_shot  follow_through).');
                }
                
            } catch (error) {
                console.error('Error processing video:', error);
                if (processingOverlay) processingOverlay.style.display = 'none';
                if (skeletonContainer) skeletonContainer.style.display = 'none';
                statusEl.style.background = '#fef2f2';
                statusEl.style.color = '#991b1b';
                statusEl.textContent = ` Error: ${error.message}`;
                console.error('Full error details:', error);
            } finally {
                processBtn.disabled = false;
            }
        });

        // Display mode toggle handlers
        document.getElementById('showSingleFrameBtn')?.addEventListener('click', function() {
            currentDisplayMode = 'single';
            document.getElementById('showSingleFrameBtn').classList.add('active');
            document.getElementById('showAveragedBtn').classList.remove('active');
            document.getElementById('frameSelectorContainer').style.display = 'flex';
            updateMetricsDisplay();
        });

        document.getElementById('showAveragedBtn')?.addEventListener('click', function() {
            currentDisplayMode = 'averaged';
            document.getElementById('showAveragedBtn').classList.add('active');
            document.getElementById('showSingleFrameBtn').classList.remove('active');
            document.getElementById('frameSelectorContainer').style.display = 'none';
            updateMetricsDisplay();
        });

        // Frame slider handler
        document.getElementById('frameSlider')?.addEventListener('input', function(e) {
            currentFrameIndex = parseInt(e.target.value);
            document.getElementById('frameNumber').textContent = `Frame ${currentFrameIndex}`;
            updateMetricsDisplay();
        });

        // Update metrics display
        function updateMetricsDisplay() {
            if (!benchmarkVideoData || benchmarkVideoData.length === 0) return;

            const tbody = document.getElementById('benchmarkMetricsTableBody');
            tbody.innerHTML = '';

            let metricsToDisplay = {};

            if (currentDisplayMode === 'averaged') {
                // Calculate averages across all frames
                const metricSums = {};
                const metricCounts = {};
                
                benchmarkVideoData.forEach(frame => {
                    // Include basic angles
                    if (frame.elbow_angle !== null && frame.elbow_angle !== undefined) {
                        if (!metricSums.elbow_angle) {
                            metricSums.elbow_angle = 0;
                            metricCounts.elbow_angle = 0;
                        }
                        metricSums.elbow_angle += frame.elbow_angle;
                        metricCounts.elbow_angle++;
                    }
                    if (frame.wrist_angle !== null && frame.wrist_angle !== undefined) {
                        if (!metricSums.wrist_angle) {
                            metricSums.wrist_angle = 0;
                            metricCounts.wrist_angle = 0;
                        }
                        metricSums.wrist_angle += frame.wrist_angle;
                        metricCounts.wrist_angle++;
                    }
                    if (frame.arm_angle !== null && frame.arm_angle !== undefined) {
                        if (!metricSums.arm_angle) {
                            metricSums.arm_angle = 0;
                            metricCounts.arm_angle = 0;
                        }
                        metricSums.arm_angle += frame.arm_angle;
                        metricCounts.arm_angle++;
                    }
                    
                    // Include detailed metrics
                    if (frame.metrics) {
                        Object.keys(frame.metrics).forEach(key => {
                            const value = frame.metrics[key];
                            if (value !== null && value !== undefined && !isNaN(value)) {
                                if (!metricSums[key]) {
                                    metricSums[key] = 0;
                                    metricCounts[key] = 0;
                                }
                                metricSums[key] += value;
                                metricCounts[key]++;
                            }
                        });
                    }
                });

                Object.keys(metricSums).forEach(key => {
                    metricsToDisplay[key] = metricSums[key] / metricCounts[key];
                });
            } else {
                // Show single frame
                const frame = benchmarkVideoData[currentFrameIndex];
                if (frame) {
                    // Include basic angles
                    if (frame.elbow_angle !== null && frame.elbow_angle !== undefined) {
                        metricsToDisplay.elbow_angle = frame.elbow_angle;
                    }
                    if (frame.wrist_angle !== null && frame.wrist_angle !== undefined) {
                        metricsToDisplay.wrist_angle = frame.wrist_angle;
                    }
                    if (frame.arm_angle !== null && frame.arm_angle !== undefined) {
                        metricsToDisplay.arm_angle = frame.arm_angle;
                    }
                    // Include detailed metrics
                    if (frame.metrics) {
                        Object.assign(metricsToDisplay, frame.metrics);
                    }
                }
            }

            // Define metric labels and units (including basic angles)
            const metricInfo = {
                // Basic angles (from original extraction)
                elbow_angle: { label: 'Elbow Angle', unit: '' },
                wrist_angle: { label: 'Wrist Angle', unit: '' },
                arm_angle: { label: 'Arm Angle', unit: '' },
                // Detailed metrics
                wrist_snap: { label: 'Wrist Snap', unit: '' },
                elbow_extension: { label: 'Elbow Extension', unit: '' },
                knee_bend: { label: 'Knee Bend', unit: '' },
                elbow_flare: { label: 'Elbow Flare', unit: '' },
                trunk_lean: { label: 'Trunk Lean', unit: '' },
                foot_alignment: { label: 'Foot Alignment', unit: '' },
                shoulder_angle: { label: 'Shoulder Angle', unit: '' },
                foot_angle: { label: 'Foot Angle', unit: '' },
                release_height: { label: 'Release Height', unit: ' (relative)' }
            };

            // Populate table
            Object.keys(metricsToDisplay).forEach(key => {
                const value = metricsToDisplay[key];
                if (value !== null && value !== undefined) {
                    const info = metricInfo[key] || { label: key, unit: '' };
                    const row = document.createElement('tr');
                    row.innerHTML = `
                        <td style="padding: 12px; border: 1px solid var(--border-color); font-weight: 500; color: var(--text-dark);">${info.label}</td>
                        <td style="padding: 12px; border: 1px solid var(--border-color); text-align: center; font-family: 'Courier New', monospace; color: var(--text-dark);">${value.toFixed(2)}</td>
                        <td style="padding: 12px; border: 1px solid var(--border-color); text-align: center; color: var(--text-gray);">${info.unit}</td>
                    `;
                    tbody.appendChild(row);
                }
            });

            // Update frame slider if in single frame mode
            if (currentDisplayMode === 'single') {
                const slider = document.getElementById('frameSlider');
                slider.max = benchmarkVideoData.length - 1;
                slider.value = currentFrameIndex;
            }
        }

        // Save benchmark form handler
        document.getElementById('saveBenchmarkForm')?.addEventListener('submit', async function(e) {
            e.preventDefault();
            
            if (!benchmarkVideoData || benchmarkVideoData.length === 0) {
                alert('Please process a video first');
                return;
            }

            const firstName = document.getElementById('benchmarkFirstName').value.trim();
            const lastName = document.getElementById('benchmarkLastName').value.trim();

            if (!firstName || !lastName) {
                alert('Please enter both first and last name');
                return;
            }

            const statusEl = document.getElementById('saveBenchmarkStatus');
            statusEl.style.display = 'block';
            statusEl.style.background = '#f0f9ff';
            statusEl.style.color = '#0369a1';
            statusEl.textContent = 'Saving benchmark...';

            try {
                // Create player identifier (lowercase, no spaces)
                const playerId = `${firstName.toLowerCase()}_${lastName.toLowerCase()}`;
                
                // Generate benchmark file content
                const benchmarkContent = `// ${firstName} ${lastName} benchmark data (extracted from video)
const ${playerId}_data = ${JSON.stringify(benchmarkVideoData, null, 2)};
`;

                // Create blob and download
                const blob = new Blob([benchmarkContent], { type: 'text/javascript' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${playerId}_benchmark.js`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                statusEl.style.background = '#dcfce7';
                statusEl.style.color = '#166534';
                statusEl.innerHTML = ` Benchmark saved as <strong>${playerId}_benchmark.js</strong><br>Please save the downloaded file to: <code>tool/player_data/${playerId}_benchmark.js</code>`;

                // Reset form
                document.getElementById('benchmarkFirstName').value = '';
                document.getElementById('benchmarkLastName').value = '';

            } catch (error) {
                console.error('Error saving benchmark:', error);
                statusEl.style.background = '#fef2f2';
                statusEl.style.color = '#991b1b';
                statusEl.textContent = ` Error: ${error.message}`;
            }
        });
        
        // Save Player Data Form Handler (Shot Sync Tab)
        document.getElementById('savePlayerDataFormElement')?.addEventListener('submit', async function(e) {
            e.preventDefault();
            
            if (!loop3DPoses || loop3DPoses.length === 0) {
                alert('Please generate animation first by clicking "Generate Animation"');
                return;
            }

            const firstName = document.getElementById('playerFirstName').value.trim();
            const lastName = document.getElementById('playerLastName').value.trim();

            if (!firstName || !lastName) {
                alert('Please enter both first and last name');
                return;
            }

            const statusEl = document.getElementById('savePlayerDataStatus');
            statusEl.style.display = 'block';
            statusEl.style.background = '#f0f9ff';
            statusEl.style.color = '#0369a1';
            statusEl.textContent = 'Extracting angles and saving data...';

            try {
                // Create player identifier (lowercase, no spaces)
                const playerId = `${firstName.toLowerCase()}_${lastName.toLowerCase()}`;
                
                // Verify we have data
                console.log('Saving player data:', {
                    poses: loop3DPoses?.length || 0,
                    stages: loop3DStages?.length || 0,
                    angles: loop3DAngles?.length || 0
                });
                
                if (!loop3DAngles || loop3DAngles.length === 0) {
                    throw new Error('No angle data found. Please ensure the video has been processed.');
                }
                
                // Extract data from loop3DPoses, loop3DStages, and loop3DAngles
                // Format similar to benchmarkVideoData
                const playerData = [];
                
                for (let i = 0; i < loop3DPoses.length; i++) {
                    const frameData = {
                        state: loop3DStages[i] || 'neutral',
                        time: i * (1/30), // Assuming 30 fps
                        elbow_angle: null,
                        wrist_angle: null,
                        arm_angle: null,
                        landmarks: loop3DPoses[i] || [],
                        metrics: {}
                    };
                    
                    // Extract angles from loop3DAngles if available
                    if (loop3DAngles && loop3DAngles[i]) {
                        const angles = loop3DAngles[i];
                        
                        // Log first frame to verify calculations
                        if (i === 0) {
                            console.log('Sample angles from first frame:', angles);
                        }
                        
                        // Map angles to frame data
                        if (angles.right_elbow !== null && angles.right_elbow !== undefined) {
                            frameData.elbow_angle = angles.right_elbow;
                        }
                        if (angles.wrist_snap !== null && angles.wrist_snap !== undefined) {
                            frameData.wrist_angle = angles.wrist_snap;
                        }
                        // Add other angles if available
                        if (angles.left_elbow !== null && angles.left_elbow !== undefined) {
                            frameData.arm_angle = angles.left_elbow;
                        }
                        
                        // Store ALL angles in metrics (including elbow_flare, wrist_snap, etc.)
                        frameData.metrics = { ...angles };
                    }
                    
                    playerData.push(frameData);
                }
                
                // Log sample data to verify
                if (playerData.length > 0) {
                    console.log('Sample frame data:', {
                        state: playerData[0].state,
                        metrics: playerData[0].metrics,
                        has_elbow_flare: 'elbow_flare' in (playerData[0].metrics || {}),
                        has_wrist_snap: 'wrist_snap' in (playerData[0].metrics || {})
                    });
                }
                
                // Save to server via API
                try {
                    const response = await fetch('/api/save_player_data', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            player_id: playerId,
                            player_data: playerData,
                            first_name: firstName,
                            last_name: lastName
                        })
                    });
                    
                    const result = await response.json();
                    
                    if (!response.ok) {
                        throw new Error(result.error || 'Failed to save player data');
                    }
                    
                    statusEl.style.background = '#dcfce7';
                    statusEl.style.color = '#166534';
                    statusEl.innerHTML = ` Player data saved successfully!<br>File: <strong>${result.filename}</strong><br>Location: <code>tool/player_data/${result.filename}</code><br>Extracted ${playerData.length} frames with angles`;
                } catch (apiError) {
                    console.warn('API save failed, falling back to download:', apiError);
                    // Fallback: download file if API fails
                    const playerDataContent = `// ${firstName} ${lastName} player data (extracted from video)
const ${playerId}_data = ${JSON.stringify(playerData, null, 2)};
`;

                    const blob = new Blob([playerDataContent], { type: 'text/javascript' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `${playerId}.js`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);

                    statusEl.style.background = '#fef3c7';
                    statusEl.style.color = '#92400e';
                    statusEl.innerHTML = ` Saved via download (API unavailable)<br>File: <strong>${playerId}.js</strong><br>Please manually save to: <code>tool/player_data/${playerId}.js</code><br>Extracted ${playerData.length} frames with angles`;
                }

                // Reset form
                document.getElementById('playerFirstName').value = '';
                document.getElementById('playerLastName').value = '';

            } catch (error) {
                console.error('Error saving player data:', error);
                statusEl.style.background = '#fef2f2';
                statusEl.style.color = '#991b1b';
                statusEl.textContent = ` Error: ${error.message}`;
            }
        });
        
        // Download Extraction Button Handler
        document.getElementById('downloadExtractionBtn')?.addEventListener('click', function() {
            if (!loop3DPoses || loop3DPoses.length === 0) {
                alert('No extraction data available. Please generate animation first by clicking "Generate Animation"');
                return;
            }
            
            if (!loop3DAngles || loop3DAngles.length === 0) {
                alert('No angle data found. Please ensure the video has been processed.');
                return;
            }
            
            try {
                // Extract data from loop3DPoses, loop3DStages, and loop3DAngles
                // Format similar to benchmarkVideoData
                const playerData = [];
                
                for (let i = 0; i < loop3DPoses.length; i++) {
                    const frameData = {
                        state: loop3DStages[i] || 'neutral',
                        time: i * (1/30), // Assuming 30 fps
                        elbow_angle: null,
                        wrist_angle: null,
                        arm_angle: null,
                        landmarks: loop3DPoses[i] || [],
                        metrics: {}
                    };
                    
                    // Extract angles from loop3DAngles if available
                    if (loop3DAngles && loop3DAngles[i]) {
                        const angles = loop3DAngles[i];
                        
                        // Map angles to frame data
                        if (angles.right_elbow !== null && angles.right_elbow !== undefined) {
                            frameData.elbow_angle = angles.right_elbow;
                        }
                        if (angles.wrist_snap !== null && angles.wrist_snap !== undefined) {
                            frameData.wrist_angle = angles.wrist_snap;
                        }
                        // Add other angles if available
                        if (angles.left_elbow !== null && angles.left_elbow !== undefined) {
                            frameData.arm_angle = angles.left_elbow;
                        }
                        
                        // Store ALL angles in metrics (including elbow_flare, wrist_snap, etc.)
                        frameData.metrics = { ...angles };
                    }
                    
                    playerData.push(frameData);
                }
                
                // Create JS file content
                const date = new Date().toISOString().split('T')[0];
                const jsContent = `// User extraction data (extracted from video on ${date})
const user_extraction_data = ${JSON.stringify(playerData, null, 2)};
`;
                
                const blob = new Blob([jsContent], { type: 'text/javascript' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `user_extraction_${date}.js`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                console.log('Downloaded extraction data:', {
                    frames: playerData.length,
                    date: date
                });
            } catch (error) {
                console.error('Error downloading extraction:', error);
                alert('Error downloading extraction: ' + error.message);
            }
        });
        
        // Clip Shots Button Handler
        document.getElementById('clipShotsBtn')?.addEventListener('click', function() {
            if (!loop3DPoses || loop3DPoses.length === 0) {
                alert('No shot data to clip. Please generate animation first.');
                return;
            }
            
            const statusEl = document.getElementById('clipStatus');
            statusEl.style.display = 'block';
            statusEl.style.background = '#f0f9ff';
            statusEl.style.color = '#0369a1';
            statusEl.textContent = 'Clipping shots...';
            
            try {
                const originalLength = loop3DPoses.length;
                const clippedPoses = [];
                const clippedStages = [];
                const clippedAngles = [];
                
                // Find first pre_shot frame
                let startIndex = -1;
                for (let i = 0; i < loop3DStages.length; i++) {
                    if (loop3DStages[i] === 'pre_shot') {
                        startIndex = i;
                        break;
                    }
                }
                
                if (startIndex === -1) {
                    throw new Error('No pre_shot frames found');
                }
                
                // Clip from first pre_shot to the end of the data
                // Just keep all frames from pre_shot onwards
                for (let i = startIndex; i < loop3DPoses.length; i++) {
                    const landmarks = loop3DPoses[i];
                    const stage = loop3DStages[i];
                    
                    // Add all frames from startIndex to end
                    clippedPoses.push(landmarks);
                    clippedStages.push(stage);
                    if (loop3DAngles && loop3DAngles[i]) {
                        clippedAngles.push(loop3DAngles[i]);
                    } else {
                        clippedAngles.push({});
                    }
                }
                
                // Update global arrays with clipped data
                loop3DPoses = clippedPoses;
                loop3DStages = clippedStages;
                loop3DAngles = clippedAngles;
                
                // Update frame slider
                const slider = document.getElementById('frameSlider');
                if (slider) {
                    slider.max = loop3DPoses.length - 1;
                    slider.value = 0;
                }
                
                // Update frame counter
                const counter = document.getElementById('frameCounter');
                if (counter) {
                    counter.textContent = `Frame: 1/${loop3DPoses.length}`;
                }
                
                // Update skeleton to show first frame of clipped data
                if (loop3DPoses.length > 0 && loopScene && loopRenderer) {
                    updateLoop3DSkeleton(loop3DPoses[0], loop3DStages[0]);
                }
                
                statusEl.style.background = '#dcfce7';
                statusEl.style.color = '#166534';
                statusEl.innerHTML = ` Shots clipped!<br>Original: ${originalLength} frames  Clipped: ${loop3DPoses.length} frames<br>Range: Pre-shot to elbow drop`;
                
                console.log(`Clipped shots: ${originalLength}  ${loop3DPoses.length} frames`);
                
            } catch (error) {
                console.error('Error clipping shots:', error);
                statusEl.style.background = '#fef2f2';
                statusEl.style.color = '#991b1b';
                statusEl.textContent = ` Error: ${error.message}`;
            }
        });

    </script>
</body>
</html>

